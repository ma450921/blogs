{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/images/graphics1/graphics1_banner.jpeg","path":"images/graphics1/graphics1_banner.jpeg","modified":0,"renderable":0},{"_id":"source/images/graphics1/graphics1_reflection.png","path":"images/graphics1/graphics1_reflection.png","modified":0,"renderable":0},{"_id":"source/images/graphics1/graphics1_rotate.png","path":"images/graphics1/graphics1_rotate.png","modified":0,"renderable":0},{"_id":"source/images/graphics1/graphics1_scale.png","path":"images/graphics1/graphics1_scale.png","modified":0,"renderable":0},{"_id":"source/images/graphics1/graphics1_shear.png","path":"images/graphics1/graphics1_shear.png","modified":0,"renderable":0},{"_id":"source/images/graphics3/graphic3_orthographic.png","path":"images/graphics3/graphic3_orthographic.png","modified":0,"renderable":0},{"_id":"source/images/graphics3/graphic3_orthographic_point.png","path":"images/graphics3/graphic3_orthographic_point.png","modified":0,"renderable":0},{"_id":"source/images/graphics3/graphics3_banner.png","path":"images/graphics3/graphics3_banner.png","modified":0,"renderable":0},{"_id":"source/images/graphics3/graphics3_camera.png","path":"images/graphics3/graphics3_camera.png","modified":0,"renderable":0},{"_id":"source/images/graphics3/graphics3_orthographic_transform.png","path":"images/graphics3/graphics3_orthographic_transform.png","modified":0,"renderable":0},{"_id":"source/images/graphics3/graphics3_transformation.png","path":"images/graphics3/graphics3_transformation.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_banner.png","path":"images/graphics4/graphics4_banner.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_bound_box.png","path":"images/graphics4/graphics4_bound_box.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_bresenham.png","path":"images/graphics4/graphics4_bresenham.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_inside.png","path":"images/graphics4/graphics4_inside.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_lines.png","path":"images/graphics4/graphics4_lines.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_pixels.png","path":"images/graphics4/graphics4_pixels.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_sample.png","path":"images/graphics4/graphics4_sample.png","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_Moiré.jpg","path":"images/graphics5/graphics5_Moiré.jpg","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_SSAA.png","path":"images/graphics5/graphics5_SSAA.png","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_aliasing.png","path":"images/graphics5/graphics5_aliasing.png","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_banner.jpg","path":"images/graphics5/graphics5_banner.jpg","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_frequency.png","path":"images/graphics5/graphics5_frequency.png","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_jaggies.png","path":"images/graphics5/graphics5_jaggies.png","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_reconstructed.png","path":"images/graphics5/graphics5_reconstructed.png","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_sample.png","path":"images/graphics5/graphics5_sample.png","modified":0,"renderable":0},{"_id":"source/images/latex/latex1_graph1.png","path":"images/latex/latex1_graph1.png","modified":0,"renderable":0},{"_id":"source/images/latex/latex1_graph2.png","path":"images/latex/latex1_graph2.png","modified":0,"renderable":0},{"_id":"source/images/latex/latex1_graph3.png","path":"images/latex/latex1_graph3.png","modified":0,"renderable":0},{"_id":"source/images/latex/latex1_graph4.png","path":"images/latex/latex1_graph4.png","modified":0,"renderable":0},{"_id":"source/images/latex/latex1_graph5.png","path":"images/latex/latex1_graph5.png","modified":0,"renderable":0},{"_id":"source/images/latex/latex_head.png","path":"images/latex/latex_head.png","modified":0,"renderable":0},{"_id":"source/images/graphics2/graphics2_banner.jpeg","path":"images/graphics2/graphics2_banner.jpeg","modified":0,"renderable":0},{"_id":"source/images/graphics2/graphics2_compose.png","path":"images/graphics2/graphics2_compose.png","modified":0,"renderable":0},{"_id":"source/images/graphics2/graphics2_decompose.png","path":"images/graphics2/graphics2_decompose.png","modified":0,"renderable":0},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/code_image.png","path":"img/code_image.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/computer_tools.jpg","path":"img/computer_tools.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/cyber1.jpg","path":"img/cyber1.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/cyber2.jpg","path":"img/cyber2.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/cyber3.jpg","path":"img/cyber3.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/spaceBanner.jpg","path":"img/spaceBanner.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/clipboard-use.js","path":"js/clipboard-use.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/debouncer.js","path":"js/debouncer.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/images/graphics6/graphics6_banner.jpg","path":"images/graphics6/graphics6_banner.jpg","modified":0,"renderable":0},{"_id":"source/images/graphics6/graphics6_painter.png","path":"images/graphics6/graphics6_painter.png","modified":1,"renderable":0},{"_id":"source/images/graphics6/graphics6_shading.png","path":"images/graphics6/graphics6_shading.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/ComputerGraphics1.md","hash":"7a5a64db9cf09953d02f181566969e06d2a65488","modified":1601710823072},{"_id":"source/_posts/ComputerGraphics3.md","hash":"c71a92e3d603a17b2ed6894c7633c6179b29e23d","modified":1601710820317},{"_id":"source/.DS_Store","hash":"21421bf64160d8654e10cdb61d42855f1223f7ea","modified":1601716800194},{"_id":"source/_posts/ComputerGraphics2.md","hash":"2cc4134a4260c3df400e885f62a3329f40151d45","modified":1601710524581},{"_id":"source/_posts/ComputerGraphics5.md","hash":"0c06421b09dd2543f9af17faa5bdb2ea827b03ee","modified":1601716296667},{"_id":"source/_posts/ComputerGraphics4.md","hash":"a08e4d8ceb83f05ee475e031862b4ef9618e0fe2","modified":1601710821658},{"_id":"source/_posts/ComputerGraphics6.md","hash":"77098c0b1967e183badd716821b99ff56dcc34e9","modified":1601782081313},{"_id":"source/_posts/ComputerGraphics7.md","hash":"f942fc7f5b84349782020b759f98679a9e4e0c68","modified":1601710841278},{"_id":"source/_posts/latexlearning1.md","hash":"a801e559268a9cfaf6674cd17f7c26b7783ba8b6","modified":1597116503746},{"_id":"source/_posts/latexlearning2.md","hash":"35e9d07778becafeb8bc5b27a9a953441f0465f4","modified":1597125562346},{"_id":"source/images/.DS_Store","hash":"9677cc15e4ae0084124649290135d5cf59c4322a","modified":1601719991430},{"_id":"source/images/graphics1/graphics1_banner.jpeg","hash":"67e0c1dcfc0277f456474198cb37161d74997e6f","modified":1601687784000},{"_id":"source/images/graphics1/graphics1_reflection.png","hash":"f1403c8080f54b84a0a353b5d9284db0de91d41d","modified":1601687784000},{"_id":"source/images/graphics1/graphics1_rotate.png","hash":"87f933a2979fa357383b912e5099c023c00556d7","modified":1601687784000},{"_id":"source/images/graphics1/graphics1_scale.png","hash":"7e2d1af3f5545c706664a180ca1608e66ad86744","modified":1601687784000},{"_id":"source/about/index.md","hash":"d62e53649a8f4a2706d0c68ab0ca93acab0c85af","modified":1597037261740},{"_id":"source/images/graphics3/graphic3_orthographic.png","hash":"bb2ec145ea331024692e9d97a498419a95cb70ec","modified":1601687862000},{"_id":"source/images/graphics1/graphics1_shear.png","hash":"4b6f7e2b826a54f583170d8c0d8a88824c612bf1","modified":1601687786000},{"_id":"source/images/graphics3/graphic3_orthographic_point.png","hash":"e636284be174f911d1466c641c87f3e932b81d96","modified":1601687862000},{"_id":"source/images/graphics3/graphics3_camera.png","hash":"da6b99e4cb56a867f48f164c8b711438507294e0","modified":1601687862000},{"_id":"source/images/graphics3/graphics3_transformation.png","hash":"fa2bd2ddffe3a1f2c64e3291a8bbd26dd1946697","modified":1601687862000},{"_id":"source/images/graphics3/.DS_Store","hash":"1042c6723400d6ecb0cd6b7471d48b3e3cc8107a","modified":1601716533478},{"_id":"source/images/graphics4/graphics4_banner.png","hash":"95a3b203897307e7aec529c881f1f9c8874493b1","modified":1601687892000},{"_id":"source/images/graphics4/graphics4_bound_box.png","hash":"42c7ad20384c763210c2f3c9755e620d47d74baf","modified":1601687892000},{"_id":"source/images/graphics4/graphics4_bresenham.png","hash":"98314d14ea732c093eef8a6350fe7cd5f4365b25","modified":1601687892000},{"_id":"source/images/graphics4/graphics4_inside.png","hash":"e2e3eea5291b88a0231e54fdbb811a2a945aa372","modified":1601687892000},{"_id":"source/images/graphics4/graphics4_lines.png","hash":"ee409c72df646791e566f290562b442f32e029c0","modified":1601687892000},{"_id":"source/images/graphics4/graphics4_pixels.png","hash":"418dc105a6cbf84e4b13294f6e5f8e505bc6bef9","modified":1601687892000},{"_id":"source/images/graphics4/graphics4_sample.png","hash":"1785a9591ce6fbb287e4512d4e33777d947fc977","modified":1601687892000},{"_id":"source/images/graphics4/.DS_Store","hash":"290462fec27446a2b601fe9262c4e3a32603e24f","modified":1601716560539},{"_id":"source/images/graphics5/.DS_Store","hash":"57db843f0b328d908d6afd368ae06461876f05c3","modified":1601715619807},{"_id":"source/images/graphics5/graphics5_sample.png","hash":"f257764d7f935cb240fb9f989cbf50f4a33a5ae9","modified":1600926141517},{"_id":"source/images/graphics1/.DS_Store","hash":"02b0950f2867a15aa8503c6e46847d3dca5d7268","modified":1601716467424},{"_id":"source/images/graphics3/graphics3_orthographic_transform.png","hash":"58b34804bddc2cc2a34123faac5bcefb33fc203d","modified":1601687862000},{"_id":"source/images/latex/latex1_graph1.png","hash":"ab13b12abe952ac3bdb4d8d537b1ce6de5e35872","modified":1597113792835},{"_id":"source/images/latex/latex1_graph4.png","hash":"5a28ff28638f940672333fdb20021acb63aad9b5","modified":1597116203358},{"_id":"source/images/latex/latex1_graph3.png","hash":"9aac9d36160a2226f46a821ad6ade7c35385d443","modified":1597116073034},{"_id":"source/images/latex/latex1_graph2.png","hash":"adeafb354599b21eab18179a37efe22d321db754","modified":1597115655881},{"_id":"source/images/graphics2/graphics2_banner.jpeg","hash":"37da4d3b58631297d7d5cd82157dad1d191856eb","modified":1601687832000},{"_id":"source/images/graphics2/graphics2_compose.png","hash":"2d9c1f16bb2c5ad144fe98edba69383c21f53683","modified":1601687832000},{"_id":"source/images/graphics2/graphics2_decompose.png","hash":"2a4b0122cec80d8db30ff5be56368c29006f8bc1","modified":1601687832000},{"_id":"source/images/latex/latex1_graph5.png","hash":"92c02f0ba26533621f3afe8a788d26d76c352f0d","modified":1597116326970},{"_id":"source/images/graphics2/.DS_Store","hash":"7535f5bf7cc37482bc8bf3d686d9bce5a044bdf6","modified":1601716501053},{"_id":"source/images/graphics3/graphics3_banner.png","hash":"822b9a3a4527ecd7394662daf9e3e1670e18b83c","modified":1601687862000},{"_id":"source/images/graphics5/graphics5_Moiré.jpg","hash":"caed5bedb970e632662792c256fc47db4c00018b","modified":1601205112797},{"_id":"source/images/graphics5/graphics5_banner.jpg","hash":"f721a393d1ec3b3c30a1f07307a3edde80748a9c","modified":1599617536521},{"_id":"source/images/graphics5/graphics5_SSAA.png","hash":"4ae7f970a6e47493726c1411973e09a59fff144f","modified":1601711789052},{"_id":"source/images/graphics5/graphics5_aliasing.png","hash":"7b236d2a7c66167926db7acda42b8f43a40e98fa","modified":1601205489520},{"_id":"source/images/graphics5/graphics5_frequency.png","hash":"1bc1e776b996b49005d688c8a5e20bdc3722a213","modified":1601709979896},{"_id":"source/images/graphics5/graphics5_reconstructed.png","hash":"ecdd4b9e8a2ead12ef00696f9c6efa62609872be","modified":1601271810769},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1591272997000},{"_id":"themes/fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1591272997000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1591272997000},{"_id":"themes/fluid/.DS_Store","hash":"a4f71eb0200abd95044f0440094b10bc71a3e410","modified":1597041781196},{"_id":"themes/fluid/LICENSE","hash":"5b919c12e4f5f5cdebb7c17ded4f10f1ebe64811","modified":1591272997000},{"_id":"themes/fluid/.eslintrc","hash":"0a59eec340b771758cf736290272c549d81ef88c","modified":1591272997000},{"_id":"themes/fluid/README.md","hash":"23729af73d967cd11a84bed7c839454df3169eb9","modified":1591272997000},{"_id":"themes/fluid/README_en.md","hash":"7db56a9214405dd3612b808baaf0847ae4986c6a","modified":1591272997000},{"_id":"themes/fluid/_static_prefix.yml","hash":"19b4414055b720ece8d78674085f4e1199ccc128","modified":1591272997000},{"_id":"themes/fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":1591272997000},{"_id":"themes/fluid/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1591272997000},{"_id":"themes/fluid/package.json","hash":"d37c2637ed470ed61dd63142ab1291233267abdb","modified":1591272997000},{"_id":"themes/fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1591272997000},{"_id":"themes/fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1591272997000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1591272997000},{"_id":"themes/fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1591272997000},{"_id":"themes/fluid/layout/categories.ejs","hash":"3b8589675338c7b3e1849104b7bb15ac477fce4e","modified":1591272997000},{"_id":"themes/fluid/layout/about.ejs","hash":"a23e73c92b6d3ff0df55dbd1aa774065a3291d8d","modified":1591272997000},{"_id":"themes/fluid/layout/archive.ejs","hash":"783ce7efe83bd72e3c767fd5a190ad38113ff34f","modified":1591272997000},{"_id":"themes/fluid/layout/category.ejs","hash":"a3f1195424a24ea2b6d996e504b503e9c156f517","modified":1591272997000},{"_id":"themes/fluid/layout/links.ejs","hash":"0bb8360ad6a2433fdeddf01fbd39b4f2db67b08f","modified":1591272997000},{"_id":"themes/fluid/layout/index.ejs","hash":"31c62687deb7d224c9b7f4e6d0d5f43406dd3fce","modified":1591272997000},{"_id":"themes/fluid/layout/layout.ejs","hash":"941b922aae1e0f8c0dfd57cc14d50c0c85a8ec60","modified":1591272997000},{"_id":"themes/fluid/layout/tag.ejs","hash":"86d1c27b1536eb3f12c18f7264abb1d6fa6d96f6","modified":1591272997000},{"_id":"themes/fluid/layout/post.ejs","hash":"7ecfa13fe363799c7620d3386a79a889d6a7545d","modified":1591272997000},{"_id":"themes/fluid/layout/page.ejs","hash":"8cab50ead4cdb992d35710147a9a5308fb5df290","modified":1591272997000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1591272997000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"7fcdcd44f3a851722e8ffc511b3ed336c30d7561","modified":1591272997000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"272067b338530bee68c0c08b839da552cfe486b4","modified":1591272997000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"d3a3204d9bb2b43a69c9cb0be59bada8cb91e412","modified":1591272997000},{"_id":"themes/fluid/source/.DS_Store","hash":"4087f0f8c44d6a87e3fec684e3cc78e050f144fa","modified":1597061651786},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"a413dc14e4737dbcaa8fb797d37f85121ede6551","modified":1591272997000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1591272997000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1591272997000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"93cf5e1f1e0362adee0f63f4edcc7738cd4fc842","modified":1591272997000},{"_id":"themes/fluid/.github/workflows/lint.yaml","hash":"0c02cc7e5a1318c481a6f523747407b29da58645","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"cc6f4130c14ba7ebdb68bb5664f05dc16d7cecb1","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"4f3acc8dc822c85d0d778552a15875f71c0cd80a","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"5dbb5ae9a8d10b43beb0495788c83629c81e9922","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"03defcd4409dce27447aa8dfe7ce41a2d47e373b","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"502f9cdf526e850833d87415cda352a2e1002a51","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"783eee847562ce14db8f723b4ae742fb69aaf620","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"0d818a43079d9a2da12d9c974426d675cc0b66ea","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/post-meta.ejs","hash":"411fe0b8b169cd4e94d00450ae76a3b7ce994c44","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"3cf1d9b9032919d6b936e1f2410911df3b325670","modified":1591272997000},{"_id":"themes/fluid/scripts/events/index.js","hash":"36b137b75c76ff08523016dc8eac702f397d771b","modified":1591272997000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"6665f19fa30cbbe0853d8140a0832f8638538f89","modified":1591272997000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"bb90a128a999b276c10a822c44851fa27d6d64ae","modified":1591272997000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"f64d2121d99225e9f6d12ce646af618232f5f366","modified":1591272997000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"d45dce23532c17367c7eb86b94afa8c9e40d16c6","modified":1591272997000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":1591272997000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":1591272997000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":1591272997000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"48e1b46b4c34b79a128dda7a0592b43be47cf955","modified":1591272997000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"c131fb22805cec89d647e643299508487fc72576","modified":1591272997000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1591272997000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"d50f5aeb1a95adbc88cea9cca4a07165d6725408","modified":1591272997000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"0886cfe3f8589671a1d289495e359c20a9908080","modified":1591272997000},{"_id":"themes/fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1591272997000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":1591272997000},{"_id":"themes/fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1591272997000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1591272997000},{"_id":"themes/fluid/source/img/.DS_Store","hash":"704e21bfe6edae5bde4828e3b6d8d3a854090d64","modified":1597058873202},{"_id":"themes/fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1591272997000},{"_id":"themes/fluid/source/img/favicon.png","hash":"c2c40a9604c8e857b685bfcba36706138b67f9c8","modified":1597037890305},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1591272997000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1591272997000},{"_id":"themes/fluid/source/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1591272997000},{"_id":"themes/fluid/source/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1591272997000},{"_id":"themes/fluid/source/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1591272997000},{"_id":"themes/fluid/source/js/local-search.js","hash":"5e36b80ad9594246f78da743a742527382b7cd50","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"fe37916cb431c8842427797aa1e4edf55b30af0a","modified":1591272997000},{"_id":"themes/fluid/source/js/main.js","hash":"863a68ca6fac43dc2a42f6ffcad2ccbdd7d249cc","modified":1591272997000},{"_id":"themes/fluid/source/js/utils.js","hash":"24b1f871f74f9bed7ac59bb0ad28a60f1491e4c2","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"3f2b188bc108d8354ffd9d74511125d50ec02979","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"872f8915a791c6015017d026225de6bc76441a8a","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"4171a45f75525251ffd4e15756b34e5b9c4cb167","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"0a34a8c809209089466116c46d7a2daac5a4f326","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"3a13813e62f0b5f57ae4b9d6b7c9b32d7bca70d6","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/anchor.ejs","hash":"3738c2ef427b4b400225b92e638a17b7ab2125ed","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"db103077a6957c9d4786e98fd8144d6a5b03c495","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/daovoice.ejs","hash":"cfc684ba48608abd25afd155ee373d9936bbe84e","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/aplayer.ejs","hash":"e843cdbe64af3dee9385eb1d763539d3ac10ed72","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/local-search.ejs","hash":"03b024c7bab51b64e5187c9dbfac039d020f1e97","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/fancybox.ejs","hash":"c447e35c93c61a70c1c2dfc34948615832989660","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/leancloud.ejs","hash":"7807e58722dcf992fba11bc879b0fac0e904dc76","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"38334350425008d1f64323de221457ee0948af0e","modified":1591272997000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/tocjs.ejs","hash":"4d961ce5cc706445f12b9636801e80a521579f72","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/mouse-click.ejs","hash":"eb19991199c201ceb103a6ef025e4dfd1e7dbfb7","modified":1591272997000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"a382f567d95e53ef614246098fd844dd3b86ac44","modified":1591272997000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da4c281a8b2d2ed813da1236950c9dff87334adc","modified":1591272997000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"ee7dfef805af96195c11223cca53983deace8bda","modified":1591272997000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"374583fd419ac6477dfca69e09756db543d7ec80","modified":1591272997000},{"_id":"themes/fluid/scripts/events/lib/version.js","hash":"5fed24e25662a1b08fd857fde2d770fdc6250475","modified":1591272997000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1591272997000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1591272997000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"3cca1d1ed5fe23d9025ec5fe28d2a215b93efade","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"c34979b9b8e5c9cb54dcdd73a1fe877bcb943548","modified":1591272997000},{"_id":"themes/fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"2637dce25ee7c00b94e64d15834d178f3c78a912","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"4f27a4bdf703aec6f900727df2596bac902c441a","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"9ce4d5d708047520345a85bbfc101b3e67dbf7b8","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_base/rewrite.styl","hash":"7288884ed0f3bf5e4d8ae790269357ca073eab64","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"a13243e6281432e312ea73683cfd1a3dd50f6ebf","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"63152526c501e674085235982603ba60b659cb84","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"934a6ae74b29a6903d2309498653910c19a77c8b","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_post/tag_plugin.styl","hash":"37043762d345f33dc1817c18e4ac6c47551f6d42","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"7e07e44fa0e77ddbdd3aa0c0abdb3be6822df2e0","modified":1591272997000},{"_id":"themes/fluid/_config.yml","hash":"da332583febff203a9cdf4f4b34201b16132f4a5","modified":1597207749461},{"_id":"themes/fluid/source/img/computer_tools.jpg","hash":"1a4d0dfc2a1e78f14e2048ca7bdd80feccceb866","modified":1597041746796},{"_id":"source/images/graphics5/graphics5_jaggies.png","hash":"d246ef0d5edb456b279e6fc85fef12c9ea37b6b9","modified":1601709018434},{"_id":"source/images/latex/latex_head.png","hash":"2ebc6e6e8130d5a7f1b8f4f91318d17a800cb659","modified":1597113728875},{"_id":"themes/fluid/source/img/cyber3.jpg","hash":"94d3c568972fe23f9f539b690bd263de9245dc0f","modified":1597058198048},{"_id":"themes/fluid/source/img/cyber1.jpg","hash":"d4ca7f895b0ef976679b4866227b94884c04ecb5","modified":1597058723923},{"_id":"themes/fluid/source/img/spaceBanner.jpg","hash":"e6a9ecd066b8968bb32900fe0aef78defd728e5f","modified":1597038573251},{"_id":"themes/fluid/source/img/cyber2.jpg","hash":"35788ca04003ec6699da9dda38b6364504fd5e62","modified":1597058804347},{"_id":"themes/fluid/source/img/code_image.png","hash":"201f6e216dd369afe5c210f5052d44a4010f70cd","modified":1597058528574},{"_id":"public/local-search.xml","hash":"c7787ff5e7afb042dc58ada38130cf114d7e9423","modified":1601716642327},{"_id":"public/about/index.html","hash":"ea508c3dbd72552b8e99b93a26e07f84afd5b2d4","modified":1601716642327},{"_id":"public/2020/10/03/ComputerGraphics7/index.html","hash":"3306d15b5cdf88028279b77b5998d592baaac406","modified":1601716642327},{"_id":"public/2020/10/01/ComputerGraphics6/index.html","hash":"14383b81bb741b2840f4b3d05d88257be971a3f2","modified":1601716642327},{"_id":"public/2020/08/11/latexlearning2/index.html","hash":"e626841caccb5fd1892bff15f37c5e5d3df8d2ac","modified":1601716642327},{"_id":"public/archives/index.html","hash":"45c9bea3d3460abb41f771ea822f3ce7539b2de4","modified":1601716642327},{"_id":"public/archives/2020/index.html","hash":"45c9bea3d3460abb41f771ea822f3ce7539b2de4","modified":1601716642327},{"_id":"public/archives/2020/08/index.html","hash":"beda9ec007cf24778581082bb542e8aafb75d962","modified":1601716642327},{"_id":"public/archives/2020/09/index.html","hash":"334b9d01a2fbbc8a0eb1ce8440593f5c8cfc0654","modified":1601716642327},{"_id":"public/archives/2020/10/index.html","hash":"a3646a90727750aa67e1f9b8cda9a5a418f269a8","modified":1601716642327},{"_id":"public/categories/GAMES101/index.html","hash":"aa842a1ec736c1c628961b8765001ab324d8630c","modified":1601716642327},{"_id":"public/categories/latex/index.html","hash":"6500637da601f5b04cf01ef28953b302f4463ca9","modified":1601716642327},{"_id":"public/tags/计算机图形学/index.html","hash":"215d7f0de03e232bbb9a7e2811da6e401785fe87","modified":1601716642327},{"_id":"public/tags/线性代数/index.html","hash":"db0bec888c492e100c374b873f6228600212014a","modified":1601716642327},{"_id":"public/tags/投影，视图变换/index.html","hash":"c4a74111a96c0bc7cb0c426f54f6411a6f7cf28f","modified":1601716642327},{"_id":"public/tags/光栅化/index.html","hash":"a6ce10e0d8426a408affede3cb35c7715f8ada81","modified":1601716642327},{"_id":"public/tags/bresenham/index.html","hash":"308400a6acabc00220f8f05f6b8241bf67061a18","modified":1601716642327},{"_id":"public/tags/反走样/index.html","hash":"48f23a52cb0ddef4c8cf74100d90f3d986318f6b","modified":1601716642327},{"_id":"public/tags/光照/index.html","hash":"ebef6392095acf6b6460194ad045f7919e4b94e7","modified":1601716642327},{"_id":"public/tags/着色/index.html","hash":"ddcc413677f808e8a4ff8edc7d94e328df0f4814","modified":1601716642327},{"_id":"public/tags/渲染模型/index.html","hash":"99491783131897a17143e52ae1acede3e39573f1","modified":1601716642327},{"_id":"public/tags/渲染管线/index.html","hash":"2f34e3baee992867624d9cb76db43933c1bb68a8","modified":1601716642327},{"_id":"public/tags/纹理/index.html","hash":"6b83bbe419ceaba3949192f3b0f26d2b5b472de2","modified":1601716642327},{"_id":"public/tags/latex/index.html","hash":"ef7a166a0e1ca800ba8eff37f9168c07f2d981e5","modified":1601716642327},{"_id":"public/tags/排版/index.html","hash":"d8a34e62d999b0626ebb889c405d34e22abf81df","modified":1601716642327},{"_id":"public/tags/论文写作/index.html","hash":"b5f1185fe8d617a7f6e61f7e6c39ddc76325c6b2","modified":1601716642327},{"_id":"public/404.html","hash":"5f6e28fecff0abb035e4dad1bd0975f0fe2a7ccd","modified":1601716642327},{"_id":"public/tags/index.html","hash":"5a0aefaea62478b1ab209819a51594da7cadd980","modified":1601716642327},{"_id":"public/categories/index.html","hash":"4899464572e41e81ce1d21d1e7d5ab43f331953d","modified":1601716642327},{"_id":"public/links/index.html","hash":"e9c752f82e06041d79d6fa5612f82c65c4d6ab26","modified":1601716642327},{"_id":"public/2020/09/13/ComputerGraphics5/index.html","hash":"34c8e8b19e4d45ed5296ff328eb682e76733f963","modified":1601716642327},{"_id":"public/2020/09/01/ComputerGraphics4/index.html","hash":"ca2fae39dc55f468e2ae02bfcf790c3c358fc1e9","modified":1601716642327},{"_id":"public/2020/08/24/ComputerGraphics3/index.html","hash":"00b422b0d00c1bdb13b077f9311855063e6a1203","modified":1601716642327},{"_id":"public/2020/08/17/ComputerGraphics2/index.html","hash":"7b440338b61ea8e2b10a134a0d7af3df24b9bb9c","modified":1601716642327},{"_id":"public/2020/08/10/latexlearning1/index.html","hash":"9a15b66020a6a807a7f7b53e284084e724d3471a","modified":1601716642327},{"_id":"public/2020/08/10/ComputerGraphics1/index.html","hash":"ec6106efa1474b1ffb8755be9796a8263f3c8e46","modified":1601716642327},{"_id":"public/index.html","hash":"aaefee81ab3a5c4627b40819e7bbca3ad90ebe3e","modified":1601716642327},{"_id":"public/images/graphics1/graphics1_reflection.png","hash":"f1403c8080f54b84a0a353b5d9284db0de91d41d","modified":1601716642327},{"_id":"public/images/graphics1/graphics1_banner.jpeg","hash":"67e0c1dcfc0277f456474198cb37161d74997e6f","modified":1601716642327},{"_id":"public/images/graphics1/graphics1_scale.png","hash":"7e2d1af3f5545c706664a180ca1608e66ad86744","modified":1601716642327},{"_id":"public/images/graphics1/graphics1_shear.png","hash":"4b6f7e2b826a54f583170d8c0d8a88824c612bf1","modified":1601716642327},{"_id":"public/images/graphics3/graphic3_orthographic.png","hash":"bb2ec145ea331024692e9d97a498419a95cb70ec","modified":1601716642327},{"_id":"public/images/graphics3/graphic3_orthographic_point.png","hash":"e636284be174f911d1466c641c87f3e932b81d96","modified":1601716642327},{"_id":"public/images/graphics3/graphics3_camera.png","hash":"da6b99e4cb56a867f48f164c8b711438507294e0","modified":1601716642327},{"_id":"public/images/graphics3/graphics3_orthographic_transform.png","hash":"58b34804bddc2cc2a34123faac5bcefb33fc203d","modified":1601716642327},{"_id":"public/images/graphics3/graphics3_transformation.png","hash":"fa2bd2ddffe3a1f2c64e3291a8bbd26dd1946697","modified":1601716642327},{"_id":"public/images/graphics4/graphics4_banner.png","hash":"95a3b203897307e7aec529c881f1f9c8874493b1","modified":1601716642327},{"_id":"public/images/graphics4/graphics4_bound_box.png","hash":"42c7ad20384c763210c2f3c9755e620d47d74baf","modified":1601716642327},{"_id":"public/images/graphics4/graphics4_bresenham.png","hash":"98314d14ea732c093eef8a6350fe7cd5f4365b25","modified":1601716642327},{"_id":"public/images/graphics4/graphics4_inside.png","hash":"e2e3eea5291b88a0231e54fdbb811a2a945aa372","modified":1601716642327},{"_id":"public/images/graphics4/graphics4_lines.png","hash":"ee409c72df646791e566f290562b442f32e029c0","modified":1601716642327},{"_id":"public/images/graphics4/graphics4_pixels.png","hash":"418dc105a6cbf84e4b13294f6e5f8e505bc6bef9","modified":1601716642327},{"_id":"public/images/graphics4/graphics4_sample.png","hash":"1785a9591ce6fbb287e4512d4e33777d947fc977","modified":1601716642327},{"_id":"public/images/latex/latex1_graph1.png","hash":"ab13b12abe952ac3bdb4d8d537b1ce6de5e35872","modified":1601716642327},{"_id":"public/images/latex/latex1_graph2.png","hash":"adeafb354599b21eab18179a37efe22d321db754","modified":1601716642327},{"_id":"public/images/latex/latex1_graph3.png","hash":"9aac9d36160a2226f46a821ad6ade7c35385d443","modified":1601716642327},{"_id":"public/images/latex/latex1_graph4.png","hash":"5a28ff28638f940672333fdb20021acb63aad9b5","modified":1601716642327},{"_id":"public/images/latex/latex1_graph5.png","hash":"92c02f0ba26533621f3afe8a788d26d76c352f0d","modified":1601716642327},{"_id":"public/images/graphics2/graphics2_banner.jpeg","hash":"37da4d3b58631297d7d5cd82157dad1d191856eb","modified":1601716642327},{"_id":"public/images/graphics2/graphics2_compose.png","hash":"2d9c1f16bb2c5ad144fe98edba69383c21f53683","modified":1601716642327},{"_id":"public/images/graphics2/graphics2_decompose.png","hash":"2a4b0122cec80d8db30ff5be56368c29006f8bc1","modified":1601716642327},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1601716642327},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1601716642327},{"_id":"public/img/favicon.png","hash":"c2c40a9604c8e857b685bfcba36706138b67f9c8","modified":1601716642327},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1601716642327},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1601716642327},{"_id":"public/images/graphics1/graphics1_rotate.png","hash":"87f933a2979fa357383b912e5099c023c00556d7","modified":1601716642327},{"_id":"public/images/graphics3/graphics3_banner.png","hash":"822b9a3a4527ecd7394662daf9e3e1670e18b83c","modified":1601716642327},{"_id":"public/images/graphics5/graphics5_Moiré.jpg","hash":"caed5bedb970e632662792c256fc47db4c00018b","modified":1601716642327},{"_id":"public/images/graphics5/graphics5_SSAA.png","hash":"4ae7f970a6e47493726c1411973e09a59fff144f","modified":1601716642327},{"_id":"public/images/graphics5/graphics5_banner.jpg","hash":"f721a393d1ec3b3c30a1f07307a3edde80748a9c","modified":1601716642327},{"_id":"public/images/graphics5/graphics5_sample.png","hash":"f257764d7f935cb240fb9f989cbf50f4a33a5ae9","modified":1601716642327},{"_id":"public/img/computer_tools.jpg","hash":"1a4d0dfc2a1e78f14e2048ca7bdd80feccceb866","modified":1601716642327},{"_id":"public/images/graphics5/graphics5_aliasing.png","hash":"7b236d2a7c66167926db7acda42b8f43a40e98fa","modified":1601716642327},{"_id":"public/images/graphics5/graphics5_frequency.png","hash":"1bc1e776b996b49005d688c8a5e20bdc3722a213","modified":1601716642327},{"_id":"public/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1601716642327},{"_id":"public/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1601716642327},{"_id":"public/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1601716642327},{"_id":"public/js/local-search.js","hash":"5e36b80ad9594246f78da743a742527382b7cd50","modified":1601716642327},{"_id":"public/js/main.js","hash":"863a68ca6fac43dc2a42f6ffcad2ccbdd7d249cc","modified":1601716642327},{"_id":"public/js/utils.js","hash":"24b1f871f74f9bed7ac59bb0ad28a60f1491e4c2","modified":1601716642327},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1601716642327},{"_id":"public/css/main.css","hash":"038f25decff0b72baa21874a140e527c62c5d6c1","modified":1601716642327},{"_id":"public/images/graphics5/graphics5_reconstructed.png","hash":"ecdd4b9e8a2ead12ef00696f9c6efa62609872be","modified":1601716642327},{"_id":"public/img/cyber1.jpg","hash":"d4ca7f895b0ef976679b4866227b94884c04ecb5","modified":1601716642327},{"_id":"public/images/latex/latex_head.png","hash":"2ebc6e6e8130d5a7f1b8f4f91318d17a800cb659","modified":1601716642327},{"_id":"public/img/cyber3.jpg","hash":"94d3c568972fe23f9f539b690bd263de9245dc0f","modified":1601716642327},{"_id":"public/images/graphics5/graphics5_jaggies.png","hash":"d246ef0d5edb456b279e6fc85fef12c9ea37b6b9","modified":1601716642327},{"_id":"public/img/code_image.png","hash":"201f6e216dd369afe5c210f5052d44a4010f70cd","modified":1601716642327},{"_id":"public/img/spaceBanner.jpg","hash":"e6a9ecd066b8968bb32900fe0aef78defd728e5f","modified":1601716642327},{"_id":"public/img/cyber2.jpg","hash":"35788ca04003ec6699da9dda38b6364504fd5e62","modified":1601716642327},{"_id":"source/images/graphics6/.DS_Store","hash":"96eb8dc0ac40aa553b4ed919cd35c61b78ea3b9a","modified":1601737887009},{"_id":"source/images/graphics6/graphics6_banner.jpg","hash":"eb6e62e9b30bd8733a14226a8a318ddd3047e746","modified":1601716780485},{"_id":"source/images/graphics6/graphics6_shading.png","hash":"49e328545eb0d1838657c572bad0d352da6d951b","modified":1601737834149},{"_id":"source/images/graphics6/graphics6_painter.png","hash":"be49881d065b0caf5dba335185373013850f2eeb","modified":1601732021489}],"Category":[{"name":"GAMES101","_id":"ckftgqfan00032wqcbep27pap"},{"name":"latex","_id":"ckftgqfax000l2wqcgdd72lcl"}],"Data":[],"Page":[{"title":"about","date":"2020-02-23T11:20:33.000Z","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-02-23 19:20:33\nlayout: about\n---","updated":"2020-08-10T05:27:41.740Z","path":"about/index.html","comments":1,"_id":"ckftgqfak00012wqc6t3c2rb5","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"计算机图形学1 —— 线性变换","index_img":"/images/graphics1/graphics1_banner.jpeg","date":"2020-08-10T03:09:11.000Z","math":true,"_content":"\n## 摘要\n在图形学中，图形位置形态的数学定义是坐标中的一个个坐标点的集合，因此图形的变换操作通过数学计算来进行。为了简化计算思路，通常我们会将这些变化通过线性代数的方式抽象为变换矩阵 (Transformation Marices)。一切物体的缩放，旋转，位移，都可以通过变换矩阵作用得到。当我们确定好了某种变化的变换矩阵后，可以将其应用在任何其他图形上。本文将介绍基本图形变化中如何利用变换矩阵来进行图形变换。\n\n## 2D线性变换\n在2D图形中，我们规定 $[x, y]^T$ 为图形上的任意一个点（也可以看作是一个二维向量），2D基于原点的线性变化可以被定义为向量 $[x, y]^T$ 左乘变换矩阵的数学表示：\n\n$$\n\\begin{bmatrix}\n a_{11} & a_{12}\\\\\n a_{21} & a_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\n x \\\\\n y\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n a_{11}x & a_{12}y\\\\\n a_{21}x & a_{22}y\n\\end{bmatrix}\n$$\n\n### 缩放（scale）\n缩放操作是将图形中所有点的坐标整体放大或者缩小某个数值，如下图所示的变换分别将$x, y$分别缩小了0.5:\n\n![](/images/graphics1/graphics1_scale.png)\n$[x, y]^T$经过变换后表示为$[x\\prime, y\\prime]^T$，经过变化后的值可以表示为：\n$$\nx\\prime = 0.5 \\times x + 0 \\times y\n$$\n\n$$\ny\\prime = 0 \\times x + 0.5 \\times y\n$$\n\n上述操作可以使用变换矩阵表示为：\n$$\nscale(s_x, s_y)\n= \n\\begin{bmatrix}\n s_x & 0\\\\\n 0 & s_y\n\\end{bmatrix} \n$$\n\n### 剪切（Shear）\n剪切变换可以简单理解为将图形的一段固定，将其对端沿着固定方向拉动。以固定x轴为例：\n![](/images/graphics1/graphics1_shear.png)\n所有点的\b$y$值保持不变，x坐标加上了对应的y值，经过变化后的值表示为：\n$$\nx\\prime =  x + 1 \\times y\n$$\n\n$$\ny\\prime = 0 \\times x + y\n$$\n\n上述操作可以使用变换矩阵表示为：\n$$\nshearX(s)\n= \n\\begin{bmatrix}\n 1 & s\\\\\n 0 & 1\n\\end{bmatrix} \n$$\n\n$$\nshearY(s)\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n s & 1\n\\end{bmatrix} \n$$\n\n### 翻转（reflection）\n翻转一般是通过将某个坐标轴的所有值取反得到的，其变换矩阵可以表示为：\n上述操作可以使用变换矩阵表示为：\n$$\nreflectionY\n= \n\\begin{bmatrix}\n -1 & 0\\\\\n 0 & 1\n\\end{bmatrix} \n$$\n\n$$\nreflectionX\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n 0 & -1\n\\end{bmatrix} \n$$\n以X轴翻转为例，经过变化矩阵计算后，图形变换如下：\n![](/images/graphics1/graphics1_reflection.png)\n\n### 旋转（rotate）\n旋转的几何意义很容易理解，图形绕着原点逆时针旋转，但是数学上的变换关系并没有上述几种变换直观。为了便于理解，我们先假定图形中的一个任意向量 $\\vec{a}$ ，它与x轴的夹角为$\\alpha$，坐标为 $[x_a, y_a]$ 。向量的长度表示为  $r^2 = x_a^2 + y_a^2$ ，因此其坐标可以表示为：\n$$\nx_a = rcos\\alpha\n$$\n$$\ny_a = rsin\\alpha\n$$\n当 $\\vec{a}$ 旋转了任意角度 $\\varphi$ 之后得到 $\\vec{b}$，此时 $\\vec{b}$ 与x轴的夹角为 $(\\alpha + \\varphi)$，坐标为$[x_b, y_b]$ 被表示为：\n$$\nx_b = rcos(\\alpha + \\varphi) = rcos\\alpha cos\\varphi - rsin\\alpha sin\\varphi\n$$\n$$\ny_b = rsin(\\alpha + \\varphi) = rsin\\alpha cos\\varphi + r sin\\alpha sin\\varphi\n$$\n\n根据$x_a = rcos\\alpha$以及$y_a = rsin\\alpha$我们可以化简得到：\n$$\nx_b = x_a cos\\varphi - y_a sin\\varphi\n$$\n$$\ny_b = y_a cos\\varphi + x_a sin\\varphi\n$$\n\n变换矩阵可以表示为：\n$$\nrotate(\\varphi) = \n\\begin{bmatrix}\n cos\\varphi & -sin\\varphi\\\\\n sin\\varphi & cos\\varphi\n\\end{bmatrix} \n$$\n\n举一个简单的旋转的例子，让图形逆时针旋转$\\pi/4$，变换矩阵的值为：\n$$\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi\\\\\nsin\\varphi & cos\\varphi\n\\end{bmatrix}\n= \n\\begin{bmatrix}\n0.707 & -0.707\\\\\n0.707 & 0.707\n\\end{bmatrix}\n$$\n图形坐标经过计算后的样式如下：\n![](/images/graphics1/graphics1_rotate.png)\n\n\n## 3D线性变换\n了解了2D线性变换之后，3D线性变换的推倒思路是一致的，仅仅是多增加了一个纬度的判断罢了。\n\n### 缩放、剪切、翻转\n3D缩放比较简单，直接通过2D缩放进行扩展：\n$$\nscale(s_x, s_y, s_z) = \n\\begin{bmatrix}\ns_x & 0 & 0\\\\\n0 & s_y & 0\\\\\n0 & 0 & s_z\n\\end{bmatrix}\n$$\n3D剪切也可以通过2D剪切做类似的扩展：\n$$\nshearX(d_y, d_z) = \n\\begin{bmatrix}\n1 & d_y & d_z\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n\n3D的旋转稍稍复杂一点点，因为在3D场景下旋转可以是以原点为中心绕着任意轴进行旋转。在2D中是由x轴向y轴旋转，换算到3D空间中就是绕着z轴进行旋转(绕z轴，z的值不会发生变化，因此变换矩阵第三行没有变化)：\n$$\nrotateZ(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix} \n$$\n\n绕着x轴的旋转可以理解为在2D场景下的yz平面，由y轴转向z轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：\n$$\nrotateX(\\varphi) = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & cos\\varphi & -sin\\varphi\\\\\n0 & sin\\varphi & cos\\varphi\n\\end{bmatrix} \n$$\n\n\n绕着y轴的旋转可以理解为在2D场景下的xz平面，由z轴转向x轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：\n$$\nrotateY(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & 0 & sin\\varphi\\\\\n0 & 1 & 0\\\\\n-sin\\varphi & 0  & cos\\varphi\n\\end{bmatrix} \n$$\n","source":"_posts/ComputerGraphics1.md","raw":"---\ntitle: 计算机图形学1 —— 线性变换\ntags: [计算机图形学, 线性代数]\ncategories: [GAMES101]\nindex_img: /images/graphics1/graphics1_banner.jpeg\ndate: 2020-08-10 11:09:11\nmath: true\n---\n\n## 摘要\n在图形学中，图形位置形态的数学定义是坐标中的一个个坐标点的集合，因此图形的变换操作通过数学计算来进行。为了简化计算思路，通常我们会将这些变化通过线性代数的方式抽象为变换矩阵 (Transformation Marices)。一切物体的缩放，旋转，位移，都可以通过变换矩阵作用得到。当我们确定好了某种变化的变换矩阵后，可以将其应用在任何其他图形上。本文将介绍基本图形变化中如何利用变换矩阵来进行图形变换。\n\n## 2D线性变换\n在2D图形中，我们规定 $[x, y]^T$ 为图形上的任意一个点（也可以看作是一个二维向量），2D基于原点的线性变化可以被定义为向量 $[x, y]^T$ 左乘变换矩阵的数学表示：\n\n$$\n\\begin{bmatrix}\n a_{11} & a_{12}\\\\\n a_{21} & a_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\n x \\\\\n y\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n a_{11}x & a_{12}y\\\\\n a_{21}x & a_{22}y\n\\end{bmatrix}\n$$\n\n### 缩放（scale）\n缩放操作是将图形中所有点的坐标整体放大或者缩小某个数值，如下图所示的变换分别将$x, y$分别缩小了0.5:\n\n![](/images/graphics1/graphics1_scale.png)\n$[x, y]^T$经过变换后表示为$[x\\prime, y\\prime]^T$，经过变化后的值可以表示为：\n$$\nx\\prime = 0.5 \\times x + 0 \\times y\n$$\n\n$$\ny\\prime = 0 \\times x + 0.5 \\times y\n$$\n\n上述操作可以使用变换矩阵表示为：\n$$\nscale(s_x, s_y)\n= \n\\begin{bmatrix}\n s_x & 0\\\\\n 0 & s_y\n\\end{bmatrix} \n$$\n\n### 剪切（Shear）\n剪切变换可以简单理解为将图形的一段固定，将其对端沿着固定方向拉动。以固定x轴为例：\n![](/images/graphics1/graphics1_shear.png)\n所有点的\b$y$值保持不变，x坐标加上了对应的y值，经过变化后的值表示为：\n$$\nx\\prime =  x + 1 \\times y\n$$\n\n$$\ny\\prime = 0 \\times x + y\n$$\n\n上述操作可以使用变换矩阵表示为：\n$$\nshearX(s)\n= \n\\begin{bmatrix}\n 1 & s\\\\\n 0 & 1\n\\end{bmatrix} \n$$\n\n$$\nshearY(s)\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n s & 1\n\\end{bmatrix} \n$$\n\n### 翻转（reflection）\n翻转一般是通过将某个坐标轴的所有值取反得到的，其变换矩阵可以表示为：\n上述操作可以使用变换矩阵表示为：\n$$\nreflectionY\n= \n\\begin{bmatrix}\n -1 & 0\\\\\n 0 & 1\n\\end{bmatrix} \n$$\n\n$$\nreflectionX\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n 0 & -1\n\\end{bmatrix} \n$$\n以X轴翻转为例，经过变化矩阵计算后，图形变换如下：\n![](/images/graphics1/graphics1_reflection.png)\n\n### 旋转（rotate）\n旋转的几何意义很容易理解，图形绕着原点逆时针旋转，但是数学上的变换关系并没有上述几种变换直观。为了便于理解，我们先假定图形中的一个任意向量 $\\vec{a}$ ，它与x轴的夹角为$\\alpha$，坐标为 $[x_a, y_a]$ 。向量的长度表示为  $r^2 = x_a^2 + y_a^2$ ，因此其坐标可以表示为：\n$$\nx_a = rcos\\alpha\n$$\n$$\ny_a = rsin\\alpha\n$$\n当 $\\vec{a}$ 旋转了任意角度 $\\varphi$ 之后得到 $\\vec{b}$，此时 $\\vec{b}$ 与x轴的夹角为 $(\\alpha + \\varphi)$，坐标为$[x_b, y_b]$ 被表示为：\n$$\nx_b = rcos(\\alpha + \\varphi) = rcos\\alpha cos\\varphi - rsin\\alpha sin\\varphi\n$$\n$$\ny_b = rsin(\\alpha + \\varphi) = rsin\\alpha cos\\varphi + r sin\\alpha sin\\varphi\n$$\n\n根据$x_a = rcos\\alpha$以及$y_a = rsin\\alpha$我们可以化简得到：\n$$\nx_b = x_a cos\\varphi - y_a sin\\varphi\n$$\n$$\ny_b = y_a cos\\varphi + x_a sin\\varphi\n$$\n\n变换矩阵可以表示为：\n$$\nrotate(\\varphi) = \n\\begin{bmatrix}\n cos\\varphi & -sin\\varphi\\\\\n sin\\varphi & cos\\varphi\n\\end{bmatrix} \n$$\n\n举一个简单的旋转的例子，让图形逆时针旋转$\\pi/4$，变换矩阵的值为：\n$$\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi\\\\\nsin\\varphi & cos\\varphi\n\\end{bmatrix}\n= \n\\begin{bmatrix}\n0.707 & -0.707\\\\\n0.707 & 0.707\n\\end{bmatrix}\n$$\n图形坐标经过计算后的样式如下：\n![](/images/graphics1/graphics1_rotate.png)\n\n\n## 3D线性变换\n了解了2D线性变换之后，3D线性变换的推倒思路是一致的，仅仅是多增加了一个纬度的判断罢了。\n\n### 缩放、剪切、翻转\n3D缩放比较简单，直接通过2D缩放进行扩展：\n$$\nscale(s_x, s_y, s_z) = \n\\begin{bmatrix}\ns_x & 0 & 0\\\\\n0 & s_y & 0\\\\\n0 & 0 & s_z\n\\end{bmatrix}\n$$\n3D剪切也可以通过2D剪切做类似的扩展：\n$$\nshearX(d_y, d_z) = \n\\begin{bmatrix}\n1 & d_y & d_z\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n\n3D的旋转稍稍复杂一点点，因为在3D场景下旋转可以是以原点为中心绕着任意轴进行旋转。在2D中是由x轴向y轴旋转，换算到3D空间中就是绕着z轴进行旋转(绕z轴，z的值不会发生变化，因此变换矩阵第三行没有变化)：\n$$\nrotateZ(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix} \n$$\n\n绕着x轴的旋转可以理解为在2D场景下的yz平面，由y轴转向z轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：\n$$\nrotateX(\\varphi) = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & cos\\varphi & -sin\\varphi\\\\\n0 & sin\\varphi & cos\\varphi\n\\end{bmatrix} \n$$\n\n\n绕着y轴的旋转可以理解为在2D场景下的xz平面，由z轴转向x轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：\n$$\nrotateY(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & 0 & sin\\varphi\\\\\n0 & 1 & 0\\\\\n-sin\\varphi & 0  & cos\\varphi\n\\end{bmatrix} \n$$\n","slug":"ComputerGraphics1","published":1,"updated":"2020-10-03T07:40:23.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckftgqfac00002wqcfw1e2dzf","content":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>在图形学中，图形位置形态的数学定义是坐标中的一个个坐标点的集合，因此图形的变换操作通过数学计算来进行。为了简化计算思路，通常我们会将这些变化通过线性代数的方式抽象为变换矩阵 (Transformation Marices)。一切物体的缩放，旋转，位移，都可以通过变换矩阵作用得到。当我们确定好了某种变化的变换矩阵后，可以将其应用在任何其他图形上。本文将介绍基本图形变化中如何利用变换矩阵来进行图形变换。</p>\n<h2 id=\"2D线性变换\"><a href=\"#2D线性变换\" class=\"headerlink\" title=\"2D线性变换\"></a>2D线性变换</h2><p>在2D图形中，我们规定 $[x, y]^T$ 为图形上的任意一个点（也可以看作是一个二维向量），2D基于原点的线性变化可以被定义为向量 $[x, y]^T$ 左乘变换矩阵的数学表示：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n a_{11} & a_{12}\\\\\n a_{21} & a_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\n x \\\\\n y\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n a_{11}x & a_{12}y\\\\\n a_{21}x & a_{22}y\n\\end{bmatrix}</script><h3 id=\"缩放（scale）\"><a href=\"#缩放（scale）\" class=\"headerlink\" title=\"缩放（scale）\"></a>缩放（scale）</h3><p>缩放操作是将图形中所有点的坐标整体放大或者缩小某个数值，如下图所示的变换分别将$x, y$分别缩小了0.5:</p>\n<p><img src=\"/images/graphics1/graphics1_scale.png\" alt=\"\"><br>$[x, y]^T$经过变换后表示为$[x\\prime, y\\prime]^T$，经过变化后的值可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nx\\prime = 0.5 \\times x + 0 \\times y</script><script type=\"math/tex; mode=display\">\ny\\prime = 0 \\times x + 0.5 \\times y</script><p>上述操作可以使用变换矩阵表示为：</p>\n<script type=\"math/tex; mode=display\">\nscale(s_x, s_y)\n= \n\\begin{bmatrix}\n s_x & 0\\\\\n 0 & s_y\n\\end{bmatrix}</script><h3 id=\"剪切（Shear）\"><a href=\"#剪切（Shear）\" class=\"headerlink\" title=\"剪切（Shear）\"></a>剪切（Shear）</h3><p>剪切变换可以简单理解为将图形的一段固定，将其对端沿着固定方向拉动。以固定x轴为例：<br><img src=\"/images/graphics1/graphics1_shear.png\" alt=\"\"><br>所有点的\b$y$值保持不变，x坐标加上了对应的y值，经过变化后的值表示为：</p>\n<script type=\"math/tex; mode=display\">\nx\\prime =  x + 1 \\times y</script><script type=\"math/tex; mode=display\">\ny\\prime = 0 \\times x + y</script><p>上述操作可以使用变换矩阵表示为：</p>\n<script type=\"math/tex; mode=display\">\nshearX(s)\n= \n\\begin{bmatrix}\n 1 & s\\\\\n 0 & 1\n\\end{bmatrix}</script><script type=\"math/tex; mode=display\">\nshearY(s)\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n s & 1\n\\end{bmatrix}</script><h3 id=\"翻转（reflection）\"><a href=\"#翻转（reflection）\" class=\"headerlink\" title=\"翻转（reflection）\"></a>翻转（reflection）</h3><p>翻转一般是通过将某个坐标轴的所有值取反得到的，其变换矩阵可以表示为：<br>上述操作可以使用变换矩阵表示为：</p>\n<script type=\"math/tex; mode=display\">\nreflectionY\n= \n\\begin{bmatrix}\n -1 & 0\\\\\n 0 & 1\n\\end{bmatrix}</script><script type=\"math/tex; mode=display\">\nreflectionX\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n 0 & -1\n\\end{bmatrix}</script><p>以X轴翻转为例，经过变化矩阵计算后，图形变换如下：<br><img src=\"/images/graphics1/graphics1_reflection.png\" alt=\"\"></p>\n<h3 id=\"旋转（rotate）\"><a href=\"#旋转（rotate）\" class=\"headerlink\" title=\"旋转（rotate）\"></a>旋转（rotate）</h3><p>旋转的几何意义很容易理解，图形绕着原点逆时针旋转，但是数学上的变换关系并没有上述几种变换直观。为了便于理解，我们先假定图形中的一个任意向量 $\\vec{a}$ ，它与x轴的夹角为$\\alpha$，坐标为 $[x_a, y_a]$ 。向量的长度表示为  $r^2 = x_a^2 + y_a^2$ ，因此其坐标可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nx_a = rcos\\alpha</script><script type=\"math/tex; mode=display\">\ny_a = rsin\\alpha</script><p>当 $\\vec{a}$ 旋转了任意角度 $\\varphi$ 之后得到 $\\vec{b}$，此时 $\\vec{b}$ 与x轴的夹角为 $(\\alpha + \\varphi)$，坐标为$[x_b, y_b]$ 被表示为：</p>\n<script type=\"math/tex; mode=display\">\nx_b = rcos(\\alpha + \\varphi) = rcos\\alpha cos\\varphi - rsin\\alpha sin\\varphi</script><script type=\"math/tex; mode=display\">\ny_b = rsin(\\alpha + \\varphi) = rsin\\alpha cos\\varphi + r sin\\alpha sin\\varphi</script><p>根据$x_a = rcos\\alpha$以及$y_a = rsin\\alpha$我们可以化简得到：</p>\n<script type=\"math/tex; mode=display\">\nx_b = x_a cos\\varphi - y_a sin\\varphi</script><script type=\"math/tex; mode=display\">\ny_b = y_a cos\\varphi + x_a sin\\varphi</script><p>变换矩阵可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nrotate(\\varphi) = \n\\begin{bmatrix}\n cos\\varphi & -sin\\varphi\\\\\n sin\\varphi & cos\\varphi\n\\end{bmatrix}</script><p>举一个简单的旋转的例子，让图形逆时针旋转$\\pi/4$，变换矩阵的值为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi\\\\\nsin\\varphi & cos\\varphi\n\\end{bmatrix}\n= \n\\begin{bmatrix}\n0.707 & -0.707\\\\\n0.707 & 0.707\n\\end{bmatrix}</script><p>图形坐标经过计算后的样式如下：<br><img src=\"/images/graphics1/graphics1_rotate.png\" alt=\"\"></p>\n<h2 id=\"3D线性变换\"><a href=\"#3D线性变换\" class=\"headerlink\" title=\"3D线性变换\"></a>3D线性变换</h2><p>了解了2D线性变换之后，3D线性变换的推倒思路是一致的，仅仅是多增加了一个纬度的判断罢了。</p>\n<h3 id=\"缩放、剪切、翻转\"><a href=\"#缩放、剪切、翻转\" class=\"headerlink\" title=\"缩放、剪切、翻转\"></a>缩放、剪切、翻转</h3><p>3D缩放比较简单，直接通过2D缩放进行扩展：</p>\n<script type=\"math/tex; mode=display\">\nscale(s_x, s_y, s_z) = \n\\begin{bmatrix}\ns_x & 0 & 0\\\\\n0 & s_y & 0\\\\\n0 & 0 & s_z\n\\end{bmatrix}</script><p>3D剪切也可以通过2D剪切做类似的扩展：</p>\n<script type=\"math/tex; mode=display\">\nshearX(d_y, d_z) = \n\\begin{bmatrix}\n1 & d_y & d_z\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>3D的旋转稍稍复杂一点点，因为在3D场景下旋转可以是以原点为中心绕着任意轴进行旋转。在2D中是由x轴向y轴旋转，换算到3D空间中就是绕着z轴进行旋转(绕z轴，z的值不会发生变化，因此变换矩阵第三行没有变化)：</p>\n<script type=\"math/tex; mode=display\">\nrotateZ(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>绕着x轴的旋转可以理解为在2D场景下的yz平面，由y轴转向z轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：</p>\n<script type=\"math/tex; mode=display\">\nrotateX(\\varphi) = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & cos\\varphi & -sin\\varphi\\\\\n0 & sin\\varphi & cos\\varphi\n\\end{bmatrix}</script><p>绕着y轴的旋转可以理解为在2D场景下的xz平面，由z轴转向x轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：</p>\n<script type=\"math/tex; mode=display\">\nrotateY(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & 0 & sin\\varphi\\\\\n0 & 1 & 0\\\\\n-sin\\varphi & 0  & cos\\varphi\n\\end{bmatrix}</script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>在图形学中，图形位置形态的数学定义是坐标中的一个个坐标点的集合，因此图形的变换操作通过数学计算来进行。为了简化计算思路，通常我们会将这些变化通过线性代数的方式抽象为变换矩阵 (Transformation Marices)。一切物体的缩放，旋转，位移，都可以通过变换矩阵作用得到。当我们确定好了某种变化的变换矩阵后，可以将其应用在任何其他图形上。本文将介绍基本图形变化中如何利用变换矩阵来进行图形变换。</p>\n<h2 id=\"2D线性变换\"><a href=\"#2D线性变换\" class=\"headerlink\" title=\"2D线性变换\"></a>2D线性变换</h2><p>在2D图形中，我们规定 $[x, y]^T$ 为图形上的任意一个点（也可以看作是一个二维向量），2D基于原点的线性变化可以被定义为向量 $[x, y]^T$ 左乘变换矩阵的数学表示：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n a_{11} & a_{12}\\\\\n a_{21} & a_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\n x \\\\\n y\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n a_{11}x & a_{12}y\\\\\n a_{21}x & a_{22}y\n\\end{bmatrix}</script><h3 id=\"缩放（scale）\"><a href=\"#缩放（scale）\" class=\"headerlink\" title=\"缩放（scale）\"></a>缩放（scale）</h3><p>缩放操作是将图形中所有点的坐标整体放大或者缩小某个数值，如下图所示的变换分别将$x, y$分别缩小了0.5:</p>\n<p><img src=\"/images/graphics1/graphics1_scale.png\" alt=\"\"><br>$[x, y]^T$经过变换后表示为$[x\\prime, y\\prime]^T$，经过变化后的值可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nx\\prime = 0.5 \\times x + 0 \\times y</script><script type=\"math/tex; mode=display\">\ny\\prime = 0 \\times x + 0.5 \\times y</script><p>上述操作可以使用变换矩阵表示为：</p>\n<script type=\"math/tex; mode=display\">\nscale(s_x, s_y)\n= \n\\begin{bmatrix}\n s_x & 0\\\\\n 0 & s_y\n\\end{bmatrix}</script><h3 id=\"剪切（Shear）\"><a href=\"#剪切（Shear）\" class=\"headerlink\" title=\"剪切（Shear）\"></a>剪切（Shear）</h3><p>剪切变换可以简单理解为将图形的一段固定，将其对端沿着固定方向拉动。以固定x轴为例：<br><img src=\"/images/graphics1/graphics1_shear.png\" alt=\"\"><br>所有点的\b$y$值保持不变，x坐标加上了对应的y值，经过变化后的值表示为：</p>\n<script type=\"math/tex; mode=display\">\nx\\prime =  x + 1 \\times y</script><script type=\"math/tex; mode=display\">\ny\\prime = 0 \\times x + y</script><p>上述操作可以使用变换矩阵表示为：</p>\n<script type=\"math/tex; mode=display\">\nshearX(s)\n= \n\\begin{bmatrix}\n 1 & s\\\\\n 0 & 1\n\\end{bmatrix}</script><script type=\"math/tex; mode=display\">\nshearY(s)\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n s & 1\n\\end{bmatrix}</script><h3 id=\"翻转（reflection）\"><a href=\"#翻转（reflection）\" class=\"headerlink\" title=\"翻转（reflection）\"></a>翻转（reflection）</h3><p>翻转一般是通过将某个坐标轴的所有值取反得到的，其变换矩阵可以表示为：<br>上述操作可以使用变换矩阵表示为：</p>\n<script type=\"math/tex; mode=display\">\nreflectionY\n= \n\\begin{bmatrix}\n -1 & 0\\\\\n 0 & 1\n\\end{bmatrix}</script><script type=\"math/tex; mode=display\">\nreflectionX\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n 0 & -1\n\\end{bmatrix}</script><p>以X轴翻转为例，经过变化矩阵计算后，图形变换如下：<br><img src=\"/images/graphics1/graphics1_reflection.png\" alt=\"\"></p>\n<h3 id=\"旋转（rotate）\"><a href=\"#旋转（rotate）\" class=\"headerlink\" title=\"旋转（rotate）\"></a>旋转（rotate）</h3><p>旋转的几何意义很容易理解，图形绕着原点逆时针旋转，但是数学上的变换关系并没有上述几种变换直观。为了便于理解，我们先假定图形中的一个任意向量 $\\vec{a}$ ，它与x轴的夹角为$\\alpha$，坐标为 $[x_a, y_a]$ 。向量的长度表示为  $r^2 = x_a^2 + y_a^2$ ，因此其坐标可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nx_a = rcos\\alpha</script><script type=\"math/tex; mode=display\">\ny_a = rsin\\alpha</script><p>当 $\\vec{a}$ 旋转了任意角度 $\\varphi$ 之后得到 $\\vec{b}$，此时 $\\vec{b}$ 与x轴的夹角为 $(\\alpha + \\varphi)$，坐标为$[x_b, y_b]$ 被表示为：</p>\n<script type=\"math/tex; mode=display\">\nx_b = rcos(\\alpha + \\varphi) = rcos\\alpha cos\\varphi - rsin\\alpha sin\\varphi</script><script type=\"math/tex; mode=display\">\ny_b = rsin(\\alpha + \\varphi) = rsin\\alpha cos\\varphi + r sin\\alpha sin\\varphi</script><p>根据$x_a = rcos\\alpha$以及$y_a = rsin\\alpha$我们可以化简得到：</p>\n<script type=\"math/tex; mode=display\">\nx_b = x_a cos\\varphi - y_a sin\\varphi</script><script type=\"math/tex; mode=display\">\ny_b = y_a cos\\varphi + x_a sin\\varphi</script><p>变换矩阵可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nrotate(\\varphi) = \n\\begin{bmatrix}\n cos\\varphi & -sin\\varphi\\\\\n sin\\varphi & cos\\varphi\n\\end{bmatrix}</script><p>举一个简单的旋转的例子，让图形逆时针旋转$\\pi/4$，变换矩阵的值为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi\\\\\nsin\\varphi & cos\\varphi\n\\end{bmatrix}\n= \n\\begin{bmatrix}\n0.707 & -0.707\\\\\n0.707 & 0.707\n\\end{bmatrix}</script><p>图形坐标经过计算后的样式如下：<br><img src=\"/images/graphics1/graphics1_rotate.png\" alt=\"\"></p>\n<h2 id=\"3D线性变换\"><a href=\"#3D线性变换\" class=\"headerlink\" title=\"3D线性变换\"></a>3D线性变换</h2><p>了解了2D线性变换之后，3D线性变换的推倒思路是一致的，仅仅是多增加了一个纬度的判断罢了。</p>\n<h3 id=\"缩放、剪切、翻转\"><a href=\"#缩放、剪切、翻转\" class=\"headerlink\" title=\"缩放、剪切、翻转\"></a>缩放、剪切、翻转</h3><p>3D缩放比较简单，直接通过2D缩放进行扩展：</p>\n<script type=\"math/tex; mode=display\">\nscale(s_x, s_y, s_z) = \n\\begin{bmatrix}\ns_x & 0 & 0\\\\\n0 & s_y & 0\\\\\n0 & 0 & s_z\n\\end{bmatrix}</script><p>3D剪切也可以通过2D剪切做类似的扩展：</p>\n<script type=\"math/tex; mode=display\">\nshearX(d_y, d_z) = \n\\begin{bmatrix}\n1 & d_y & d_z\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>3D的旋转稍稍复杂一点点，因为在3D场景下旋转可以是以原点为中心绕着任意轴进行旋转。在2D中是由x轴向y轴旋转，换算到3D空间中就是绕着z轴进行旋转(绕z轴，z的值不会发生变化，因此变换矩阵第三行没有变化)：</p>\n<script type=\"math/tex; mode=display\">\nrotateZ(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>绕着x轴的旋转可以理解为在2D场景下的yz平面，由y轴转向z轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：</p>\n<script type=\"math/tex; mode=display\">\nrotateX(\\varphi) = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & cos\\varphi & -sin\\varphi\\\\\n0 & sin\\varphi & cos\\varphi\n\\end{bmatrix}</script><p>绕着y轴的旋转可以理解为在2D场景下的xz平面，由z轴转向x轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：</p>\n<script type=\"math/tex; mode=display\">\nrotateY(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & 0 & sin\\varphi\\\\\n0 & 1 & 0\\\\\n-sin\\varphi & 0  & cos\\varphi\n\\end{bmatrix}</script>"},{"title":"计算机图形学2 —— 图形变换扩展","index_img":"/images/graphics2/graphics2_banner.jpeg","date":"2020-08-17T13:09:11.000Z","math":true,"_content":"## 线性变换的组合和分解\n\n### 线性变换的组合\n在前文我们提到，所有的线性变换都可以扩展成为变换矩阵左乘于源坐标点的数学表示。当对一个向量应用多次变换时的数学表示则是按照顺序分别左乘变换矩阵：\n$$\nfirst, v_2 = Sv_1, then, v_3 = Rv_2\n$$\n可以被表示为：\n$$\nv_3 = R(Sv_1)\n$$\n根据矩阵计算的结合律可以推导为：\n$$\nv_3 = (RS)v_1\n$$\n根据上面的推导可以发现一个规律，矩阵经过的两次变换$S$、$R$，可以表示为一次变换矩阵$M$，其中$M = RS$。其中矩阵乘法的顺序很重要。\n![](/images/graphics2/graphics2_compose.png)\n\n### 线性变换的分解\n既然多个变换矩阵可以合并为同一个变换矩阵，那么一个变换矩阵也可以被分解为多个变换矩阵的乘积。利用矩阵分解知识我们知道，对于给定 $A_{n*n}$ 的方阵，如果其具有n个线性无关的特征向量，那么可以被分解为，正交矩阵与对角矩阵相乘的形式，这个过程：\n$$\nA = RSR^T\n$$\n其中 $R$ 为特征向量组成的正交矩阵，$S$ 为其特征值组成的对角矩阵。在$n=2$的情况下，$R$ 由其特征向量 $v_1, v_2$ 组成，$R = [v_1, v_2]$。$S$的对角值分别为其特征值 $\\lambda_1$、$\\lambda_2$。\n\n根据其分解出的矩阵的特点，我们可以通过几何意义来对 $A$ 进行线性变换分解，$R$ 可以看作是一个旋转变换，$S$可以看作是缩放变换，因此原变换矩阵 $A$ 被分解为以下三个步骤：\n\n1. 将其特征向量 $v_1$ 和 $v_2$ 旋转到 $x, y$轴上即变换矩阵 $R^T$。\n2. 将变换后的矩阵进行缩放，$x, y$ 方向分别被缩放 $(\\lambda_1, \\lambda_2)$ 即变换矩阵$S$。\n3. 将变换后的特征向量 $v_1$ 和 $v_2$ 旋转回原来的位置即变换矩阵 $R$\n![](/images/graphics2/graphics2_decompose.png)\n\n### 绕任意轴旋转\n\n前文中提到了绕 $x, y, z$轴旋转的变换矩阵，根据矩阵分解和组合的特性我们可以推倒出绕任意轴旋转的变换矩阵。绕任意轴旋转可以被分解为以下三步：\n1. 通过变换矩阵$R_{uvw}^T$将需要做旋转的向量的向量空间变换到笛卡尔坐标系中，使得原向量空间下的 $u, v ,w$ 和 $x, y, z$做对齐。\n2. 做绕 $x$ 轴的旋转，变换矩阵为标准旋转矩阵$R_x$\n3. 通过变换矩阵$R_{uvw}$将旋转后的矩阵, 在重新变换为原向量空间下的 $u, v, w$中。\n\n以上过程可以用以下公式表示：\n$$\nR_a = R_{uvw} R_x R_{uvw}^T\n$$\n\n下面讨论下$R_{uvw}$这个矩阵，这里面会涉及到一部分向量空间的知识。为了方便理解，这里先不过多的讨论理论知识，按照方便理解的方式来进行讨论。假设$x, y, z$轴三个方向上的单位向量组成的矩阵：\n$$\nR_E = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n这三个向量互为正交，因此当我们为其做一些线性变换后(比如说绕z轴旋转45度后再绕y轴旋转45度，然后在缩放2倍)，三个向量依旧是正交的，通过线性变换 $R_{uvw}^T$ 变换之后，我们可以得到正交矩阵 $R_{uvw}$ \n$$\nR_{uvw} = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n$$\n下面证明上面的表达式为何能成立，假定$u = x_ux + y_uy + z_uz$，$v, w$同理，根据正交矩阵的特性，可以得到以下推倒：\n$$\nu  \\cdot u = v \\cdot v = w \\cdot w = 1\n$$\n$$\nu \\cdot v = v \\cdot w = w \\cdot u = 0\n$$\n利用这个特性，我们可以使用变换矩阵$R_{uvw}$将u变换到x轴上：\n$$\nR_{uvw}u = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u \\\\\ny_u \\\\\nz_u\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nx_ux_u + y_vy_v + z_wz_w\\\\\nx_vx_u + y_vy_u + z_vy_u\\\\\nx_wx_u + y_wy_u + z_wx_u\n\\end{bmatrix}\n$$\n上式可以被化简为：\n$$\nR_{uvw}u = \n\\begin{bmatrix}\nu \\cdot u\\\\\nv \\cdot u\\\\\nw \\cdot u\n= \n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n= \nx\n$$\n同理可以推导出$R_{uvw}v = y$以及$R_{uvw}w = z$\n对于还原变换矩阵$R_{uvw}^T$同理也可以通过上述方式推导如何将坐标轴${x, y, z}$变换到$u, v, w$上去。\n总结来看，对于任意轴的旋转可以用下列公式进行表示：\n$$\nR_a = R_{uvw} R_x R_{uvw}^T = \n\\begin{bmatrix}\nx_u & y_u & z_u\\\\\nx_v & y_v & z_v\\\\\nx_w & y_w & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n$$\n\n## 齐次坐标\n平移操作也是矩阵中经常会出现的情况，它变换后的坐标$x^\\prime,y^\\prime$可以很方便的通过公式表示:\n$$\nx^\\prime = x + x_t\n$$\n$$\ny^\\prime = y = y_t\n$$\n但是平移变换很难通过与待变换矩阵同纬度的变换矩阵来进行表示，因为它不属于线性变换。这里需要引入其次坐标的概念，通过原本是n维的向量用一个n+1维向量来表示。比如我们原有的平面中的点$(x, y)$升纬到3D表示为：$[x, y, 1]^T$，这样就可以将平移操作表示3D中的线性变换矩阵：\n$$\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n此时再对$x^\\prime,y^\\prime$做计算，可以得到：\n$$\n\\begin{bmatrix}\nx^\\prime \\\\\ny^\\prime \\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nm_{11}x + m_{12}y + x_t\\\\\nm_{21}x + m_{22}y + y_t\\\\\n1\n\\end{bmatrix}\n$$\n\n**注：在其次坐标中最后一维取值为0时，代表一个方向，取值为1时代表一个点**","source":"_posts/ComputerGraphics2.md","raw":"---\ntitle: 计算机图形学2 —— 图形变换扩展\ntags: [计算机图形学, 线性代数]\ncategories: [GAMES101]\nindex_img: /images/graphics2/graphics2_banner.jpeg\ndate: 2020-08-17 21:09:11\nmath: true\n---\n## 线性变换的组合和分解\n\n### 线性变换的组合\n在前文我们提到，所有的线性变换都可以扩展成为变换矩阵左乘于源坐标点的数学表示。当对一个向量应用多次变换时的数学表示则是按照顺序分别左乘变换矩阵：\n$$\nfirst, v_2 = Sv_1, then, v_3 = Rv_2\n$$\n可以被表示为：\n$$\nv_3 = R(Sv_1)\n$$\n根据矩阵计算的结合律可以推导为：\n$$\nv_3 = (RS)v_1\n$$\n根据上面的推导可以发现一个规律，矩阵经过的两次变换$S$、$R$，可以表示为一次变换矩阵$M$，其中$M = RS$。其中矩阵乘法的顺序很重要。\n![](/images/graphics2/graphics2_compose.png)\n\n### 线性变换的分解\n既然多个变换矩阵可以合并为同一个变换矩阵，那么一个变换矩阵也可以被分解为多个变换矩阵的乘积。利用矩阵分解知识我们知道，对于给定 $A_{n*n}$ 的方阵，如果其具有n个线性无关的特征向量，那么可以被分解为，正交矩阵与对角矩阵相乘的形式，这个过程：\n$$\nA = RSR^T\n$$\n其中 $R$ 为特征向量组成的正交矩阵，$S$ 为其特征值组成的对角矩阵。在$n=2$的情况下，$R$ 由其特征向量 $v_1, v_2$ 组成，$R = [v_1, v_2]$。$S$的对角值分别为其特征值 $\\lambda_1$、$\\lambda_2$。\n\n根据其分解出的矩阵的特点，我们可以通过几何意义来对 $A$ 进行线性变换分解，$R$ 可以看作是一个旋转变换，$S$可以看作是缩放变换，因此原变换矩阵 $A$ 被分解为以下三个步骤：\n\n1. 将其特征向量 $v_1$ 和 $v_2$ 旋转到 $x, y$轴上即变换矩阵 $R^T$。\n2. 将变换后的矩阵进行缩放，$x, y$ 方向分别被缩放 $(\\lambda_1, \\lambda_2)$ 即变换矩阵$S$。\n3. 将变换后的特征向量 $v_1$ 和 $v_2$ 旋转回原来的位置即变换矩阵 $R$\n![](/images/graphics2/graphics2_decompose.png)\n\n### 绕任意轴旋转\n\n前文中提到了绕 $x, y, z$轴旋转的变换矩阵，根据矩阵分解和组合的特性我们可以推倒出绕任意轴旋转的变换矩阵。绕任意轴旋转可以被分解为以下三步：\n1. 通过变换矩阵$R_{uvw}^T$将需要做旋转的向量的向量空间变换到笛卡尔坐标系中，使得原向量空间下的 $u, v ,w$ 和 $x, y, z$做对齐。\n2. 做绕 $x$ 轴的旋转，变换矩阵为标准旋转矩阵$R_x$\n3. 通过变换矩阵$R_{uvw}$将旋转后的矩阵, 在重新变换为原向量空间下的 $u, v, w$中。\n\n以上过程可以用以下公式表示：\n$$\nR_a = R_{uvw} R_x R_{uvw}^T\n$$\n\n下面讨论下$R_{uvw}$这个矩阵，这里面会涉及到一部分向量空间的知识。为了方便理解，这里先不过多的讨论理论知识，按照方便理解的方式来进行讨论。假设$x, y, z$轴三个方向上的单位向量组成的矩阵：\n$$\nR_E = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n这三个向量互为正交，因此当我们为其做一些线性变换后(比如说绕z轴旋转45度后再绕y轴旋转45度，然后在缩放2倍)，三个向量依旧是正交的，通过线性变换 $R_{uvw}^T$ 变换之后，我们可以得到正交矩阵 $R_{uvw}$ \n$$\nR_{uvw} = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n$$\n下面证明上面的表达式为何能成立，假定$u = x_ux + y_uy + z_uz$，$v, w$同理，根据正交矩阵的特性，可以得到以下推倒：\n$$\nu  \\cdot u = v \\cdot v = w \\cdot w = 1\n$$\n$$\nu \\cdot v = v \\cdot w = w \\cdot u = 0\n$$\n利用这个特性，我们可以使用变换矩阵$R_{uvw}$将u变换到x轴上：\n$$\nR_{uvw}u = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u \\\\\ny_u \\\\\nz_u\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nx_ux_u + y_vy_v + z_wz_w\\\\\nx_vx_u + y_vy_u + z_vy_u\\\\\nx_wx_u + y_wy_u + z_wx_u\n\\end{bmatrix}\n$$\n上式可以被化简为：\n$$\nR_{uvw}u = \n\\begin{bmatrix}\nu \\cdot u\\\\\nv \\cdot u\\\\\nw \\cdot u\n= \n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n= \nx\n$$\n同理可以推导出$R_{uvw}v = y$以及$R_{uvw}w = z$\n对于还原变换矩阵$R_{uvw}^T$同理也可以通过上述方式推导如何将坐标轴${x, y, z}$变换到$u, v, w$上去。\n总结来看，对于任意轴的旋转可以用下列公式进行表示：\n$$\nR_a = R_{uvw} R_x R_{uvw}^T = \n\\begin{bmatrix}\nx_u & y_u & z_u\\\\\nx_v & y_v & z_v\\\\\nx_w & y_w & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n$$\n\n## 齐次坐标\n平移操作也是矩阵中经常会出现的情况，它变换后的坐标$x^\\prime,y^\\prime$可以很方便的通过公式表示:\n$$\nx^\\prime = x + x_t\n$$\n$$\ny^\\prime = y = y_t\n$$\n但是平移变换很难通过与待变换矩阵同纬度的变换矩阵来进行表示，因为它不属于线性变换。这里需要引入其次坐标的概念，通过原本是n维的向量用一个n+1维向量来表示。比如我们原有的平面中的点$(x, y)$升纬到3D表示为：$[x, y, 1]^T$，这样就可以将平移操作表示3D中的线性变换矩阵：\n$$\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n此时再对$x^\\prime,y^\\prime$做计算，可以得到：\n$$\n\\begin{bmatrix}\nx^\\prime \\\\\ny^\\prime \\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nm_{11}x + m_{12}y + x_t\\\\\nm_{21}x + m_{22}y + y_t\\\\\n1\n\\end{bmatrix}\n$$\n\n**注：在其次坐标中最后一维取值为0时，代表一个方向，取值为1时代表一个点**","slug":"ComputerGraphics2","published":1,"updated":"2020-10-03T07:35:24.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckftgqfal00022wqc31nx63tm","content":"<h2 id=\"线性变换的组合和分解\"><a href=\"#线性变换的组合和分解\" class=\"headerlink\" title=\"线性变换的组合和分解\"></a>线性变换的组合和分解</h2><h3 id=\"线性变换的组合\"><a href=\"#线性变换的组合\" class=\"headerlink\" title=\"线性变换的组合\"></a>线性变换的组合</h3><p>在前文我们提到，所有的线性变换都可以扩展成为变换矩阵左乘于源坐标点的数学表示。当对一个向量应用多次变换时的数学表示则是按照顺序分别左乘变换矩阵：</p>\n<script type=\"math/tex; mode=display\">\nfirst, v_2 = Sv_1, then, v_3 = Rv_2</script><p>可以被表示为：</p>\n<script type=\"math/tex; mode=display\">\nv_3 = R(Sv_1)</script><p>根据矩阵计算的结合律可以推导为：</p>\n<script type=\"math/tex; mode=display\">\nv_3 = (RS)v_1</script><p>根据上面的推导可以发现一个规律，矩阵经过的两次变换$S$、$R$，可以表示为一次变换矩阵$M$，其中$M = RS$。其中矩阵乘法的顺序很重要。<br><img src=\"/images/graphics2/graphics2_compose.png\" alt=\"\"></p>\n<h3 id=\"线性变换的分解\"><a href=\"#线性变换的分解\" class=\"headerlink\" title=\"线性变换的分解\"></a>线性变换的分解</h3><p>既然多个变换矩阵可以合并为同一个变换矩阵，那么一个变换矩阵也可以被分解为多个变换矩阵的乘积。利用矩阵分解知识我们知道，对于给定 $A_{n*n}$ 的方阵，如果其具有n个线性无关的特征向量，那么可以被分解为，正交矩阵与对角矩阵相乘的形式，这个过程：</p>\n<script type=\"math/tex; mode=display\">\nA = RSR^T</script><p>其中 $R$ 为特征向量组成的正交矩阵，$S$ 为其特征值组成的对角矩阵。在$n=2$的情况下，$R$ 由其特征向量 $v_1, v_2$ 组成，$R = [v_1, v_2]$。$S$的对角值分别为其特征值 $\\lambda_1$、$\\lambda_2$。</p>\n<p>根据其分解出的矩阵的特点，我们可以通过几何意义来对 $A$ 进行线性变换分解，$R$ 可以看作是一个旋转变换，$S$可以看作是缩放变换，因此原变换矩阵 $A$ 被分解为以下三个步骤：</p>\n<ol>\n<li>将其特征向量 $v_1$ 和 $v_2$ 旋转到 $x, y$轴上即变换矩阵 $R^T$。</li>\n<li>将变换后的矩阵进行缩放，$x, y$ 方向分别被缩放 $(\\lambda_1, \\lambda_2)$ 即变换矩阵$S$。</li>\n<li>将变换后的特征向量 $v_1$ 和 $v_2$ 旋转回原来的位置即变换矩阵 $R$<br><img src=\"/images/graphics2/graphics2_decompose.png\" alt=\"\"></li>\n</ol>\n<h3 id=\"绕任意轴旋转\"><a href=\"#绕任意轴旋转\" class=\"headerlink\" title=\"绕任意轴旋转\"></a>绕任意轴旋转</h3><p>前文中提到了绕 $x, y, z$轴旋转的变换矩阵，根据矩阵分解和组合的特性我们可以推倒出绕任意轴旋转的变换矩阵。绕任意轴旋转可以被分解为以下三步：</p>\n<ol>\n<li>通过变换矩阵$R_{uvw}^T$将需要做旋转的向量的向量空间变换到笛卡尔坐标系中，使得原向量空间下的 $u, v ,w$ 和 $x, y, z$做对齐。</li>\n<li>做绕 $x$ 轴的旋转，变换矩阵为标准旋转矩阵$R_x$</li>\n<li>通过变换矩阵$R_{uvw}$将旋转后的矩阵, 在重新变换为原向量空间下的 $u, v, w$中。</li>\n</ol>\n<p>以上过程可以用以下公式表示：</p>\n<script type=\"math/tex; mode=display\">\nR_a = R_{uvw} R_x R_{uvw}^T</script><p>下面讨论下$R_{uvw}$这个矩阵，这里面会涉及到一部分向量空间的知识。为了方便理解，这里先不过多的讨论理论知识，按照方便理解的方式来进行讨论。假设$x, y, z$轴三个方向上的单位向量组成的矩阵：</p>\n<script type=\"math/tex; mode=display\">\nR_E = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>这三个向量互为正交，因此当我们为其做一些线性变换后(比如说绕z轴旋转45度后再绕y轴旋转45度，然后在缩放2倍)，三个向量依旧是正交的，通过线性变换 $R<em>{uvw}^T$ 变换之后，我们可以得到正交矩阵 $R</em>{uvw}$ </p>\n<script type=\"math/tex; mode=display\">\nR_{uvw} = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}</script><p>下面证明上面的表达式为何能成立，假定$u = x_ux + y_uy + z_uz$，$v, w$同理，根据正交矩阵的特性，可以得到以下推倒：</p>\n<script type=\"math/tex; mode=display\">\nu  \\cdot u = v \\cdot v = w \\cdot w = 1</script><script type=\"math/tex; mode=display\">\nu \\cdot v = v \\cdot w = w \\cdot u = 0</script><p>利用这个特性，我们可以使用变换矩阵$R_{uvw}$将u变换到x轴上：</p>\n<script type=\"math/tex; mode=display\">\nR_{uvw}u = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u \\\\\ny_u \\\\\nz_u\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nx_ux_u + y_vy_v + z_wz_w\\\\\nx_vx_u + y_vy_u + z_vy_u\\\\\nx_wx_u + y_wy_u + z_wx_u\n\\end{bmatrix}</script><p>上式可以被化简为：</p>\n<script type=\"math/tex; mode=display\">\nR_{uvw}u = \n\\begin{bmatrix}\nu \\cdot u\\\\\nv \\cdot u\\\\\nw \\cdot u\n= \n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n= \nx</script><p>同理可以推导出$R<em>{uvw}v = y$以及$R</em>{uvw}w = z$<br>对于还原变换矩阵$R_{uvw}^T$同理也可以通过上述方式推导如何将坐标轴${x, y, z}$变换到$u, v, w$上去。<br>总结来看，对于任意轴的旋转可以用下列公式进行表示：</p>\n<script type=\"math/tex; mode=display\">\nR_a = R_{uvw} R_x R_{uvw}^T = \n\\begin{bmatrix}\nx_u & y_u & z_u\\\\\nx_v & y_v & z_v\\\\\nx_w & y_w & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}</script><h2 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h2><p>平移操作也是矩阵中经常会出现的情况，它变换后的坐标$x^\\prime,y^\\prime$可以很方便的通过公式表示:</p>\n<script type=\"math/tex; mode=display\">\nx^\\prime = x + x_t</script><script type=\"math/tex; mode=display\">\ny^\\prime = y = y_t</script><p>但是平移变换很难通过与待变换矩阵同纬度的变换矩阵来进行表示，因为它不属于线性变换。这里需要引入其次坐标的概念，通过原本是n维的向量用一个n+1维向量来表示。比如我们原有的平面中的点$(x, y)$升纬到3D表示为：$[x, y, 1]^T$，这样就可以将平移操作表示3D中的线性变换矩阵：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>此时再对$x^\\prime,y^\\prime$做计算，可以得到：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\nx^\\prime \\\\\ny^\\prime \\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nm_{11}x + m_{12}y + x_t\\\\\nm_{21}x + m_{22}y + y_t\\\\\n1\n\\end{bmatrix}</script><p><strong>注：在其次坐标中最后一维取值为0时，代表一个方向，取值为1时代表一个点</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"线性变换的组合和分解\"><a href=\"#线性变换的组合和分解\" class=\"headerlink\" title=\"线性变换的组合和分解\"></a>线性变换的组合和分解</h2><h3 id=\"线性变换的组合\"><a href=\"#线性变换的组合\" class=\"headerlink\" title=\"线性变换的组合\"></a>线性变换的组合</h3><p>在前文我们提到，所有的线性变换都可以扩展成为变换矩阵左乘于源坐标点的数学表示。当对一个向量应用多次变换时的数学表示则是按照顺序分别左乘变换矩阵：</p>\n<script type=\"math/tex; mode=display\">\nfirst, v_2 = Sv_1, then, v_3 = Rv_2</script><p>可以被表示为：</p>\n<script type=\"math/tex; mode=display\">\nv_3 = R(Sv_1)</script><p>根据矩阵计算的结合律可以推导为：</p>\n<script type=\"math/tex; mode=display\">\nv_3 = (RS)v_1</script><p>根据上面的推导可以发现一个规律，矩阵经过的两次变换$S$、$R$，可以表示为一次变换矩阵$M$，其中$M = RS$。其中矩阵乘法的顺序很重要。<br><img src=\"/images/graphics2/graphics2_compose.png\" alt=\"\"></p>\n<h3 id=\"线性变换的分解\"><a href=\"#线性变换的分解\" class=\"headerlink\" title=\"线性变换的分解\"></a>线性变换的分解</h3><p>既然多个变换矩阵可以合并为同一个变换矩阵，那么一个变换矩阵也可以被分解为多个变换矩阵的乘积。利用矩阵分解知识我们知道，对于给定 $A_{n*n}$ 的方阵，如果其具有n个线性无关的特征向量，那么可以被分解为，正交矩阵与对角矩阵相乘的形式，这个过程：</p>\n<script type=\"math/tex; mode=display\">\nA = RSR^T</script><p>其中 $R$ 为特征向量组成的正交矩阵，$S$ 为其特征值组成的对角矩阵。在$n=2$的情况下，$R$ 由其特征向量 $v_1, v_2$ 组成，$R = [v_1, v_2]$。$S$的对角值分别为其特征值 $\\lambda_1$、$\\lambda_2$。</p>\n<p>根据其分解出的矩阵的特点，我们可以通过几何意义来对 $A$ 进行线性变换分解，$R$ 可以看作是一个旋转变换，$S$可以看作是缩放变换，因此原变换矩阵 $A$ 被分解为以下三个步骤：</p>\n<ol>\n<li>将其特征向量 $v_1$ 和 $v_2$ 旋转到 $x, y$轴上即变换矩阵 $R^T$。</li>\n<li>将变换后的矩阵进行缩放，$x, y$ 方向分别被缩放 $(\\lambda_1, \\lambda_2)$ 即变换矩阵$S$。</li>\n<li>将变换后的特征向量 $v_1$ 和 $v_2$ 旋转回原来的位置即变换矩阵 $R$<br><img src=\"/images/graphics2/graphics2_decompose.png\" alt=\"\"></li>\n</ol>\n<h3 id=\"绕任意轴旋转\"><a href=\"#绕任意轴旋转\" class=\"headerlink\" title=\"绕任意轴旋转\"></a>绕任意轴旋转</h3><p>前文中提到了绕 $x, y, z$轴旋转的变换矩阵，根据矩阵分解和组合的特性我们可以推倒出绕任意轴旋转的变换矩阵。绕任意轴旋转可以被分解为以下三步：</p>\n<ol>\n<li>通过变换矩阵$R_{uvw}^T$将需要做旋转的向量的向量空间变换到笛卡尔坐标系中，使得原向量空间下的 $u, v ,w$ 和 $x, y, z$做对齐。</li>\n<li>做绕 $x$ 轴的旋转，变换矩阵为标准旋转矩阵$R_x$</li>\n<li>通过变换矩阵$R_{uvw}$将旋转后的矩阵, 在重新变换为原向量空间下的 $u, v, w$中。</li>\n</ol>\n<p>以上过程可以用以下公式表示：</p>\n<script type=\"math/tex; mode=display\">\nR_a = R_{uvw} R_x R_{uvw}^T</script><p>下面讨论下$R_{uvw}$这个矩阵，这里面会涉及到一部分向量空间的知识。为了方便理解，这里先不过多的讨论理论知识，按照方便理解的方式来进行讨论。假设$x, y, z$轴三个方向上的单位向量组成的矩阵：</p>\n<script type=\"math/tex; mode=display\">\nR_E = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>这三个向量互为正交，因此当我们为其做一些线性变换后(比如说绕z轴旋转45度后再绕y轴旋转45度，然后在缩放2倍)，三个向量依旧是正交的，通过线性变换 $R<em>{uvw}^T$ 变换之后，我们可以得到正交矩阵 $R</em>{uvw}$ </p>\n<script type=\"math/tex; mode=display\">\nR_{uvw} = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}</script><p>下面证明上面的表达式为何能成立，假定$u = x_ux + y_uy + z_uz$，$v, w$同理，根据正交矩阵的特性，可以得到以下推倒：</p>\n<script type=\"math/tex; mode=display\">\nu  \\cdot u = v \\cdot v = w \\cdot w = 1</script><script type=\"math/tex; mode=display\">\nu \\cdot v = v \\cdot w = w \\cdot u = 0</script><p>利用这个特性，我们可以使用变换矩阵$R_{uvw}$将u变换到x轴上：</p>\n<script type=\"math/tex; mode=display\">\nR_{uvw}u = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u \\\\\ny_u \\\\\nz_u\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nx_ux_u + y_vy_v + z_wz_w\\\\\nx_vx_u + y_vy_u + z_vy_u\\\\\nx_wx_u + y_wy_u + z_wx_u\n\\end{bmatrix}</script><p>上式可以被化简为：</p>\n<script type=\"math/tex; mode=display\">\nR_{uvw}u = \n\\begin{bmatrix}\nu \\cdot u\\\\\nv \\cdot u\\\\\nw \\cdot u\n= \n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n= \nx</script><p>同理可以推导出$R<em>{uvw}v = y$以及$R</em>{uvw}w = z$<br>对于还原变换矩阵$R_{uvw}^T$同理也可以通过上述方式推导如何将坐标轴${x, y, z}$变换到$u, v, w$上去。<br>总结来看，对于任意轴的旋转可以用下列公式进行表示：</p>\n<script type=\"math/tex; mode=display\">\nR_a = R_{uvw} R_x R_{uvw}^T = \n\\begin{bmatrix}\nx_u & y_u & z_u\\\\\nx_v & y_v & z_v\\\\\nx_w & y_w & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}</script><h2 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h2><p>平移操作也是矩阵中经常会出现的情况，它变换后的坐标$x^\\prime,y^\\prime$可以很方便的通过公式表示:</p>\n<script type=\"math/tex; mode=display\">\nx^\\prime = x + x_t</script><script type=\"math/tex; mode=display\">\ny^\\prime = y = y_t</script><p>但是平移变换很难通过与待变换矩阵同纬度的变换矩阵来进行表示，因为它不属于线性变换。这里需要引入其次坐标的概念，通过原本是n维的向量用一个n+1维向量来表示。比如我们原有的平面中的点$(x, y)$升纬到3D表示为：$[x, y, 1]^T$，这样就可以将平移操作表示3D中的线性变换矩阵：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>此时再对$x^\\prime,y^\\prime$做计算，可以得到：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\nx^\\prime \\\\\ny^\\prime \\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nm_{11}x + m_{12}y + x_t\\\\\nm_{21}x + m_{22}y + y_t\\\\\n1\n\\end{bmatrix}</script><p><strong>注：在其次坐标中最后一维取值为0时，代表一个方向，取值为1时代表一个点</strong></p>\n"},{"title":"计算机图形学3 —— 视图变换","index_img":"/images/graphics3/graphics3_banner.png","date":"2020-08-24T14:19:33.000Z","math":true,"_content":"视图变换（viewing transform）的主要职责是将3D物体的坐标（我们取标准坐标$(x, y, z)$映射到屏幕的一个个像素点上来。它的过程可以说是比较复杂的，因为在视图变换的过程中很多因素可以决定最后成像的效果。视图变换可以分为四个过程，模型变换（modal transform）、 视角变换（view transform）、投影变换（projection transform）以及视口变换（viewport transformation）。这个过程可以拿拍照片来类比：\n1. 站好位置，摆好姿势（modal transform）\n2. 找好角度，调整相机位置（view transform）\n3. 拍摄照片，将3D场景拍摄到2D的照片（projection transform && viewport transformation）\n\n在拍照片的过程中我们模拟了视图变换的过程。首先是模型变换，我们需要将模型从模型坐标变换到世界坐标中来，也就是在拍照过程中让人站好姿势、摆好位置。调整相机位置，也就是调整在世界坐标中从哪个方向去观测。这个过程我们需要确定两个方向，一个方向是观测的朝向，另一个方向就是与观测朝向“向上”的方向，比如说我们朝着$-Z$方向去看，那么“向上”方向就是$Y$方向。当以上过程都完成后，我们需要将3D场景转换到2D屏幕上，就需要通过投影的方式做像素映射。\n\n![](/images/graphics3/graphics3_transformation.png)\n\n## 相机变换 view/camera transform\n结合在上一篇我们讨论的绕任意轴旋转的变换推导中，我们其实可以很容易使用类似的思路来进行推导相机变换。还记得为什么在相机变换的过程中，为什么除了看向方向（look-at direction）之外表示为$g$，还需要一个“向上”的方向（up direction）表示为$t$，有了着两个方向以及相机的位置$e$。\n我们在根据坐标系法则就可以建立起一个三位坐标$u,v,w$。定义如下：\n$$\nw =  -\\frac{g}{\\left |\\left | g \\right |   \\right | } \n$$\n\n$$\nu = \\frac{t \\times w }{ \\left |\\left | {t \\times w} \\right |   \\right |  }  \n$$\n\n$$\nv = w \\times u\n$$\n\n![](/images/graphics3/graphics3_camera.png)\n摄像机变换就可以看作将$x,y,z$坐标系转换到$u,v,w$坐标系的过程。我们将变换矩阵写作$M_{view}$，令\n\n$$\nM_{view} = R_{view}T_{view}\n$$\n\n其中$R$是改变相机朝向的的变换矩阵，它的作用是使得$-Z$旋转到看向方向$u$，$Y$旋转到“向上“的方向$v$。$T_{view}$是移动相机位置的矩阵，是一个平移矩阵，可以被表示为：\n\n$$\nT_{view} =\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n旋转的过程在前面的章节有提过，如果需要使用$R$变换矩阵，因此$M$可以被表示为：\n\n$$\nM_{view} = \n\n\\begin{bmatrix}\nx_u & y_u & z_u & 0\\\\\nx_v & y_v & z_v & 0\\\\\nx_w & y_w & z_w & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n## 投影变换 pojection transform\n投影变换的过程主要是将3D的点投影到2D的屏幕上来，根据变换条件的不同，可以将投影区分为正交投影和透视投影。如下图所示展现了两种投影的变换方式和成像结果。\n![](/images/graphics3/graphics3_banner.png)\n### 正交投影 Orthographic Projection Transformation\n正交投影很好理解，在正交投影之后图形中所有点的的相对位置都不会发生改变，可以将其看作直接将图形“压扁”，然后放置在某一平面上。\n![](/images/graphics3/graphic3_orthographic.png)\n在实际渲染过程中，我们总是希望在某个空间区域来渲染图形，而非根据整个视图区域来做渲染。假设渲染发生在一个沿着$Z$轴负方向，底面（bottom）与$XY$平面平行的一个立方体。这时候可以定义左右面（left, right）以及近远面（near, far），以及上下面（top, bottom）用以下代数表示：\n$$\nx = l = left{\\space}plane\n$$\n\n$$\nx = r = right{\\space}plane\n$$\n\n$$\ny = v = bottom{\\space}plane\n$$\n\n$$\ny = t = left{\\space}plane\n$$\n\n$$\nz = n = near{\\space}plane\n$$\n\n$$\nz = f = far{\\space}plane\n$$\n简单来说，正交投影的主要原理是将上述区域变换到一个”正则、规范、标准“的立方体$[-1, 1]^3$中来。这个变换过程可以分解为两个变换：\n1. 将渲染盒子平移到以原点为中心的位置，即每个定点到投影平面的距离为 边长/2\n2. 将渲染盒子缩放为立方体$[-1, 1]^3$\n![](/images/graphics3/graphics3_orthographic_transform.png)\n这个过程可以用变换矩阵表示为：\n$$\nM_{ortho} = \n\\begin{bmatrix}\n\\frac{2}{r - l} & 0 & 0 & 0\\\\\n0 & \\frac{2}{t - b} & 0 & 0\\\\\n0 & 0 & \\frac{2}{n - f} & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n\\begin{bmatrix}\n1 & 0 & 0 & -\\frac{r+l}{2}\\\\\n0 & 1 & 0 & -\\frac{t+b}{2}\\\\\n0 & 0 & 1 & -\\frac{n+f}{2}\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n$$\n### 透视投影 Perspective Projection Transformation\n透视投影和正交投影最大的区别在于，透视投影的过程不是“平行的”，投影的线最终会相交。因为透视投影需要实现真实的透视关系，也就是相等大小的物体，处于场景近端他会显示得更大，处于场景远端它会显示得更小。对于任意一点的投影过程可以用下图来表示：\n\n![](/images/graphics3/graphic3_orthographic_point.png)\n\n对于任意点$[x, y, z]$, 经过透视投影变换后到投影平面上，形成$[x^{\\prime}, y^{\\prime}, z^{\\prime}]$。图中的$z = -n$为投影平面，也就是我们的$near$面，假定$[x, y, z]$所在的与$XY$平面平行的面为$far$面。根据相似三角形法则，对于$y^{\\prime}$可以得到：\n$$\ny^{\\prime} = \\frac{n}{z}y {\\space}{\\space}{\\space}{\\space}{\\space}x^{\\prime} = \\frac{n}{z}x \n$$\n\n为了推导投影矩阵，我们列出其原点和投影点的关系，当被投影点坐标全部乘以$z$的时候，被投影点坐标变化如下：\n$$\n \\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n \\begin{pmatrix}\n nx/z\\\\\n ny/z\\\\\n unknown\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix}\n$$\n\n因此我们想要求的投影矩阵是执行了如下变化：\n$$\nM_{persp{\\to}ortho}^{4\\times4}:\n{\\space}\n\\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix} \n$$\n根据上面的变换过程我们可以将变换矩阵的确定项先写出来：\n$$\nM_{persp{\\to}ortho}^{4\\times4}=\n \\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n ? & ? & ? & ?\\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix} \n$$\n接下来就是如何确定不确定的这行的值了，在透视投影的可视空间中，发生透视变换后有两个特性：\n1. 所有在$near$面上的点，经过透视投影变换后其坐标值是不变的。\n2. 所有在$far$面上的点，经过透视投影变换后其$z$值是不变的。\n\n对于特性1，我们可以假定在near平面上的点$(x,y,n,1)^T$，经过变换之后，其坐标仍然保持不变。将所有坐标乘以$n$，得到：\n$$\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n nx\\\\\n ny\\\\\n n^2\\\\\n n\n\\end{pmatrix}\n$$\n通过上面的变换，我们可以得出一个结论——未知行额前两项必定为0，因为经过变换后的$z$值与$x,y$无关。因此假定最后一行为$(0,0,A,B)$，再计算第三行的乘法：\n$$\n\\begin{pmatrix}\n 0 {\\space}\n 0 {\\space}\n A {\\space}\n B \n\\end{pmatrix}\n\\begin{pmatrix}\n x \\\\\n y \\\\\n n \\\\\n 1 \n\\end{pmatrix}\n=\nn^2\n\\Rightarrow \nAn + B = n^2\n$$\n同理，利用特性二所有在$far$平面上的点的$z$值不会发生变化：\n$$\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f^2\\\\\n f\n\\end{pmatrix}\n\n\\Rightarrow \nAf + B = f^2\n$$\n\n联立两个等式，得到：\n$$\nA = f + n\n$$\n$$\nB = -nf\n$$\n因此变换矩阵$M_{persp{\\to}ortho}^{4\\times4}$的值为：\n$$\nM_{persp{\\to}ortho}^{4\\times4} =   \n\\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n 0 & 0 & f+n & -nf \\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix}  \n$$\n实际上，完成透视变换之后，再进行一次正交投影变换就彻底完成了以上透视投影变换：\n$$\nM_{persp} = M_{ortho}M_{persp{\\to}ortho}\n$$","source":"_posts/ComputerGraphics3.md","raw":"---\ntitle: 计算机图形学3 —— 视图变换\ntags: [计算机图形学, 投影，视图变换]\ncategories: [GAMES101]\nindex_img: /images/graphics3/graphics3_banner.png\ndate: 2020-08-24 22:19:33\nmath: true\n---\n视图变换（viewing transform）的主要职责是将3D物体的坐标（我们取标准坐标$(x, y, z)$映射到屏幕的一个个像素点上来。它的过程可以说是比较复杂的，因为在视图变换的过程中很多因素可以决定最后成像的效果。视图变换可以分为四个过程，模型变换（modal transform）、 视角变换（view transform）、投影变换（projection transform）以及视口变换（viewport transformation）。这个过程可以拿拍照片来类比：\n1. 站好位置，摆好姿势（modal transform）\n2. 找好角度，调整相机位置（view transform）\n3. 拍摄照片，将3D场景拍摄到2D的照片（projection transform && viewport transformation）\n\n在拍照片的过程中我们模拟了视图变换的过程。首先是模型变换，我们需要将模型从模型坐标变换到世界坐标中来，也就是在拍照过程中让人站好姿势、摆好位置。调整相机位置，也就是调整在世界坐标中从哪个方向去观测。这个过程我们需要确定两个方向，一个方向是观测的朝向，另一个方向就是与观测朝向“向上”的方向，比如说我们朝着$-Z$方向去看，那么“向上”方向就是$Y$方向。当以上过程都完成后，我们需要将3D场景转换到2D屏幕上，就需要通过投影的方式做像素映射。\n\n![](/images/graphics3/graphics3_transformation.png)\n\n## 相机变换 view/camera transform\n结合在上一篇我们讨论的绕任意轴旋转的变换推导中，我们其实可以很容易使用类似的思路来进行推导相机变换。还记得为什么在相机变换的过程中，为什么除了看向方向（look-at direction）之外表示为$g$，还需要一个“向上”的方向（up direction）表示为$t$，有了着两个方向以及相机的位置$e$。\n我们在根据坐标系法则就可以建立起一个三位坐标$u,v,w$。定义如下：\n$$\nw =  -\\frac{g}{\\left |\\left | g \\right |   \\right | } \n$$\n\n$$\nu = \\frac{t \\times w }{ \\left |\\left | {t \\times w} \\right |   \\right |  }  \n$$\n\n$$\nv = w \\times u\n$$\n\n![](/images/graphics3/graphics3_camera.png)\n摄像机变换就可以看作将$x,y,z$坐标系转换到$u,v,w$坐标系的过程。我们将变换矩阵写作$M_{view}$，令\n\n$$\nM_{view} = R_{view}T_{view}\n$$\n\n其中$R$是改变相机朝向的的变换矩阵，它的作用是使得$-Z$旋转到看向方向$u$，$Y$旋转到“向上“的方向$v$。$T_{view}$是移动相机位置的矩阵，是一个平移矩阵，可以被表示为：\n\n$$\nT_{view} =\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n旋转的过程在前面的章节有提过，如果需要使用$R$变换矩阵，因此$M$可以被表示为：\n\n$$\nM_{view} = \n\n\\begin{bmatrix}\nx_u & y_u & z_u & 0\\\\\nx_v & y_v & z_v & 0\\\\\nx_w & y_w & z_w & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n## 投影变换 pojection transform\n投影变换的过程主要是将3D的点投影到2D的屏幕上来，根据变换条件的不同，可以将投影区分为正交投影和透视投影。如下图所示展现了两种投影的变换方式和成像结果。\n![](/images/graphics3/graphics3_banner.png)\n### 正交投影 Orthographic Projection Transformation\n正交投影很好理解，在正交投影之后图形中所有点的的相对位置都不会发生改变，可以将其看作直接将图形“压扁”，然后放置在某一平面上。\n![](/images/graphics3/graphic3_orthographic.png)\n在实际渲染过程中，我们总是希望在某个空间区域来渲染图形，而非根据整个视图区域来做渲染。假设渲染发生在一个沿着$Z$轴负方向，底面（bottom）与$XY$平面平行的一个立方体。这时候可以定义左右面（left, right）以及近远面（near, far），以及上下面（top, bottom）用以下代数表示：\n$$\nx = l = left{\\space}plane\n$$\n\n$$\nx = r = right{\\space}plane\n$$\n\n$$\ny = v = bottom{\\space}plane\n$$\n\n$$\ny = t = left{\\space}plane\n$$\n\n$$\nz = n = near{\\space}plane\n$$\n\n$$\nz = f = far{\\space}plane\n$$\n简单来说，正交投影的主要原理是将上述区域变换到一个”正则、规范、标准“的立方体$[-1, 1]^3$中来。这个变换过程可以分解为两个变换：\n1. 将渲染盒子平移到以原点为中心的位置，即每个定点到投影平面的距离为 边长/2\n2. 将渲染盒子缩放为立方体$[-1, 1]^3$\n![](/images/graphics3/graphics3_orthographic_transform.png)\n这个过程可以用变换矩阵表示为：\n$$\nM_{ortho} = \n\\begin{bmatrix}\n\\frac{2}{r - l} & 0 & 0 & 0\\\\\n0 & \\frac{2}{t - b} & 0 & 0\\\\\n0 & 0 & \\frac{2}{n - f} & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n\\begin{bmatrix}\n1 & 0 & 0 & -\\frac{r+l}{2}\\\\\n0 & 1 & 0 & -\\frac{t+b}{2}\\\\\n0 & 0 & 1 & -\\frac{n+f}{2}\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n$$\n### 透视投影 Perspective Projection Transformation\n透视投影和正交投影最大的区别在于，透视投影的过程不是“平行的”，投影的线最终会相交。因为透视投影需要实现真实的透视关系，也就是相等大小的物体，处于场景近端他会显示得更大，处于场景远端它会显示得更小。对于任意一点的投影过程可以用下图来表示：\n\n![](/images/graphics3/graphic3_orthographic_point.png)\n\n对于任意点$[x, y, z]$, 经过透视投影变换后到投影平面上，形成$[x^{\\prime}, y^{\\prime}, z^{\\prime}]$。图中的$z = -n$为投影平面，也就是我们的$near$面，假定$[x, y, z]$所在的与$XY$平面平行的面为$far$面。根据相似三角形法则，对于$y^{\\prime}$可以得到：\n$$\ny^{\\prime} = \\frac{n}{z}y {\\space}{\\space}{\\space}{\\space}{\\space}x^{\\prime} = \\frac{n}{z}x \n$$\n\n为了推导投影矩阵，我们列出其原点和投影点的关系，当被投影点坐标全部乘以$z$的时候，被投影点坐标变化如下：\n$$\n \\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n \\begin{pmatrix}\n nx/z\\\\\n ny/z\\\\\n unknown\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix}\n$$\n\n因此我们想要求的投影矩阵是执行了如下变化：\n$$\nM_{persp{\\to}ortho}^{4\\times4}:\n{\\space}\n\\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix} \n$$\n根据上面的变换过程我们可以将变换矩阵的确定项先写出来：\n$$\nM_{persp{\\to}ortho}^{4\\times4}=\n \\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n ? & ? & ? & ?\\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix} \n$$\n接下来就是如何确定不确定的这行的值了，在透视投影的可视空间中，发生透视变换后有两个特性：\n1. 所有在$near$面上的点，经过透视投影变换后其坐标值是不变的。\n2. 所有在$far$面上的点，经过透视投影变换后其$z$值是不变的。\n\n对于特性1，我们可以假定在near平面上的点$(x,y,n,1)^T$，经过变换之后，其坐标仍然保持不变。将所有坐标乘以$n$，得到：\n$$\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n nx\\\\\n ny\\\\\n n^2\\\\\n n\n\\end{pmatrix}\n$$\n通过上面的变换，我们可以得出一个结论——未知行额前两项必定为0，因为经过变换后的$z$值与$x,y$无关。因此假定最后一行为$(0,0,A,B)$，再计算第三行的乘法：\n$$\n\\begin{pmatrix}\n 0 {\\space}\n 0 {\\space}\n A {\\space}\n B \n\\end{pmatrix}\n\\begin{pmatrix}\n x \\\\\n y \\\\\n n \\\\\n 1 \n\\end{pmatrix}\n=\nn^2\n\\Rightarrow \nAn + B = n^2\n$$\n同理，利用特性二所有在$far$平面上的点的$z$值不会发生变化：\n$$\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f^2\\\\\n f\n\\end{pmatrix}\n\n\\Rightarrow \nAf + B = f^2\n$$\n\n联立两个等式，得到：\n$$\nA = f + n\n$$\n$$\nB = -nf\n$$\n因此变换矩阵$M_{persp{\\to}ortho}^{4\\times4}$的值为：\n$$\nM_{persp{\\to}ortho}^{4\\times4} =   \n\\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n 0 & 0 & f+n & -nf \\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix}  \n$$\n实际上，完成透视变换之后，再进行一次正交投影变换就彻底完成了以上透视投影变换：\n$$\nM_{persp} = M_{ortho}M_{persp{\\to}ortho}\n$$","slug":"ComputerGraphics3","published":1,"updated":"2020-10-03T07:40:20.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckftgqfao00052wqccnkmfykg","content":"<p>视图变换（viewing transform）的主要职责是将3D物体的坐标（我们取标准坐标$(x, y, z)$映射到屏幕的一个个像素点上来。它的过程可以说是比较复杂的，因为在视图变换的过程中很多因素可以决定最后成像的效果。视图变换可以分为四个过程，模型变换（modal transform）、 视角变换（view transform）、投影变换（projection transform）以及视口变换（viewport transformation）。这个过程可以拿拍照片来类比：</p>\n<ol>\n<li>站好位置，摆好姿势（modal transform）</li>\n<li>找好角度，调整相机位置（view transform）</li>\n<li>拍摄照片，将3D场景拍摄到2D的照片（projection transform &amp;&amp; viewport transformation）</li>\n</ol>\n<p>在拍照片的过程中我们模拟了视图变换的过程。首先是模型变换，我们需要将模型从模型坐标变换到世界坐标中来，也就是在拍照过程中让人站好姿势、摆好位置。调整相机位置，也就是调整在世界坐标中从哪个方向去观测。这个过程我们需要确定两个方向，一个方向是观测的朝向，另一个方向就是与观测朝向“向上”的方向，比如说我们朝着$-Z$方向去看，那么“向上”方向就是$Y$方向。当以上过程都完成后，我们需要将3D场景转换到2D屏幕上，就需要通过投影的方式做像素映射。</p>\n<p><img src=\"/images/graphics3/graphics3_transformation.png\" alt=\"\"></p>\n<h2 id=\"相机变换-view-camera-transform\"><a href=\"#相机变换-view-camera-transform\" class=\"headerlink\" title=\"相机变换 view/camera transform\"></a>相机变换 view/camera transform</h2><p>结合在上一篇我们讨论的绕任意轴旋转的变换推导中，我们其实可以很容易使用类似的思路来进行推导相机变换。还记得为什么在相机变换的过程中，为什么除了看向方向（look-at direction）之外表示为$g$，还需要一个“向上”的方向（up direction）表示为$t$，有了着两个方向以及相机的位置$e$。<br>我们在根据坐标系法则就可以建立起一个三位坐标$u,v,w$。定义如下：</p>\n<script type=\"math/tex; mode=display\">\nw =  -\\frac{g}{\\left |\\left | g \\right |   \\right | }</script><script type=\"math/tex; mode=display\">\nu = \\frac{t \\times w }{ \\left |\\left | {t \\times w} \\right |   \\right |  }</script><script type=\"math/tex; mode=display\">\nv = w \\times u</script><p><img src=\"/images/graphics3/graphics3_camera.png\" alt=\"\"><br>摄像机变换就可以看作将$x,y,z$坐标系转换到$u,v,w$坐标系的过程。我们将变换矩阵写作$M_{view}$，令</p>\n<script type=\"math/tex; mode=display\">\nM_{view} = R_{view}T_{view}</script><p>其中$R$是改变相机朝向的的变换矩阵，它的作用是使得$-Z$旋转到看向方向$u$，$Y$旋转到“向上“的方向$v$。$T_{view}$是移动相机位置的矩阵，是一个平移矩阵，可以被表示为：</p>\n<script type=\"math/tex; mode=display\">\nT_{view} =\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}</script><p>旋转的过程在前面的章节有提过，如果需要使用$R$变换矩阵，因此$M$可以被表示为：</p>\n<script type=\"math/tex; mode=display\">\nM_{view} = \n\n\\begin{bmatrix}\nx_u & y_u & z_u & 0\\\\\nx_v & y_v & z_v & 0\\\\\nx_w & y_w & z_w & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}</script><h2 id=\"投影变换-pojection-transform\"><a href=\"#投影变换-pojection-transform\" class=\"headerlink\" title=\"投影变换 pojection transform\"></a>投影变换 pojection transform</h2><p>投影变换的过程主要是将3D的点投影到2D的屏幕上来，根据变换条件的不同，可以将投影区分为正交投影和透视投影。如下图所示展现了两种投影的变换方式和成像结果。<br><img src=\"/images/graphics3/graphics3_banner.png\" alt=\"\"></p>\n<h3 id=\"正交投影-Orthographic-Projection-Transformation\"><a href=\"#正交投影-Orthographic-Projection-Transformation\" class=\"headerlink\" title=\"正交投影 Orthographic Projection Transformation\"></a>正交投影 Orthographic Projection Transformation</h3><p>正交投影很好理解，在正交投影之后图形中所有点的的相对位置都不会发生改变，可以将其看作直接将图形“压扁”，然后放置在某一平面上。<br><img src=\"/images/graphics3/graphic3_orthographic.png\" alt=\"\"><br>在实际渲染过程中，我们总是希望在某个空间区域来渲染图形，而非根据整个视图区域来做渲染。假设渲染发生在一个沿着$Z$轴负方向，底面（bottom）与$XY$平面平行的一个立方体。这时候可以定义左右面（left, right）以及近远面（near, far），以及上下面（top, bottom）用以下代数表示：</p>\n<script type=\"math/tex; mode=display\">\nx = l = left{\\space}plane</script><script type=\"math/tex; mode=display\">\nx = r = right{\\space}plane</script><script type=\"math/tex; mode=display\">\ny = v = bottom{\\space}plane</script><script type=\"math/tex; mode=display\">\ny = t = left{\\space}plane</script><script type=\"math/tex; mode=display\">\nz = n = near{\\space}plane</script><script type=\"math/tex; mode=display\">\nz = f = far{\\space}plane</script><p>简单来说，正交投影的主要原理是将上述区域变换到一个”正则、规范、标准“的立方体$[-1, 1]^3$中来。这个变换过程可以分解为两个变换：</p>\n<ol>\n<li>将渲染盒子平移到以原点为中心的位置，即每个定点到投影平面的距离为 边长/2</li>\n<li>将渲染盒子缩放为立方体$[-1, 1]^3$<br><img src=\"/images/graphics3/graphics3_orthographic_transform.png\" alt=\"\"><br>这个过程可以用变换矩阵表示为：<script type=\"math/tex; mode=display\">\nM_{ortho} = \n\\begin{bmatrix}\n\\frac{2}{r - l} & 0 & 0 & 0\\\\\n0 & \\frac{2}{t - b} & 0 & 0\\\\\n0 & 0 & \\frac{2}{n - f} & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n\\begin{bmatrix}\n1 & 0 & 0 & -\\frac{r+l}{2}\\\\\n0 & 1 & 0 & -\\frac{t+b}{2}\\\\\n0 & 0 & 1 & -\\frac{n+f}{2}\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}</script><h3 id=\"透视投影-Perspective-Projection-Transformation\"><a href=\"#透视投影-Perspective-Projection-Transformation\" class=\"headerlink\" title=\"透视投影 Perspective Projection Transformation\"></a>透视投影 Perspective Projection Transformation</h3>透视投影和正交投影最大的区别在于，透视投影的过程不是“平行的”，投影的线最终会相交。因为透视投影需要实现真实的透视关系，也就是相等大小的物体，处于场景近端他会显示得更大，处于场景远端它会显示得更小。对于任意一点的投影过程可以用下图来表示：</li>\n</ol>\n<p><img src=\"/images/graphics3/graphic3_orthographic_point.png\" alt=\"\"></p>\n<p>对于任意点$[x, y, z]$, 经过透视投影变换后到投影平面上，形成$[x^{\\prime}, y^{\\prime}, z^{\\prime}]$。图中的$z = -n$为投影平面，也就是我们的$near$面，假定$[x, y, z]$所在的与$XY$平面平行的面为$far$面。根据相似三角形法则，对于$y^{\\prime}$可以得到：</p>\n<script type=\"math/tex; mode=display\">\ny^{\\prime} = \\frac{n}{z}y {\\space}{\\space}{\\space}{\\space}{\\space}x^{\\prime} = \\frac{n}{z}x</script><p>为了推导投影矩阵，我们列出其原点和投影点的关系，当被投影点坐标全部乘以$z$的时候，被投影点坐标变化如下：</p>\n<script type=\"math/tex; mode=display\">\n \\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n \\begin{pmatrix}\n nx/z\\\\\n ny/z\\\\\n unknown\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix}</script><p>因此我们想要求的投影矩阵是执行了如下变化：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}:\n{\\space}\n\\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix}</script><p>根据上面的变换过程我们可以将变换矩阵的确定项先写出来：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}=\n \\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n ? & ? & ? & ?\\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix}</script><p>接下来就是如何确定不确定的这行的值了，在透视投影的可视空间中，发生透视变换后有两个特性：</p>\n<ol>\n<li>所有在$near$面上的点，经过透视投影变换后其坐标值是不变的。</li>\n<li>所有在$far$面上的点，经过透视投影变换后其$z$值是不变的。</li>\n</ol>\n<p>对于特性1，我们可以假定在near平面上的点$(x,y,n,1)^T$，经过变换之后，其坐标仍然保持不变。将所有坐标乘以$n$，得到：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n nx\\\\\n ny\\\\\n n^2\\\\\n n\n\\end{pmatrix}</script><p>通过上面的变换，我们可以得出一个结论——未知行额前两项必定为0，因为经过变换后的$z$值与$x,y$无关。因此假定最后一行为$(0,0,A,B)$，再计算第三行的乘法：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{pmatrix}\n 0 {\\space}\n 0 {\\space}\n A {\\space}\n B \n\\end{pmatrix}\n\\begin{pmatrix}\n x \\\\\n y \\\\\n n \\\\\n 1 \n\\end{pmatrix}\n=\nn^2\n\\Rightarrow \nAn + B = n^2</script><p>同理，利用特性二所有在$far$平面上的点的$z$值不会发生变化：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f^2\\\\\n f\n\\end{pmatrix}\n\n\\Rightarrow \nAf + B = f^2</script><p>联立两个等式，得到：</p>\n<script type=\"math/tex; mode=display\">\nA = f + n</script><script type=\"math/tex; mode=display\">\nB = -nf</script><p>因此变换矩阵$M_{persp{\\to}ortho}^{4\\times4}$的值为：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4} =   \n\\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n 0 & 0 & f+n & -nf \\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix}</script><p>实际上，完成透视变换之后，再进行一次正交投影变换就彻底完成了以上透视投影变换：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp} = M_{ortho}M_{persp{\\to}ortho}</script>","site":{"data":{}},"excerpt":"","more":"<p>视图变换（viewing transform）的主要职责是将3D物体的坐标（我们取标准坐标$(x, y, z)$映射到屏幕的一个个像素点上来。它的过程可以说是比较复杂的，因为在视图变换的过程中很多因素可以决定最后成像的效果。视图变换可以分为四个过程，模型变换（modal transform）、 视角变换（view transform）、投影变换（projection transform）以及视口变换（viewport transformation）。这个过程可以拿拍照片来类比：</p>\n<ol>\n<li>站好位置，摆好姿势（modal transform）</li>\n<li>找好角度，调整相机位置（view transform）</li>\n<li>拍摄照片，将3D场景拍摄到2D的照片（projection transform &amp;&amp; viewport transformation）</li>\n</ol>\n<p>在拍照片的过程中我们模拟了视图变换的过程。首先是模型变换，我们需要将模型从模型坐标变换到世界坐标中来，也就是在拍照过程中让人站好姿势、摆好位置。调整相机位置，也就是调整在世界坐标中从哪个方向去观测。这个过程我们需要确定两个方向，一个方向是观测的朝向，另一个方向就是与观测朝向“向上”的方向，比如说我们朝着$-Z$方向去看，那么“向上”方向就是$Y$方向。当以上过程都完成后，我们需要将3D场景转换到2D屏幕上，就需要通过投影的方式做像素映射。</p>\n<p><img src=\"/images/graphics3/graphics3_transformation.png\" alt=\"\"></p>\n<h2 id=\"相机变换-view-camera-transform\"><a href=\"#相机变换-view-camera-transform\" class=\"headerlink\" title=\"相机变换 view/camera transform\"></a>相机变换 view/camera transform</h2><p>结合在上一篇我们讨论的绕任意轴旋转的变换推导中，我们其实可以很容易使用类似的思路来进行推导相机变换。还记得为什么在相机变换的过程中，为什么除了看向方向（look-at direction）之外表示为$g$，还需要一个“向上”的方向（up direction）表示为$t$，有了着两个方向以及相机的位置$e$。<br>我们在根据坐标系法则就可以建立起一个三位坐标$u,v,w$。定义如下：</p>\n<script type=\"math/tex; mode=display\">\nw =  -\\frac{g}{\\left |\\left | g \\right |   \\right | }</script><script type=\"math/tex; mode=display\">\nu = \\frac{t \\times w }{ \\left |\\left | {t \\times w} \\right |   \\right |  }</script><script type=\"math/tex; mode=display\">\nv = w \\times u</script><p><img src=\"/images/graphics3/graphics3_camera.png\" alt=\"\"><br>摄像机变换就可以看作将$x,y,z$坐标系转换到$u,v,w$坐标系的过程。我们将变换矩阵写作$M_{view}$，令</p>\n<script type=\"math/tex; mode=display\">\nM_{view} = R_{view}T_{view}</script><p>其中$R$是改变相机朝向的的变换矩阵，它的作用是使得$-Z$旋转到看向方向$u$，$Y$旋转到“向上“的方向$v$。$T_{view}$是移动相机位置的矩阵，是一个平移矩阵，可以被表示为：</p>\n<script type=\"math/tex; mode=display\">\nT_{view} =\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}</script><p>旋转的过程在前面的章节有提过，如果需要使用$R$变换矩阵，因此$M$可以被表示为：</p>\n<script type=\"math/tex; mode=display\">\nM_{view} = \n\n\\begin{bmatrix}\nx_u & y_u & z_u & 0\\\\\nx_v & y_v & z_v & 0\\\\\nx_w & y_w & z_w & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}</script><h2 id=\"投影变换-pojection-transform\"><a href=\"#投影变换-pojection-transform\" class=\"headerlink\" title=\"投影变换 pojection transform\"></a>投影变换 pojection transform</h2><p>投影变换的过程主要是将3D的点投影到2D的屏幕上来，根据变换条件的不同，可以将投影区分为正交投影和透视投影。如下图所示展现了两种投影的变换方式和成像结果。<br><img src=\"/images/graphics3/graphics3_banner.png\" alt=\"\"></p>\n<h3 id=\"正交投影-Orthographic-Projection-Transformation\"><a href=\"#正交投影-Orthographic-Projection-Transformation\" class=\"headerlink\" title=\"正交投影 Orthographic Projection Transformation\"></a>正交投影 Orthographic Projection Transformation</h3><p>正交投影很好理解，在正交投影之后图形中所有点的的相对位置都不会发生改变，可以将其看作直接将图形“压扁”，然后放置在某一平面上。<br><img src=\"/images/graphics3/graphic3_orthographic.png\" alt=\"\"><br>在实际渲染过程中，我们总是希望在某个空间区域来渲染图形，而非根据整个视图区域来做渲染。假设渲染发生在一个沿着$Z$轴负方向，底面（bottom）与$XY$平面平行的一个立方体。这时候可以定义左右面（left, right）以及近远面（near, far），以及上下面（top, bottom）用以下代数表示：</p>\n<script type=\"math/tex; mode=display\">\nx = l = left{\\space}plane</script><script type=\"math/tex; mode=display\">\nx = r = right{\\space}plane</script><script type=\"math/tex; mode=display\">\ny = v = bottom{\\space}plane</script><script type=\"math/tex; mode=display\">\ny = t = left{\\space}plane</script><script type=\"math/tex; mode=display\">\nz = n = near{\\space}plane</script><script type=\"math/tex; mode=display\">\nz = f = far{\\space}plane</script><p>简单来说，正交投影的主要原理是将上述区域变换到一个”正则、规范、标准“的立方体$[-1, 1]^3$中来。这个变换过程可以分解为两个变换：</p>\n<ol>\n<li>将渲染盒子平移到以原点为中心的位置，即每个定点到投影平面的距离为 边长/2</li>\n<li>将渲染盒子缩放为立方体$[-1, 1]^3$<br><img src=\"/images/graphics3/graphics3_orthographic_transform.png\" alt=\"\"><br>这个过程可以用变换矩阵表示为：<script type=\"math/tex; mode=display\">\nM_{ortho} = \n\\begin{bmatrix}\n\\frac{2}{r - l} & 0 & 0 & 0\\\\\n0 & \\frac{2}{t - b} & 0 & 0\\\\\n0 & 0 & \\frac{2}{n - f} & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n\\begin{bmatrix}\n1 & 0 & 0 & -\\frac{r+l}{2}\\\\\n0 & 1 & 0 & -\\frac{t+b}{2}\\\\\n0 & 0 & 1 & -\\frac{n+f}{2}\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}</script><h3 id=\"透视投影-Perspective-Projection-Transformation\"><a href=\"#透视投影-Perspective-Projection-Transformation\" class=\"headerlink\" title=\"透视投影 Perspective Projection Transformation\"></a>透视投影 Perspective Projection Transformation</h3>透视投影和正交投影最大的区别在于，透视投影的过程不是“平行的”，投影的线最终会相交。因为透视投影需要实现真实的透视关系，也就是相等大小的物体，处于场景近端他会显示得更大，处于场景远端它会显示得更小。对于任意一点的投影过程可以用下图来表示：</li>\n</ol>\n<p><img src=\"/images/graphics3/graphic3_orthographic_point.png\" alt=\"\"></p>\n<p>对于任意点$[x, y, z]$, 经过透视投影变换后到投影平面上，形成$[x^{\\prime}, y^{\\prime}, z^{\\prime}]$。图中的$z = -n$为投影平面，也就是我们的$near$面，假定$[x, y, z]$所在的与$XY$平面平行的面为$far$面。根据相似三角形法则，对于$y^{\\prime}$可以得到：</p>\n<script type=\"math/tex; mode=display\">\ny^{\\prime} = \\frac{n}{z}y {\\space}{\\space}{\\space}{\\space}{\\space}x^{\\prime} = \\frac{n}{z}x</script><p>为了推导投影矩阵，我们列出其原点和投影点的关系，当被投影点坐标全部乘以$z$的时候，被投影点坐标变化如下：</p>\n<script type=\"math/tex; mode=display\">\n \\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n \\begin{pmatrix}\n nx/z\\\\\n ny/z\\\\\n unknown\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix}</script><p>因此我们想要求的投影矩阵是执行了如下变化：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}:\n{\\space}\n\\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix}</script><p>根据上面的变换过程我们可以将变换矩阵的确定项先写出来：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}=\n \\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n ? & ? & ? & ?\\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix}</script><p>接下来就是如何确定不确定的这行的值了，在透视投影的可视空间中，发生透视变换后有两个特性：</p>\n<ol>\n<li>所有在$near$面上的点，经过透视投影变换后其坐标值是不变的。</li>\n<li>所有在$far$面上的点，经过透视投影变换后其$z$值是不变的。</li>\n</ol>\n<p>对于特性1，我们可以假定在near平面上的点$(x,y,n,1)^T$，经过变换之后，其坐标仍然保持不变。将所有坐标乘以$n$，得到：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n nx\\\\\n ny\\\\\n n^2\\\\\n n\n\\end{pmatrix}</script><p>通过上面的变换，我们可以得出一个结论——未知行额前两项必定为0，因为经过变换后的$z$值与$x,y$无关。因此假定最后一行为$(0,0,A,B)$，再计算第三行的乘法：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{pmatrix}\n 0 {\\space}\n 0 {\\space}\n A {\\space}\n B \n\\end{pmatrix}\n\\begin{pmatrix}\n x \\\\\n y \\\\\n n \\\\\n 1 \n\\end{pmatrix}\n=\nn^2\n\\Rightarrow \nAn + B = n^2</script><p>同理，利用特性二所有在$far$平面上的点的$z$值不会发生变化：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f^2\\\\\n f\n\\end{pmatrix}\n\n\\Rightarrow \nAf + B = f^2</script><p>联立两个等式，得到：</p>\n<script type=\"math/tex; mode=display\">\nA = f + n</script><script type=\"math/tex; mode=display\">\nB = -nf</script><p>因此变换矩阵$M_{persp{\\to}ortho}^{4\\times4}$的值为：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4} =   \n\\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n 0 & 0 & f+n & -nf \\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix}</script><p>实际上，完成透视变换之后，再进行一次正交投影变换就彻底完成了以上透视投影变换：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp} = M_{ortho}M_{persp{\\to}ortho}</script>"},{"title":"计算机图形学4 ——  光栅化","index_img":"/images/graphics4/graphics4_banner.png","date":"2020-09-01T13:09:11.000Z","math":true,"_content":"\n> 总体来说，栅格化这个术语可以用于任何将向量图形转换成位图的过程,在通常的应用中，这个术语用来表示在计算机上显示三维形状的流行渲染算法。\n\n> 栅格化目前是生成实时三维计算机图形最流行的算法。实时应用需要立即响应用户输入，并且通常需要至少每秒 24 帧的速率。辐射着色、光线跟踪等其它渲染技术不同，栅格化的速度非常快，但是由于它不是根据光传输的物理规律进行处理的，所以无法正确模拟许多复杂真实光照环境，只能达到足够欺骗人类眼睛的程度。\n\n以上是Wikipedia对于光栅化的解释，大致上来说，光栅化是顶点数据变换为屏幕像素数据的过程。在光栅化中，我们需要考虑如何将位置信息数据转化为像素信息数据，例如如何在屏幕上进行展示一条线、一个圆，一个三角形。如下图所示，在屏幕中实际显示的最小单位是一个像素点。如何在屏幕中绘制像素信息，或使用哪些像素值来表示图形，是光栅化需要考虑的问题。\n\n光栅化的基本过程可以用以下伪代码来表示：\n```\nfor (T in trangels):\n    for (P in pixels):\n        determine if P is inside T\n```\n## 像素（pixels）的表示\n我们使用一个整数坐标点代表一个像素，像素作为光栅化的最小单位，其尺寸是单位大小为1的正方形。其用其中心点$x, y$来表示其位置坐标。如下图所示：\n![](/images/graphics4/graphics4_pixels.png)\n## 直线光栅化表示\n和绘制一个点相比，绘制一条直线就需要我们关注如何通过直线中每个像素点的位置来表示这个像素点。在photoshop中绘制一条直线时，应用自动产生的像素点的位置。通过下图可以看出，在绘制一条水平或者垂直的直线的时候，只需要连续在对应方向进行绘制即可。但是当直线的斜率为$(0, \\infty)$时，表示一条直线就困难很多。此时无法利用像素点直接还原这条直线，只能通过类似表示的方式来表示这条直线。如何绘制直线，演进出很多算法，下面介绍两种直线绘制算法DDA和Bresenham。\n![](/images/graphics4/graphics4_lines.png)\n### DDA(Digital differience analyzer)\nDDA的绘制过程比较简单，绘制像素的位置都由直线的斜率来决定。指定直线的斜率$k$，每个像素点$X, Y$\n1. 如果斜率$\\left | k \\right |  < 1$，则$X = X + 1$, $Y = Y + k$\n2. 如果斜率$\\left | k \\right |  > 1$，则$X = X + 1/k$, $Y = Y + 1$\n以上所有结果都进行四舍五入进行取整表示，DDA的绘制过程可以通过以下代码来进行表示：\n\n``` cpp\n// calculate dx , dy\ndx = X1 - X0;\ndy = Y1 - Y0;\n\n// Depending upon absolute value of dx & dy\n// choose number of steps to put pixel as\nsteps = abs(dx) > abs(dy) ? abs(dx) : abs(dy);\n\n// calculate increment in x & y for each steps\nXinc = dx / (float) steps;\nYinc = dy / (float) steps;\n\n// Put pixel for each step\nX = X0;\nY = Y0;\nfor (int i = 0; i <= steps; i++)\n{\n    putpixel (X, Y, RED);\n    X += Xinc;\n    Y += Yinc;\n}\n```\n\n### Bresenham\nDDA算法按照直线的函数表达式来绘制，但是并不代表它的准确性和效率就高。实际上，在绘制过程中对值取四舍五入的方式不仅浪费性能，而且可能会造成绘制不准。Bresenham算法有效地解决了这些问题，它在绘制过程中，通过对两个备选绘制点的中值进行比较来决定绘制点的位置。\n\n如下图所示，在斜率 $\\left | k \\right |  < 1$ 的情况下，当我们绘制下一个点 $(x_k+1, unknown)$ 时，有两个备选点 $(x_k+1, y_k + 1)$ 以及 $(x_k+1, y_k)$ 。这时候我们只需要找出与直线与 $x = x_k + 1$ 相交的交点距离哪个备选点更近即可。\n![](/images/graphics4/graphics4_bresenham.png)\n观察实际$y$的增长值$y_d$，如果$y_d > 0.5$，则取上面的点，否则取下面的点。实际Bresenham过程也比较简单，但是这里比较涉及到了浮点数$0.5$的计算，性能会退化地和DDA一致。为了避免使用浮点数计算，使用了一种比较巧妙的计算方法。在以下两个条件下做讨论：\n1. 所有的直线的斜率$k\\in(0,1)$\n2. $x_1 < x_2$ 且 $y_1 < y_2$\n\n此时，每次绘制像素时：\n1. $X$方向都会向右移动一格\n2. 为了得到$Y$方向的增长值，先计算 $\\Delta{y} = (y_2 - y_1)$ $\\Delta{x} =(x_2 - x_1)$，根据斜率的性质，可以得出 $\\Delta{y} = k\\Delta{x}$ \n3. 当 $y$ 增长1个单位时，$x$ 需要增长$1/k$个单位\n4. 我们规定 $2\\Delta{y} - \\Delta{x}$ 为初始判定值$d$，每次绘制时$d += 2\\Delta{y}$\n5. 当 $d >= 0$的时候，说明$Y$轴方向的增长量超过了1，令$y + 1$，然后将$d - 2\\Delta{x}$。\n\n以下是代码表示:\n\n``` cpp\nvoid bresenham(int x1, int y1, int x2, int y2) { \n    int m_new = 2 * (y2 - y1); \n    int slope_error_new = m_new - (x2 - x1); \n    for (int x = x1, y = y1; x <= x2; x++) \n    { \n        cout << \"(\" << x << \",\" << y << \")\\n\"; \n\n        // Add slope to increment angle formed \n        slope_error_new += m_new; \n\n        // Slope error reached limit, time to \n        // increment y and update slope error. \n        if (slope_error_new >= 0) \n        { \n            y++; \n            slope_error_new  -= 2 * (x2 - x1); \n        } \n    } \n}\n```\n## 图形光栅化表示\n下面以三角形为例，介绍图形的光栅化过程。在图形光栅化的过程中，我们需要逐行扫描每个像素，判断像素是否处于图形之中，如果处于图形之中就将其采样。\n\n![](/images/graphics4/graphics4_sample.png)\n\n如何判断点$Q$是否在三角形内呢？对于三角形而言，确定三角形的形状和位置需要确定三角形的三个定点$P_1$、$P_2$、$P_3$。利用向量叉乘的特性，分别计算$\\overrightarrow{P_1P_2} \\times \\overrightarrow{P_1Q}$和$\\overrightarrow{P_2P_3} \\times \\overrightarrow{P_2Q}$以及$\\overrightarrow{P_3P_1} \\times \\overrightarrow{P_3Q}$的值是否是相同正负号的。如果是就说明点$Q$在三角形$P_1P_2P_3$内。\n![](/images/graphics4/graphics4_inside.png)\n\n逐行扫描对于光栅化过程来说有点过于耗费性能，因为很多情况下区域内只有很小的宇哥图形。如果逐行去扫描不需要着色的像素，会造成严重的性能浪费。因此可以使用一个盒子边界来包裹需要扫描的像素区域，只在这个区域内进行光栅化的过程，大幅提升光栅化的性能。这个特性实际上适用于很多图形学的场景，比如碰撞检测、抗锯齿。\n![](/images/graphics4/graphics4_bound_box.png)","source":"_posts/ComputerGraphics4.md","raw":"---\ntitle: 计算机图形学4 ——  光栅化\ntags: [计算机图形学, 光栅化, bresenham]\ncategories: [GAMES101]\nindex_img: /images/graphics4/graphics4_banner.png\ndate: 2020-09-01 21:09:11\nmath: true\n---\n\n> 总体来说，栅格化这个术语可以用于任何将向量图形转换成位图的过程,在通常的应用中，这个术语用来表示在计算机上显示三维形状的流行渲染算法。\n\n> 栅格化目前是生成实时三维计算机图形最流行的算法。实时应用需要立即响应用户输入，并且通常需要至少每秒 24 帧的速率。辐射着色、光线跟踪等其它渲染技术不同，栅格化的速度非常快，但是由于它不是根据光传输的物理规律进行处理的，所以无法正确模拟许多复杂真实光照环境，只能达到足够欺骗人类眼睛的程度。\n\n以上是Wikipedia对于光栅化的解释，大致上来说，光栅化是顶点数据变换为屏幕像素数据的过程。在光栅化中，我们需要考虑如何将位置信息数据转化为像素信息数据，例如如何在屏幕上进行展示一条线、一个圆，一个三角形。如下图所示，在屏幕中实际显示的最小单位是一个像素点。如何在屏幕中绘制像素信息，或使用哪些像素值来表示图形，是光栅化需要考虑的问题。\n\n光栅化的基本过程可以用以下伪代码来表示：\n```\nfor (T in trangels):\n    for (P in pixels):\n        determine if P is inside T\n```\n## 像素（pixels）的表示\n我们使用一个整数坐标点代表一个像素，像素作为光栅化的最小单位，其尺寸是单位大小为1的正方形。其用其中心点$x, y$来表示其位置坐标。如下图所示：\n![](/images/graphics4/graphics4_pixels.png)\n## 直线光栅化表示\n和绘制一个点相比，绘制一条直线就需要我们关注如何通过直线中每个像素点的位置来表示这个像素点。在photoshop中绘制一条直线时，应用自动产生的像素点的位置。通过下图可以看出，在绘制一条水平或者垂直的直线的时候，只需要连续在对应方向进行绘制即可。但是当直线的斜率为$(0, \\infty)$时，表示一条直线就困难很多。此时无法利用像素点直接还原这条直线，只能通过类似表示的方式来表示这条直线。如何绘制直线，演进出很多算法，下面介绍两种直线绘制算法DDA和Bresenham。\n![](/images/graphics4/graphics4_lines.png)\n### DDA(Digital differience analyzer)\nDDA的绘制过程比较简单，绘制像素的位置都由直线的斜率来决定。指定直线的斜率$k$，每个像素点$X, Y$\n1. 如果斜率$\\left | k \\right |  < 1$，则$X = X + 1$, $Y = Y + k$\n2. 如果斜率$\\left | k \\right |  > 1$，则$X = X + 1/k$, $Y = Y + 1$\n以上所有结果都进行四舍五入进行取整表示，DDA的绘制过程可以通过以下代码来进行表示：\n\n``` cpp\n// calculate dx , dy\ndx = X1 - X0;\ndy = Y1 - Y0;\n\n// Depending upon absolute value of dx & dy\n// choose number of steps to put pixel as\nsteps = abs(dx) > abs(dy) ? abs(dx) : abs(dy);\n\n// calculate increment in x & y for each steps\nXinc = dx / (float) steps;\nYinc = dy / (float) steps;\n\n// Put pixel for each step\nX = X0;\nY = Y0;\nfor (int i = 0; i <= steps; i++)\n{\n    putpixel (X, Y, RED);\n    X += Xinc;\n    Y += Yinc;\n}\n```\n\n### Bresenham\nDDA算法按照直线的函数表达式来绘制，但是并不代表它的准确性和效率就高。实际上，在绘制过程中对值取四舍五入的方式不仅浪费性能，而且可能会造成绘制不准。Bresenham算法有效地解决了这些问题，它在绘制过程中，通过对两个备选绘制点的中值进行比较来决定绘制点的位置。\n\n如下图所示，在斜率 $\\left | k \\right |  < 1$ 的情况下，当我们绘制下一个点 $(x_k+1, unknown)$ 时，有两个备选点 $(x_k+1, y_k + 1)$ 以及 $(x_k+1, y_k)$ 。这时候我们只需要找出与直线与 $x = x_k + 1$ 相交的交点距离哪个备选点更近即可。\n![](/images/graphics4/graphics4_bresenham.png)\n观察实际$y$的增长值$y_d$，如果$y_d > 0.5$，则取上面的点，否则取下面的点。实际Bresenham过程也比较简单，但是这里比较涉及到了浮点数$0.5$的计算，性能会退化地和DDA一致。为了避免使用浮点数计算，使用了一种比较巧妙的计算方法。在以下两个条件下做讨论：\n1. 所有的直线的斜率$k\\in(0,1)$\n2. $x_1 < x_2$ 且 $y_1 < y_2$\n\n此时，每次绘制像素时：\n1. $X$方向都会向右移动一格\n2. 为了得到$Y$方向的增长值，先计算 $\\Delta{y} = (y_2 - y_1)$ $\\Delta{x} =(x_2 - x_1)$，根据斜率的性质，可以得出 $\\Delta{y} = k\\Delta{x}$ \n3. 当 $y$ 增长1个单位时，$x$ 需要增长$1/k$个单位\n4. 我们规定 $2\\Delta{y} - \\Delta{x}$ 为初始判定值$d$，每次绘制时$d += 2\\Delta{y}$\n5. 当 $d >= 0$的时候，说明$Y$轴方向的增长量超过了1，令$y + 1$，然后将$d - 2\\Delta{x}$。\n\n以下是代码表示:\n\n``` cpp\nvoid bresenham(int x1, int y1, int x2, int y2) { \n    int m_new = 2 * (y2 - y1); \n    int slope_error_new = m_new - (x2 - x1); \n    for (int x = x1, y = y1; x <= x2; x++) \n    { \n        cout << \"(\" << x << \",\" << y << \")\\n\"; \n\n        // Add slope to increment angle formed \n        slope_error_new += m_new; \n\n        // Slope error reached limit, time to \n        // increment y and update slope error. \n        if (slope_error_new >= 0) \n        { \n            y++; \n            slope_error_new  -= 2 * (x2 - x1); \n        } \n    } \n}\n```\n## 图形光栅化表示\n下面以三角形为例，介绍图形的光栅化过程。在图形光栅化的过程中，我们需要逐行扫描每个像素，判断像素是否处于图形之中，如果处于图形之中就将其采样。\n\n![](/images/graphics4/graphics4_sample.png)\n\n如何判断点$Q$是否在三角形内呢？对于三角形而言，确定三角形的形状和位置需要确定三角形的三个定点$P_1$、$P_2$、$P_3$。利用向量叉乘的特性，分别计算$\\overrightarrow{P_1P_2} \\times \\overrightarrow{P_1Q}$和$\\overrightarrow{P_2P_3} \\times \\overrightarrow{P_2Q}$以及$\\overrightarrow{P_3P_1} \\times \\overrightarrow{P_3Q}$的值是否是相同正负号的。如果是就说明点$Q$在三角形$P_1P_2P_3$内。\n![](/images/graphics4/graphics4_inside.png)\n\n逐行扫描对于光栅化过程来说有点过于耗费性能，因为很多情况下区域内只有很小的宇哥图形。如果逐行去扫描不需要着色的像素，会造成严重的性能浪费。因此可以使用一个盒子边界来包裹需要扫描的像素区域，只在这个区域内进行光栅化的过程，大幅提升光栅化的性能。这个特性实际上适用于很多图形学的场景，比如碰撞检测、抗锯齿。\n![](/images/graphics4/graphics4_bound_box.png)","slug":"ComputerGraphics4","published":1,"updated":"2020-10-03T07:40:21.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckftgqfap00062wqcdu6h53cz","content":"<blockquote>\n<p>总体来说，栅格化这个术语可以用于任何将向量图形转换成位图的过程,在通常的应用中，这个术语用来表示在计算机上显示三维形状的流行渲染算法。</p>\n<p>栅格化目前是生成实时三维计算机图形最流行的算法。实时应用需要立即响应用户输入，并且通常需要至少每秒 24 帧的速率。辐射着色、光线跟踪等其它渲染技术不同，栅格化的速度非常快，但是由于它不是根据光传输的物理规律进行处理的，所以无法正确模拟许多复杂真实光照环境，只能达到足够欺骗人类眼睛的程度。</p>\n</blockquote>\n<p>以上是Wikipedia对于光栅化的解释，大致上来说，光栅化是顶点数据变换为屏幕像素数据的过程。在光栅化中，我们需要考虑如何将位置信息数据转化为像素信息数据，例如如何在屏幕上进行展示一条线、一个圆，一个三角形。如下图所示，在屏幕中实际显示的最小单位是一个像素点。如何在屏幕中绘制像素信息，或使用哪些像素值来表示图形，是光栅化需要考虑的问题。</p>\n<p>光栅化的基本过程可以用以下伪代码来表示：<br><pre><code class=\"hljs properties\"><span class=\"hljs-attr\">for</span> <span class=\"hljs-string\">(T in trangels):</span>\n    <span class=\"hljs-attr\">for</span> <span class=\"hljs-string\">(P in pixels):</span>\n        <span class=\"hljs-attr\">determine</span> <span class=\"hljs-string\">if P is inside T</span></code></pre></p>\n<h2 id=\"像素（pixels）的表示\"><a href=\"#像素（pixels）的表示\" class=\"headerlink\" title=\"像素（pixels）的表示\"></a>像素（pixels）的表示</h2><p>我们使用一个整数坐标点代表一个像素，像素作为光栅化的最小单位，其尺寸是单位大小为1的正方形。其用其中心点$x, y$来表示其位置坐标。如下图所示：<br><img src=\"/images/graphics4/graphics4_pixels.png\" alt=\"\"></p>\n<h2 id=\"直线光栅化表示\"><a href=\"#直线光栅化表示\" class=\"headerlink\" title=\"直线光栅化表示\"></a>直线光栅化表示</h2><p>和绘制一个点相比，绘制一条直线就需要我们关注如何通过直线中每个像素点的位置来表示这个像素点。在photoshop中绘制一条直线时，应用自动产生的像素点的位置。通过下图可以看出，在绘制一条水平或者垂直的直线的时候，只需要连续在对应方向进行绘制即可。但是当直线的斜率为$(0, \\infty)$时，表示一条直线就困难很多。此时无法利用像素点直接还原这条直线，只能通过类似表示的方式来表示这条直线。如何绘制直线，演进出很多算法，下面介绍两种直线绘制算法DDA和Bresenham。<br><img src=\"/images/graphics4/graphics4_lines.png\" alt=\"\"></p>\n<h3 id=\"DDA-Digital-differience-analyzer\"><a href=\"#DDA-Digital-differience-analyzer\" class=\"headerlink\" title=\"DDA(Digital differience analyzer)\"></a>DDA(Digital differience analyzer)</h3><p>DDA的绘制过程比较简单，绘制像素的位置都由直线的斜率来决定。指定直线的斜率$k$，每个像素点$X, Y$</p>\n<ol>\n<li>如果斜率$\\left | k \\right |  &lt; 1$，则$X = X + 1$, $Y = Y + k$</li>\n<li>如果斜率$\\left | k \\right |  &gt; 1$，则$X = X + 1/k$, $Y = Y + 1$<br>以上所有结果都进行四舍五入进行取整表示，DDA的绘制过程可以通过以下代码来进行表示：</li>\n</ol>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// calculate dx , dy</span>\ndx = X1 - X0;\ndy = Y1 - Y0;\n\n<span class=\"hljs-comment\">// Depending upon absolute value of dx &amp; dy</span>\n<span class=\"hljs-comment\">// choose number of steps to put pixel as</span>\nsteps = <span class=\"hljs-built_in\">abs</span>(dx) &gt; <span class=\"hljs-built_in\">abs</span>(dy) ? <span class=\"hljs-built_in\">abs</span>(dx) : <span class=\"hljs-built_in\">abs</span>(dy);\n\n<span class=\"hljs-comment\">// calculate increment in x &amp; y for each steps</span>\nXinc = dx / (<span class=\"hljs-keyword\">float</span>) steps;\nYinc = dy / (<span class=\"hljs-keyword\">float</span>) steps;\n\n<span class=\"hljs-comment\">// Put pixel for each step</span>\nX = X0;\nY = Y0;\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= steps; i++)\n&#123;\n    putpixel (X, Y, RED);\n    X += Xinc;\n    Y += Yinc;\n&#125;</code></pre>\n<h3 id=\"Bresenham\"><a href=\"#Bresenham\" class=\"headerlink\" title=\"Bresenham\"></a>Bresenham</h3><p>DDA算法按照直线的函数表达式来绘制，但是并不代表它的准确性和效率就高。实际上，在绘制过程中对值取四舍五入的方式不仅浪费性能，而且可能会造成绘制不准。Bresenham算法有效地解决了这些问题，它在绘制过程中，通过对两个备选绘制点的中值进行比较来决定绘制点的位置。</p>\n<p>如下图所示，在斜率 $\\left | k \\right |  &lt; 1$ 的情况下，当我们绘制下一个点 $(x_k+1, unknown)$ 时，有两个备选点 $(x_k+1, y_k + 1)$ 以及 $(x_k+1, y_k)$ 。这时候我们只需要找出与直线与 $x = x_k + 1$ 相交的交点距离哪个备选点更近即可。<br><img src=\"/images/graphics4/graphics4_bresenham.png\" alt=\"\"><br>观察实际$y$的增长值$y_d$，如果$y_d &gt; 0.5$，则取上面的点，否则取下面的点。实际Bresenham过程也比较简单，但是这里比较涉及到了浮点数$0.5$的计算，性能会退化地和DDA一致。为了避免使用浮点数计算，使用了一种比较巧妙的计算方法。在以下两个条件下做讨论：</p>\n<ol>\n<li>所有的直线的斜率$k\\in(0,1)$</li>\n<li>$x_1 &lt; x_2$ 且 $y_1 &lt; y_2$</li>\n</ol>\n<p>此时，每次绘制像素时：</p>\n<ol>\n<li>$X$方向都会向右移动一格</li>\n<li>为了得到$Y$方向的增长值，先计算 $\\Delta{y} = (y_2 - y_1)$ $\\Delta{x} =(x_2 - x_1)$，根据斜率的性质，可以得出 $\\Delta{y} = k\\Delta{x}$ </li>\n<li>当 $y$ 增长1个单位时，$x$ 需要增长$1/k$个单位</li>\n<li>我们规定 $2\\Delta{y} - \\Delta{x}$ 为初始判定值$d$，每次绘制时$d += 2\\Delta{y}$</li>\n<li>当 $d &gt;= 0$的时候，说明$Y$轴方向的增长量超过了1，令$y + 1$，然后将$d - 2\\Delta{x}$。</li>\n</ol>\n<p>以下是代码表示:</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bresenham</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x1, <span class=\"hljs-keyword\">int</span> y1, <span class=\"hljs-keyword\">int</span> x2, <span class=\"hljs-keyword\">int</span> y2)</span> </span>&#123; \n    <span class=\"hljs-keyword\">int</span> m_new = <span class=\"hljs-number\">2</span> * (y2 - y1); \n    <span class=\"hljs-keyword\">int</span> slope_error_new = m_new - (x2 - x1); \n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> x = x1, y = y1; x &lt;= x2; x++) \n    &#123; \n        <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class=\"hljs-string\">&quot;)\\n&quot;</span>; \n\n        <span class=\"hljs-comment\">// Add slope to increment angle formed </span>\n        slope_error_new += m_new; \n\n        <span class=\"hljs-comment\">// Slope error reached limit, time to </span>\n        <span class=\"hljs-comment\">// increment y and update slope error. </span>\n        <span class=\"hljs-keyword\">if</span> (slope_error_new &gt;= <span class=\"hljs-number\">0</span>) \n        &#123; \n            y++; \n            slope_error_new  -= <span class=\"hljs-number\">2</span> * (x2 - x1); \n        &#125; \n    &#125; \n&#125;</code></pre>\n<h2 id=\"图形光栅化表示\"><a href=\"#图形光栅化表示\" class=\"headerlink\" title=\"图形光栅化表示\"></a>图形光栅化表示</h2><p>下面以三角形为例，介绍图形的光栅化过程。在图形光栅化的过程中，我们需要逐行扫描每个像素，判断像素是否处于图形之中，如果处于图形之中就将其采样。</p>\n<p><img src=\"/images/graphics4/graphics4_sample.png\" alt=\"\"></p>\n<p>如何判断点$Q$是否在三角形内呢？对于三角形而言，确定三角形的形状和位置需要确定三角形的三个定点$P_1$、$P_2$、$P_3$。利用向量叉乘的特性，分别计算$\\overrightarrow{P_1P_2} \\times \\overrightarrow{P_1Q}$和$\\overrightarrow{P_2P_3} \\times \\overrightarrow{P_2Q}$以及$\\overrightarrow{P_3P_1} \\times \\overrightarrow{P_3Q}$的值是否是相同正负号的。如果是就说明点$Q$在三角形$P_1P_2P_3$内。<br><img src=\"/images/graphics4/graphics4_inside.png\" alt=\"\"></p>\n<p>逐行扫描对于光栅化过程来说有点过于耗费性能，因为很多情况下区域内只有很小的宇哥图形。如果逐行去扫描不需要着色的像素，会造成严重的性能浪费。因此可以使用一个盒子边界来包裹需要扫描的像素区域，只在这个区域内进行光栅化的过程，大幅提升光栅化的性能。这个特性实际上适用于很多图形学的场景，比如碰撞检测、抗锯齿。<br><img src=\"/images/graphics4/graphics4_bound_box.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>总体来说，栅格化这个术语可以用于任何将向量图形转换成位图的过程,在通常的应用中，这个术语用来表示在计算机上显示三维形状的流行渲染算法。</p>\n<p>栅格化目前是生成实时三维计算机图形最流行的算法。实时应用需要立即响应用户输入，并且通常需要至少每秒 24 帧的速率。辐射着色、光线跟踪等其它渲染技术不同，栅格化的速度非常快，但是由于它不是根据光传输的物理规律进行处理的，所以无法正确模拟许多复杂真实光照环境，只能达到足够欺骗人类眼睛的程度。</p>\n</blockquote>\n<p>以上是Wikipedia对于光栅化的解释，大致上来说，光栅化是顶点数据变换为屏幕像素数据的过程。在光栅化中，我们需要考虑如何将位置信息数据转化为像素信息数据，例如如何在屏幕上进行展示一条线、一个圆，一个三角形。如下图所示，在屏幕中实际显示的最小单位是一个像素点。如何在屏幕中绘制像素信息，或使用哪些像素值来表示图形，是光栅化需要考虑的问题。</p>\n<p>光栅化的基本过程可以用以下伪代码来表示：<br><pre><code class=\"hljs properties\"><span class=\"hljs-attr\">for</span> <span class=\"hljs-string\">(T in trangels):</span>\n    <span class=\"hljs-attr\">for</span> <span class=\"hljs-string\">(P in pixels):</span>\n        <span class=\"hljs-attr\">determine</span> <span class=\"hljs-string\">if P is inside T</span></code></pre></p>\n<h2 id=\"像素（pixels）的表示\"><a href=\"#像素（pixels）的表示\" class=\"headerlink\" title=\"像素（pixels）的表示\"></a>像素（pixels）的表示</h2><p>我们使用一个整数坐标点代表一个像素，像素作为光栅化的最小单位，其尺寸是单位大小为1的正方形。其用其中心点$x, y$来表示其位置坐标。如下图所示：<br><img src=\"/images/graphics4/graphics4_pixels.png\" alt=\"\"></p>\n<h2 id=\"直线光栅化表示\"><a href=\"#直线光栅化表示\" class=\"headerlink\" title=\"直线光栅化表示\"></a>直线光栅化表示</h2><p>和绘制一个点相比，绘制一条直线就需要我们关注如何通过直线中每个像素点的位置来表示这个像素点。在photoshop中绘制一条直线时，应用自动产生的像素点的位置。通过下图可以看出，在绘制一条水平或者垂直的直线的时候，只需要连续在对应方向进行绘制即可。但是当直线的斜率为$(0, \\infty)$时，表示一条直线就困难很多。此时无法利用像素点直接还原这条直线，只能通过类似表示的方式来表示这条直线。如何绘制直线，演进出很多算法，下面介绍两种直线绘制算法DDA和Bresenham。<br><img src=\"/images/graphics4/graphics4_lines.png\" alt=\"\"></p>\n<h3 id=\"DDA-Digital-differience-analyzer\"><a href=\"#DDA-Digital-differience-analyzer\" class=\"headerlink\" title=\"DDA(Digital differience analyzer)\"></a>DDA(Digital differience analyzer)</h3><p>DDA的绘制过程比较简单，绘制像素的位置都由直线的斜率来决定。指定直线的斜率$k$，每个像素点$X, Y$</p>\n<ol>\n<li>如果斜率$\\left | k \\right |  &lt; 1$，则$X = X + 1$, $Y = Y + k$</li>\n<li>如果斜率$\\left | k \\right |  &gt; 1$，则$X = X + 1/k$, $Y = Y + 1$<br>以上所有结果都进行四舍五入进行取整表示，DDA的绘制过程可以通过以下代码来进行表示：</li>\n</ol>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// calculate dx , dy</span>\ndx = X1 - X0;\ndy = Y1 - Y0;\n\n<span class=\"hljs-comment\">// Depending upon absolute value of dx &amp; dy</span>\n<span class=\"hljs-comment\">// choose number of steps to put pixel as</span>\nsteps = <span class=\"hljs-built_in\">abs</span>(dx) &gt; <span class=\"hljs-built_in\">abs</span>(dy) ? <span class=\"hljs-built_in\">abs</span>(dx) : <span class=\"hljs-built_in\">abs</span>(dy);\n\n<span class=\"hljs-comment\">// calculate increment in x &amp; y for each steps</span>\nXinc = dx / (<span class=\"hljs-keyword\">float</span>) steps;\nYinc = dy / (<span class=\"hljs-keyword\">float</span>) steps;\n\n<span class=\"hljs-comment\">// Put pixel for each step</span>\nX = X0;\nY = Y0;\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= steps; i++)\n&#123;\n    putpixel (X, Y, RED);\n    X += Xinc;\n    Y += Yinc;\n&#125;</code></pre>\n<h3 id=\"Bresenham\"><a href=\"#Bresenham\" class=\"headerlink\" title=\"Bresenham\"></a>Bresenham</h3><p>DDA算法按照直线的函数表达式来绘制，但是并不代表它的准确性和效率就高。实际上，在绘制过程中对值取四舍五入的方式不仅浪费性能，而且可能会造成绘制不准。Bresenham算法有效地解决了这些问题，它在绘制过程中，通过对两个备选绘制点的中值进行比较来决定绘制点的位置。</p>\n<p>如下图所示，在斜率 $\\left | k \\right |  &lt; 1$ 的情况下，当我们绘制下一个点 $(x_k+1, unknown)$ 时，有两个备选点 $(x_k+1, y_k + 1)$ 以及 $(x_k+1, y_k)$ 。这时候我们只需要找出与直线与 $x = x_k + 1$ 相交的交点距离哪个备选点更近即可。<br><img src=\"/images/graphics4/graphics4_bresenham.png\" alt=\"\"><br>观察实际$y$的增长值$y_d$，如果$y_d &gt; 0.5$，则取上面的点，否则取下面的点。实际Bresenham过程也比较简单，但是这里比较涉及到了浮点数$0.5$的计算，性能会退化地和DDA一致。为了避免使用浮点数计算，使用了一种比较巧妙的计算方法。在以下两个条件下做讨论：</p>\n<ol>\n<li>所有的直线的斜率$k\\in(0,1)$</li>\n<li>$x_1 &lt; x_2$ 且 $y_1 &lt; y_2$</li>\n</ol>\n<p>此时，每次绘制像素时：</p>\n<ol>\n<li>$X$方向都会向右移动一格</li>\n<li>为了得到$Y$方向的增长值，先计算 $\\Delta{y} = (y_2 - y_1)$ $\\Delta{x} =(x_2 - x_1)$，根据斜率的性质，可以得出 $\\Delta{y} = k\\Delta{x}$ </li>\n<li>当 $y$ 增长1个单位时，$x$ 需要增长$1/k$个单位</li>\n<li>我们规定 $2\\Delta{y} - \\Delta{x}$ 为初始判定值$d$，每次绘制时$d += 2\\Delta{y}$</li>\n<li>当 $d &gt;= 0$的时候，说明$Y$轴方向的增长量超过了1，令$y + 1$，然后将$d - 2\\Delta{x}$。</li>\n</ol>\n<p>以下是代码表示:</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bresenham</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x1, <span class=\"hljs-keyword\">int</span> y1, <span class=\"hljs-keyword\">int</span> x2, <span class=\"hljs-keyword\">int</span> y2)</span> </span>&#123; \n    <span class=\"hljs-keyword\">int</span> m_new = <span class=\"hljs-number\">2</span> * (y2 - y1); \n    <span class=\"hljs-keyword\">int</span> slope_error_new = m_new - (x2 - x1); \n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> x = x1, y = y1; x &lt;= x2; x++) \n    &#123; \n        <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class=\"hljs-string\">&quot;)\\n&quot;</span>; \n\n        <span class=\"hljs-comment\">// Add slope to increment angle formed </span>\n        slope_error_new += m_new; \n\n        <span class=\"hljs-comment\">// Slope error reached limit, time to </span>\n        <span class=\"hljs-comment\">// increment y and update slope error. </span>\n        <span class=\"hljs-keyword\">if</span> (slope_error_new &gt;= <span class=\"hljs-number\">0</span>) \n        &#123; \n            y++; \n            slope_error_new  -= <span class=\"hljs-number\">2</span> * (x2 - x1); \n        &#125; \n    &#125; \n&#125;</code></pre>\n<h2 id=\"图形光栅化表示\"><a href=\"#图形光栅化表示\" class=\"headerlink\" title=\"图形光栅化表示\"></a>图形光栅化表示</h2><p>下面以三角形为例，介绍图形的光栅化过程。在图形光栅化的过程中，我们需要逐行扫描每个像素，判断像素是否处于图形之中，如果处于图形之中就将其采样。</p>\n<p><img src=\"/images/graphics4/graphics4_sample.png\" alt=\"\"></p>\n<p>如何判断点$Q$是否在三角形内呢？对于三角形而言，确定三角形的形状和位置需要确定三角形的三个定点$P_1$、$P_2$、$P_3$。利用向量叉乘的特性，分别计算$\\overrightarrow{P_1P_2} \\times \\overrightarrow{P_1Q}$和$\\overrightarrow{P_2P_3} \\times \\overrightarrow{P_2Q}$以及$\\overrightarrow{P_3P_1} \\times \\overrightarrow{P_3Q}$的值是否是相同正负号的。如果是就说明点$Q$在三角形$P_1P_2P_3$内。<br><img src=\"/images/graphics4/graphics4_inside.png\" alt=\"\"></p>\n<p>逐行扫描对于光栅化过程来说有点过于耗费性能，因为很多情况下区域内只有很小的宇哥图形。如果逐行去扫描不需要着色的像素，会造成严重的性能浪费。因此可以使用一个盒子边界来包裹需要扫描的像素区域，只在这个区域内进行光栅化的过程，大幅提升光栅化的性能。这个特性实际上适用于很多图形学的场景，比如碰撞检测、抗锯齿。<br><img src=\"/images/graphics4/graphics4_bound_box.png\" alt=\"\"></p>\n"},{"title":"计算机图形学5 —— 反走样","index_img":"/images/graphics5/graphics5_banner.jpg","date":"2020-09-13T09:09:11.000Z","math":true,"_content":"\n## 走样\n上一节介绍图形的光栅化的过程，经过图形光栅化过程后，可以得到一个像素集合，它将表示我们想要光栅化的图形，这些点被称为采样信号（Sampled Signal）\n![](/images/graphics5/graphics5_sample.png)\n上图表示了三角形光栅化的过程，可以看到最后形成的采样信号与原信号差距还是比较大的，这种现象就是我们所说的走样(Aliasing)。它对于实际的图形成像的影响非常大，出现走样现象的图形，会在边界处出现各种情况的锯齿，这些锯齿很影响实际的成像体验。\n\n走样现象实际上是无法完全避免的，即使分辨率更高的分辨率，更精细的模型，更高的渲染渲染性能也于事无补。因为产生走样现象的本质是由于像素本身是离散型的，我们需要有限的像素点来表示无限精细的线，走样是数字化的必然产物。比如在下图中，相当精细的画面实际上在放大之后观察像素也存在着走样的现象。我们能够做的，仅仅是利用各种技术去减轻这种现象。\n![](/images/graphics5/graphics5_aliasing.png)\n\n## 走样在信号上的解释\n图形的光栅化过程，实际上是可以通过信号采样和重建过程来表示的。场景中的几何物体投射到屏幕上的过程，实际就是对虚拟场景的采样和重建的过程，所以也可以把图像当作信号来分析。由于存储空间和显示设备分辨率的限制，图像的采样过程也是有损的。\n![](/images/graphics5/graphics5_reconstructed.png)\n\n从频域的角度来看，实际上成样过程实际上也是通过离散的采样点来模拟原信号的变换过程。对于低频信号而言，不需要太多的采样点就可以很容易模拟出原信号的形态，因为原信号变化波动很慢。但是对于高频信号而言，很容易出现采样点无法还原原信号的情况，一旦采样点越过了多次频率变化，就很难还原原有的信号。频率越高，通过采样点能还原原信号的概率就越低。比如下图，蓝色部分是原信号，由于采样点不足，通过采样点还原信号时还原的信号频率远低于原信号。\n\n![](/images/graphics5/graphics5_frequency.png)\n\n因此走样的根因和采样过程有关系，最常见的问题就在于采样不足。信号变换太快（高频信号），但是采样的速度跟不上。从时域的角度去看，当采样不足时，就会出现模拟出的信号与信号源有一定的差距，就造成了走样现象。\n\n### Jaggies（锯齿）\n锯齿是在空间中采样的走样现象，造成这种现象的根本原因是因为在空间采样中过程，信号频率变化太快导致的。在图形的边缘型号有带有颜色信息的信号变为无颜色信息的型号，这个过程变化过于剧烈。在采样的过程中如果采样不足，就会造成边缘部分出现无法还原图形的真实形状，就出现了锯齿。比如下图在边缘部分出现严重的锯齿现象。\n![](/images/graphics5/graphics5_jaggies.png)\n### Moiré Patterns\nMoiré Patterns 也是因为采样不足导致的，在采样过程中由于采样频率过低，从而导致信号在某些区域内出现缺失。比如说在采样的过程中，跳过了奇数行像素或者偶数行像素的信号。就会出现严重的 Moiré Patterns 现象。\n![](/images/graphics5/graphics5_Moiré.jpg)\n\n## 反走样及其原理\n\n### SSAA\n反走样的最直接也最有效的的原理就是增大采样频率，使用尽量多的采样点来还原原始的信号形态。这就是SSAA（Super Sampling Anti-aliasing）的原理。它的原理正如字面意思，将一个像素点分解为多个模拟的像素点，通过这种细分来进行着色（shading）计算，最后在对模拟像素点取平均值，最终的到实际物理像素点的颜色。\n\n以每个像素点分解为4个模拟像素点为例，对原始的像素点作出分解。正如上面的介绍所说，如果模拟像素点位于三角形内，否则不进行着色，所有模拟像素点着色完成之后，则将其计算颜色的平均值。\n![](/images/graphics5/graphics5_SSAA.jpg)\n\n最后通过SSAA得到的像素点如右图所示，看起来依旧是存在锯齿的，但是在实际成像过程中，边缘的部分颜色会浅一些，这样锯齿的效果也不会特别明显，能够更还原几何形体的真实形态。\n\n### MSAA\nMSAA（Multi-Sampling Anti-aliasing）是对SSAA的一个改进。SSAA虽然非常直接有效，但是其消耗的性能也是极大的。拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。\n\nMSAA（Multi-Sampling AA）则很聪明的只是在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次。例如下图是4xMSAA，三角形只覆盖了4个coverage sample中的2个。所以这个三角形需要生成一个fragment在pixel shader里着色，只不过生成的fragment还是在像素中央（位置，法线等信息插值到像素中央）然后只运行一次pixel shader，最后得到的结果在resolve阶段会乘以0.5，因为这个三角形只cover了一半的sample。现代所有GPU都在硬件上实现了这个算法，而且在shading的运算量远大于光栅化的今天，这个方法远比SSAA快很多。\n","source":"_posts/ComputerGraphics5.md","raw":"---\ntitle: 计算机图形学5 —— 反走样\ntags: [计算机图形学, 光栅化, 反走样]\ncategories: [GAMES101]\nindex_img: /images/graphics5/graphics5_banner.jpg\ndate: 2020-09-13 17:09:11\nmath: true\n---\n\n## 走样\n上一节介绍图形的光栅化的过程，经过图形光栅化过程后，可以得到一个像素集合，它将表示我们想要光栅化的图形，这些点被称为采样信号（Sampled Signal）\n![](/images/graphics5/graphics5_sample.png)\n上图表示了三角形光栅化的过程，可以看到最后形成的采样信号与原信号差距还是比较大的，这种现象就是我们所说的走样(Aliasing)。它对于实际的图形成像的影响非常大，出现走样现象的图形，会在边界处出现各种情况的锯齿，这些锯齿很影响实际的成像体验。\n\n走样现象实际上是无法完全避免的，即使分辨率更高的分辨率，更精细的模型，更高的渲染渲染性能也于事无补。因为产生走样现象的本质是由于像素本身是离散型的，我们需要有限的像素点来表示无限精细的线，走样是数字化的必然产物。比如在下图中，相当精细的画面实际上在放大之后观察像素也存在着走样的现象。我们能够做的，仅仅是利用各种技术去减轻这种现象。\n![](/images/graphics5/graphics5_aliasing.png)\n\n## 走样在信号上的解释\n图形的光栅化过程，实际上是可以通过信号采样和重建过程来表示的。场景中的几何物体投射到屏幕上的过程，实际就是对虚拟场景的采样和重建的过程，所以也可以把图像当作信号来分析。由于存储空间和显示设备分辨率的限制，图像的采样过程也是有损的。\n![](/images/graphics5/graphics5_reconstructed.png)\n\n从频域的角度来看，实际上成样过程实际上也是通过离散的采样点来模拟原信号的变换过程。对于低频信号而言，不需要太多的采样点就可以很容易模拟出原信号的形态，因为原信号变化波动很慢。但是对于高频信号而言，很容易出现采样点无法还原原信号的情况，一旦采样点越过了多次频率变化，就很难还原原有的信号。频率越高，通过采样点能还原原信号的概率就越低。比如下图，蓝色部分是原信号，由于采样点不足，通过采样点还原信号时还原的信号频率远低于原信号。\n\n![](/images/graphics5/graphics5_frequency.png)\n\n因此走样的根因和采样过程有关系，最常见的问题就在于采样不足。信号变换太快（高频信号），但是采样的速度跟不上。从时域的角度去看，当采样不足时，就会出现模拟出的信号与信号源有一定的差距，就造成了走样现象。\n\n### Jaggies（锯齿）\n锯齿是在空间中采样的走样现象，造成这种现象的根本原因是因为在空间采样中过程，信号频率变化太快导致的。在图形的边缘型号有带有颜色信息的信号变为无颜色信息的型号，这个过程变化过于剧烈。在采样的过程中如果采样不足，就会造成边缘部分出现无法还原图形的真实形状，就出现了锯齿。比如下图在边缘部分出现严重的锯齿现象。\n![](/images/graphics5/graphics5_jaggies.png)\n### Moiré Patterns\nMoiré Patterns 也是因为采样不足导致的，在采样过程中由于采样频率过低，从而导致信号在某些区域内出现缺失。比如说在采样的过程中，跳过了奇数行像素或者偶数行像素的信号。就会出现严重的 Moiré Patterns 现象。\n![](/images/graphics5/graphics5_Moiré.jpg)\n\n## 反走样及其原理\n\n### SSAA\n反走样的最直接也最有效的的原理就是增大采样频率，使用尽量多的采样点来还原原始的信号形态。这就是SSAA（Super Sampling Anti-aliasing）的原理。它的原理正如字面意思，将一个像素点分解为多个模拟的像素点，通过这种细分来进行着色（shading）计算，最后在对模拟像素点取平均值，最终的到实际物理像素点的颜色。\n\n以每个像素点分解为4个模拟像素点为例，对原始的像素点作出分解。正如上面的介绍所说，如果模拟像素点位于三角形内，否则不进行着色，所有模拟像素点着色完成之后，则将其计算颜色的平均值。\n![](/images/graphics5/graphics5_SSAA.jpg)\n\n最后通过SSAA得到的像素点如右图所示，看起来依旧是存在锯齿的，但是在实际成像过程中，边缘的部分颜色会浅一些，这样锯齿的效果也不会特别明显，能够更还原几何形体的真实形态。\n\n### MSAA\nMSAA（Multi-Sampling Anti-aliasing）是对SSAA的一个改进。SSAA虽然非常直接有效，但是其消耗的性能也是极大的。拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。\n\nMSAA（Multi-Sampling AA）则很聪明的只是在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次。例如下图是4xMSAA，三角形只覆盖了4个coverage sample中的2个。所以这个三角形需要生成一个fragment在pixel shader里着色，只不过生成的fragment还是在像素中央（位置，法线等信息插值到像素中央）然后只运行一次pixel shader，最后得到的结果在resolve阶段会乘以0.5，因为这个三角形只cover了一半的sample。现代所有GPU都在硬件上实现了这个算法，而且在shading的运算量远大于光栅化的今天，这个方法远比SSAA快很多。\n","slug":"ComputerGraphics5","published":1,"updated":"2020-10-03T09:11:36.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckftgqfaq00072wqc7mnhe534","content":"<h2 id=\"走样\"><a href=\"#走样\" class=\"headerlink\" title=\"走样\"></a>走样</h2><p>上一节介绍图形的光栅化的过程，经过图形光栅化过程后，可以得到一个像素集合，它将表示我们想要光栅化的图形，这些点被称为采样信号（Sampled Signal）<br><img src=\"/images/graphics5/graphics5_sample.png\" alt=\"\"><br>上图表示了三角形光栅化的过程，可以看到最后形成的采样信号与原信号差距还是比较大的，这种现象就是我们所说的走样(Aliasing)。它对于实际的图形成像的影响非常大，出现走样现象的图形，会在边界处出现各种情况的锯齿，这些锯齿很影响实际的成像体验。</p>\n<p>走样现象实际上是无法完全避免的，即使分辨率更高的分辨率，更精细的模型，更高的渲染渲染性能也于事无补。因为产生走样现象的本质是由于像素本身是离散型的，我们需要有限的像素点来表示无限精细的线，走样是数字化的必然产物。比如在下图中，相当精细的画面实际上在放大之后观察像素也存在着走样的现象。我们能够做的，仅仅是利用各种技术去减轻这种现象。<br><img src=\"/images/graphics5/graphics5_aliasing.png\" alt=\"\"></p>\n<h2 id=\"走样在信号上的解释\"><a href=\"#走样在信号上的解释\" class=\"headerlink\" title=\"走样在信号上的解释\"></a>走样在信号上的解释</h2><p>图形的光栅化过程，实际上是可以通过信号采样和重建过程来表示的。场景中的几何物体投射到屏幕上的过程，实际就是对虚拟场景的采样和重建的过程，所以也可以把图像当作信号来分析。由于存储空间和显示设备分辨率的限制，图像的采样过程也是有损的。<br><img src=\"/images/graphics5/graphics5_reconstructed.png\" alt=\"\"></p>\n<p>从频域的角度来看，实际上成样过程实际上也是通过离散的采样点来模拟原信号的变换过程。对于低频信号而言，不需要太多的采样点就可以很容易模拟出原信号的形态，因为原信号变化波动很慢。但是对于高频信号而言，很容易出现采样点无法还原原信号的情况，一旦采样点越过了多次频率变化，就很难还原原有的信号。频率越高，通过采样点能还原原信号的概率就越低。比如下图，蓝色部分是原信号，由于采样点不足，通过采样点还原信号时还原的信号频率远低于原信号。</p>\n<p><img src=\"/images/graphics5/graphics5_frequency.png\" alt=\"\"></p>\n<p>因此走样的根因和采样过程有关系，最常见的问题就在于采样不足。信号变换太快（高频信号），但是采样的速度跟不上。从时域的角度去看，当采样不足时，就会出现模拟出的信号与信号源有一定的差距，就造成了走样现象。</p>\n<h3 id=\"Jaggies（锯齿）\"><a href=\"#Jaggies（锯齿）\" class=\"headerlink\" title=\"Jaggies（锯齿）\"></a>Jaggies（锯齿）</h3><p>锯齿是在空间中采样的走样现象，造成这种现象的根本原因是因为在空间采样中过程，信号频率变化太快导致的。在图形的边缘型号有带有颜色信息的信号变为无颜色信息的型号，这个过程变化过于剧烈。在采样的过程中如果采样不足，就会造成边缘部分出现无法还原图形的真实形状，就出现了锯齿。比如下图在边缘部分出现严重的锯齿现象。<br><img src=\"/images/graphics5/graphics5_jaggies.png\" alt=\"\"></p>\n<h3 id=\"Moire-Patterns\"><a href=\"#Moire-Patterns\" class=\"headerlink\" title=\"Moiré Patterns\"></a>Moiré Patterns</h3><p>Moiré Patterns 也是因为采样不足导致的，在采样过程中由于采样频率过低，从而导致信号在某些区域内出现缺失。比如说在采样的过程中，跳过了奇数行像素或者偶数行像素的信号。就会出现严重的 Moiré Patterns 现象。<br><img src=\"/images/graphics5/graphics5_Moiré.jpg\" alt=\"\"></p>\n<h2 id=\"反走样及其原理\"><a href=\"#反走样及其原理\" class=\"headerlink\" title=\"反走样及其原理\"></a>反走样及其原理</h2><h3 id=\"SSAA\"><a href=\"#SSAA\" class=\"headerlink\" title=\"SSAA\"></a>SSAA</h3><p>反走样的最直接也最有效的的原理就是增大采样频率，使用尽量多的采样点来还原原始的信号形态。这就是SSAA（Super Sampling Anti-aliasing）的原理。它的原理正如字面意思，将一个像素点分解为多个模拟的像素点，通过这种细分来进行着色（shading）计算，最后在对模拟像素点取平均值，最终的到实际物理像素点的颜色。</p>\n<p>以每个像素点分解为4个模拟像素点为例，对原始的像素点作出分解。正如上面的介绍所说，如果模拟像素点位于三角形内，否则不进行着色，所有模拟像素点着色完成之后，则将其计算颜色的平均值。<br><img src=\"/images/graphics5/graphics5_SSAA.jpg\" alt=\"\"></p>\n<p>最后通过SSAA得到的像素点如右图所示，看起来依旧是存在锯齿的，但是在实际成像过程中，边缘的部分颜色会浅一些，这样锯齿的效果也不会特别明显，能够更还原几何形体的真实形态。</p>\n<h3 id=\"MSAA\"><a href=\"#MSAA\" class=\"headerlink\" title=\"MSAA\"></a>MSAA</h3><p>MSAA（Multi-Sampling Anti-aliasing）是对SSAA的一个改进。SSAA虽然非常直接有效，但是其消耗的性能也是极大的。拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。</p>\n<p>MSAA（Multi-Sampling AA）则很聪明的只是在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次。例如下图是4xMSAA，三角形只覆盖了4个coverage sample中的2个。所以这个三角形需要生成一个fragment在pixel shader里着色，只不过生成的fragment还是在像素中央（位置，法线等信息插值到像素中央）然后只运行一次pixel shader，最后得到的结果在resolve阶段会乘以0.5，因为这个三角形只cover了一半的sample。现代所有GPU都在硬件上实现了这个算法，而且在shading的运算量远大于光栅化的今天，这个方法远比SSAA快很多。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"走样\"><a href=\"#走样\" class=\"headerlink\" title=\"走样\"></a>走样</h2><p>上一节介绍图形的光栅化的过程，经过图形光栅化过程后，可以得到一个像素集合，它将表示我们想要光栅化的图形，这些点被称为采样信号（Sampled Signal）<br><img src=\"/images/graphics5/graphics5_sample.png\" alt=\"\"><br>上图表示了三角形光栅化的过程，可以看到最后形成的采样信号与原信号差距还是比较大的，这种现象就是我们所说的走样(Aliasing)。它对于实际的图形成像的影响非常大，出现走样现象的图形，会在边界处出现各种情况的锯齿，这些锯齿很影响实际的成像体验。</p>\n<p>走样现象实际上是无法完全避免的，即使分辨率更高的分辨率，更精细的模型，更高的渲染渲染性能也于事无补。因为产生走样现象的本质是由于像素本身是离散型的，我们需要有限的像素点来表示无限精细的线，走样是数字化的必然产物。比如在下图中，相当精细的画面实际上在放大之后观察像素也存在着走样的现象。我们能够做的，仅仅是利用各种技术去减轻这种现象。<br><img src=\"/images/graphics5/graphics5_aliasing.png\" alt=\"\"></p>\n<h2 id=\"走样在信号上的解释\"><a href=\"#走样在信号上的解释\" class=\"headerlink\" title=\"走样在信号上的解释\"></a>走样在信号上的解释</h2><p>图形的光栅化过程，实际上是可以通过信号采样和重建过程来表示的。场景中的几何物体投射到屏幕上的过程，实际就是对虚拟场景的采样和重建的过程，所以也可以把图像当作信号来分析。由于存储空间和显示设备分辨率的限制，图像的采样过程也是有损的。<br><img src=\"/images/graphics5/graphics5_reconstructed.png\" alt=\"\"></p>\n<p>从频域的角度来看，实际上成样过程实际上也是通过离散的采样点来模拟原信号的变换过程。对于低频信号而言，不需要太多的采样点就可以很容易模拟出原信号的形态，因为原信号变化波动很慢。但是对于高频信号而言，很容易出现采样点无法还原原信号的情况，一旦采样点越过了多次频率变化，就很难还原原有的信号。频率越高，通过采样点能还原原信号的概率就越低。比如下图，蓝色部分是原信号，由于采样点不足，通过采样点还原信号时还原的信号频率远低于原信号。</p>\n<p><img src=\"/images/graphics5/graphics5_frequency.png\" alt=\"\"></p>\n<p>因此走样的根因和采样过程有关系，最常见的问题就在于采样不足。信号变换太快（高频信号），但是采样的速度跟不上。从时域的角度去看，当采样不足时，就会出现模拟出的信号与信号源有一定的差距，就造成了走样现象。</p>\n<h3 id=\"Jaggies（锯齿）\"><a href=\"#Jaggies（锯齿）\" class=\"headerlink\" title=\"Jaggies（锯齿）\"></a>Jaggies（锯齿）</h3><p>锯齿是在空间中采样的走样现象，造成这种现象的根本原因是因为在空间采样中过程，信号频率变化太快导致的。在图形的边缘型号有带有颜色信息的信号变为无颜色信息的型号，这个过程变化过于剧烈。在采样的过程中如果采样不足，就会造成边缘部分出现无法还原图形的真实形状，就出现了锯齿。比如下图在边缘部分出现严重的锯齿现象。<br><img src=\"/images/graphics5/graphics5_jaggies.png\" alt=\"\"></p>\n<h3 id=\"Moire-Patterns\"><a href=\"#Moire-Patterns\" class=\"headerlink\" title=\"Moiré Patterns\"></a>Moiré Patterns</h3><p>Moiré Patterns 也是因为采样不足导致的，在采样过程中由于采样频率过低，从而导致信号在某些区域内出现缺失。比如说在采样的过程中，跳过了奇数行像素或者偶数行像素的信号。就会出现严重的 Moiré Patterns 现象。<br><img src=\"/images/graphics5/graphics5_Moiré.jpg\" alt=\"\"></p>\n<h2 id=\"反走样及其原理\"><a href=\"#反走样及其原理\" class=\"headerlink\" title=\"反走样及其原理\"></a>反走样及其原理</h2><h3 id=\"SSAA\"><a href=\"#SSAA\" class=\"headerlink\" title=\"SSAA\"></a>SSAA</h3><p>反走样的最直接也最有效的的原理就是增大采样频率，使用尽量多的采样点来还原原始的信号形态。这就是SSAA（Super Sampling Anti-aliasing）的原理。它的原理正如字面意思，将一个像素点分解为多个模拟的像素点，通过这种细分来进行着色（shading）计算，最后在对模拟像素点取平均值，最终的到实际物理像素点的颜色。</p>\n<p>以每个像素点分解为4个模拟像素点为例，对原始的像素点作出分解。正如上面的介绍所说，如果模拟像素点位于三角形内，否则不进行着色，所有模拟像素点着色完成之后，则将其计算颜色的平均值。<br><img src=\"/images/graphics5/graphics5_SSAA.jpg\" alt=\"\"></p>\n<p>最后通过SSAA得到的像素点如右图所示，看起来依旧是存在锯齿的，但是在实际成像过程中，边缘的部分颜色会浅一些，这样锯齿的效果也不会特别明显，能够更还原几何形体的真实形态。</p>\n<h3 id=\"MSAA\"><a href=\"#MSAA\" class=\"headerlink\" title=\"MSAA\"></a>MSAA</h3><p>MSAA（Multi-Sampling Anti-aliasing）是对SSAA的一个改进。SSAA虽然非常直接有效，但是其消耗的性能也是极大的。拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。</p>\n<p>MSAA（Multi-Sampling AA）则很聪明的只是在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次。例如下图是4xMSAA，三角形只覆盖了4个coverage sample中的2个。所以这个三角形需要生成一个fragment在pixel shader里着色，只不过生成的fragment还是在像素中央（位置，法线等信息插值到像素中央）然后只运行一次pixel shader，最后得到的结果在resolve阶段会乘以0.5，因为这个三角形只cover了一半的sample。现代所有GPU都在硬件上实现了这个算法，而且在shading的运算量远大于光栅化的今天，这个方法远比SSAA快很多。</p>\n"},{"title":"计算机图形学6 —— 着色","index_img":"/images/graphics6/graphics6_banner.jpg","date":"2020-10-01T09:09:11.000Z","math":true,"_content":"## 可见性和Z-buffer\n对于在一个场景中进行绘制时，将3D模型投影到2D屏幕上的时候，总会出现遮盖的情景。那么那些部分可见，那些部分不可见是需要考虑的。最直接的方式就是一层一层，从远及近将这张图给画出来，这样前景的物体就会遮挡住背景的物体。这种绘制方式叫做画家算法（painter's algorithm）\n但是这种简单的做法在很多场景是很难解决的，因为远近先后顺序这个很难做判断。比如说下面这个场景三角形$P、R、Q$相互的前后关系很难确定，实际要表现的效果是互有遮挡。因此单纯使用画家算法来一层层进行绘制，是很难达到显示效果的。\n![](/images/graphics6/graphics6_painter.png)\n\nZ-buffer算法解决了这个问题，因为对于三角形来说确定遮挡关系很难，但是对于像素来说，是可以有明确的遮挡关系的。对于2D场景中任意一个点$(x, y)$，存储其深度（depth）信息$z$，每次绘制像素点$(x, y)$时，比较其与zbuffer(x, y)的值进行比较，如果小的话则将深度其存储在zbuffer中，并将其颜色信息存储在framebuffer中。当场景计算完毕之后，再通过framebuffer进行绘制。伪代码如下：\n```\nfor (each triangle T)\n    for (each sample (x,y,z) in T)\n        if (z < zbuffer[x,y]) \n            framebuffer[x,y] = rgb; // 存储颜色信息\n            zbuffer[x,y] = z; // 存储z信息\n        else\n            ... // do nothing\n```\n## 光照和着色\n着色（shading）过程是渲染过程非常关键的一步，简单来说就是光栅化过程中计算每个采样点的颜色色值。在词典中着色的解释如下：\n\n```\nshad·ing, [ˈʃeɪdɪŋ], noun\nThe darkening or coloring of an illustration or diagram with parallel lines or a block of color.\n```\n正如解释所说，shading过程实际上就是引入明暗不同以及颜色的变化，在图形学课程中，往往shading指对不同的物体，应用不同的材质。\n![](/images/graphics6/graphics6_shading.png)\n## Blinn-Phong 反射模型\n\n## 着色模型\n\n### Flat Shading(平面着色)\n\n### Gourand Shading（定点着色）\n\n### Phong Shading（像素着色）","source":"_posts/ComputerGraphics6.md","raw":"---\ntitle: 计算机图形学6 —— 着色 \ntags: [计算机图形学, 光照, 着色, 渲染模型]\ncategories: [GAMES101]\nindex_img: /images/graphics6/graphics6_banner.jpg\ndate: 2020-10-1 17:09:11\nmath: true\n---\n## 可见性和Z-buffer\n对于在一个场景中进行绘制时，将3D模型投影到2D屏幕上的时候，总会出现遮盖的情景。那么那些部分可见，那些部分不可见是需要考虑的。最直接的方式就是一层一层，从远及近将这张图给画出来，这样前景的物体就会遮挡住背景的物体。这种绘制方式叫做画家算法（painter's algorithm）\n但是这种简单的做法在很多场景是很难解决的，因为远近先后顺序这个很难做判断。比如说下面这个场景三角形$P、R、Q$相互的前后关系很难确定，实际要表现的效果是互有遮挡。因此单纯使用画家算法来一层层进行绘制，是很难达到显示效果的。\n![](/images/graphics6/graphics6_painter.png)\n\nZ-buffer算法解决了这个问题，因为对于三角形来说确定遮挡关系很难，但是对于像素来说，是可以有明确的遮挡关系的。对于2D场景中任意一个点$(x, y)$，存储其深度（depth）信息$z$，每次绘制像素点$(x, y)$时，比较其与zbuffer(x, y)的值进行比较，如果小的话则将深度其存储在zbuffer中，并将其颜色信息存储在framebuffer中。当场景计算完毕之后，再通过framebuffer进行绘制。伪代码如下：\n```\nfor (each triangle T)\n    for (each sample (x,y,z) in T)\n        if (z < zbuffer[x,y]) \n            framebuffer[x,y] = rgb; // 存储颜色信息\n            zbuffer[x,y] = z; // 存储z信息\n        else\n            ... // do nothing\n```\n## 光照和着色\n着色（shading）过程是渲染过程非常关键的一步，简单来说就是光栅化过程中计算每个采样点的颜色色值。在词典中着色的解释如下：\n\n```\nshad·ing, [ˈʃeɪdɪŋ], noun\nThe darkening or coloring of an illustration or diagram with parallel lines or a block of color.\n```\n正如解释所说，shading过程实际上就是引入明暗不同以及颜色的变化，在图形学课程中，往往shading指对不同的物体，应用不同的材质。\n![](/images/graphics6/graphics6_shading.png)\n## Blinn-Phong 反射模型\n\n## 着色模型\n\n### Flat Shading(平面着色)\n\n### Gourand Shading（定点着色）\n\n### Phong Shading（像素着色）","slug":"ComputerGraphics6","published":1,"updated":"2020-10-04T03:28:01.313Z","_id":"ckftgqfas000a2wqc5y0k2yla","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"可见性和Z-buffer\"><a href=\"#可见性和Z-buffer\" class=\"headerlink\" title=\"可见性和Z-buffer\"></a>可见性和Z-buffer</h2><p>对于在一个场景中进行绘制时，将3D模型投影到2D屏幕上的时候，总会出现遮盖的情景。那么那些部分可见，那些部分不可见是需要考虑的。最直接的方式就是一层一层，从远及近将这张图给画出来，这样前景的物体就会遮挡住背景的物体。这种绘制方式叫做画家算法（painter’s algorithm）<br>但是这种简单的做法在很多场景是很难解决的，因为远近先后顺序这个很难做判断。比如说下面这个场景三角形$P、R、Q$相互的前后关系很难确定，实际要表现的效果是互有遮挡。因此单纯使用画家算法来一层层进行绘制，是很难达到显示效果的。<br><img src=\"/images/graphics6/graphics6_painter.png\" alt=\"\"></p>\n<p>Z-buffer算法解决了这个问题，因为对于三角形来说确定遮挡关系很难，但是对于像素来说，是可以有明确的遮挡关系的。对于2D场景中任意一个点$(x, y)$，存储其深度（depth）信息$z$，每次绘制像素点$(x, y)$时，比较其与zbuffer(x, y)的值进行比较，如果小的话则将深度其存储在zbuffer中，并将其颜色信息存储在framebuffer中。当场景计算完毕之后，再通过framebuffer进行绘制。伪代码如下：<br><pre><code class=\"hljs gml\"><span class=\"hljs-keyword\">for</span> (each triangle T)\n    <span class=\"hljs-keyword\">for</span> (each sample (<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>,z) in T)\n        <span class=\"hljs-keyword\">if</span> (z &lt; zbuffer[<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>]) \n            framebuffer[<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>] = rgb; <span class=\"hljs-comment\">// 存储颜色信息</span>\n            zbuffer[<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>] = z; <span class=\"hljs-comment\">// 存储z信息</span>\n        <span class=\"hljs-keyword\">else</span>\n            ... <span class=\"hljs-comment\">// do nothing</span></code></pre></p>\n<h2 id=\"光照和着色\"><a href=\"#光照和着色\" class=\"headerlink\" title=\"光照和着色\"></a>光照和着色</h2><p>着色（shading）过程是渲染过程非常关键的一步，简单来说就是光栅化过程中计算每个采样点的颜色色值。在词典中着色的解释如下：</p>\n<pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">shad·ing, </span>[ˈʃeɪdɪŋ], noun\nThe darkening <span class=\"hljs-keyword\">or </span>coloring of an illustration <span class=\"hljs-keyword\">or </span><span class=\"hljs-keyword\">diagram </span>with parallel lines <span class=\"hljs-keyword\">or </span>a <span class=\"hljs-keyword\">block </span>of color.</code></pre>\n<p>正如解释所说，shading过程实际上就是引入明暗不同以及颜色的变化，在图形学课程中，往往shading指对不同的物体，应用不同的材质。<br><img src=\"/images/graphics6/graphics6_shading.png\" alt=\"\"></p>\n<h2 id=\"Blinn-Phong-反射模型\"><a href=\"#Blinn-Phong-反射模型\" class=\"headerlink\" title=\"Blinn-Phong 反射模型\"></a>Blinn-Phong 反射模型</h2><h2 id=\"着色模型\"><a href=\"#着色模型\" class=\"headerlink\" title=\"着色模型\"></a>着色模型</h2><h3 id=\"Flat-Shading-平面着色\"><a href=\"#Flat-Shading-平面着色\" class=\"headerlink\" title=\"Flat Shading(平面着色)\"></a>Flat Shading(平面着色)</h3><h3 id=\"Gourand-Shading（定点着色）\"><a href=\"#Gourand-Shading（定点着色）\" class=\"headerlink\" title=\"Gourand Shading（定点着色）\"></a>Gourand Shading（定点着色）</h3><h3 id=\"Phong-Shading（像素着色）\"><a href=\"#Phong-Shading（像素着色）\" class=\"headerlink\" title=\"Phong Shading（像素着色）\"></a>Phong Shading（像素着色）</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"可见性和Z-buffer\"><a href=\"#可见性和Z-buffer\" class=\"headerlink\" title=\"可见性和Z-buffer\"></a>可见性和Z-buffer</h2><p>对于在一个场景中进行绘制时，将3D模型投影到2D屏幕上的时候，总会出现遮盖的情景。那么那些部分可见，那些部分不可见是需要考虑的。最直接的方式就是一层一层，从远及近将这张图给画出来，这样前景的物体就会遮挡住背景的物体。这种绘制方式叫做画家算法（painter’s algorithm）<br>但是这种简单的做法在很多场景是很难解决的，因为远近先后顺序这个很难做判断。比如说下面这个场景三角形$P、R、Q$相互的前后关系很难确定，实际要表现的效果是互有遮挡。因此单纯使用画家算法来一层层进行绘制，是很难达到显示效果的。<br><img src=\"/images/graphics6/graphics6_painter.png\" alt=\"\"></p>\n<p>Z-buffer算法解决了这个问题，因为对于三角形来说确定遮挡关系很难，但是对于像素来说，是可以有明确的遮挡关系的。对于2D场景中任意一个点$(x, y)$，存储其深度（depth）信息$z$，每次绘制像素点$(x, y)$时，比较其与zbuffer(x, y)的值进行比较，如果小的话则将深度其存储在zbuffer中，并将其颜色信息存储在framebuffer中。当场景计算完毕之后，再通过framebuffer进行绘制。伪代码如下：<br><pre><code class=\"hljs gml\"><span class=\"hljs-keyword\">for</span> (each triangle T)\n    <span class=\"hljs-keyword\">for</span> (each sample (<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>,z) in T)\n        <span class=\"hljs-keyword\">if</span> (z &lt; zbuffer[<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>]) \n            framebuffer[<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>] = rgb; <span class=\"hljs-comment\">// 存储颜色信息</span>\n            zbuffer[<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>] = z; <span class=\"hljs-comment\">// 存储z信息</span>\n        <span class=\"hljs-keyword\">else</span>\n            ... <span class=\"hljs-comment\">// do nothing</span></code></pre></p>\n<h2 id=\"光照和着色\"><a href=\"#光照和着色\" class=\"headerlink\" title=\"光照和着色\"></a>光照和着色</h2><p>着色（shading）过程是渲染过程非常关键的一步，简单来说就是光栅化过程中计算每个采样点的颜色色值。在词典中着色的解释如下：</p>\n<pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">shad·ing, </span>[ˈʃeɪdɪŋ], noun\nThe darkening <span class=\"hljs-keyword\">or </span>coloring of an illustration <span class=\"hljs-keyword\">or </span><span class=\"hljs-keyword\">diagram </span>with parallel lines <span class=\"hljs-keyword\">or </span>a <span class=\"hljs-keyword\">block </span>of color.</code></pre>\n<p>正如解释所说，shading过程实际上就是引入明暗不同以及颜色的变化，在图形学课程中，往往shading指对不同的物体，应用不同的材质。<br><img src=\"/images/graphics6/graphics6_shading.png\" alt=\"\"></p>\n<h2 id=\"Blinn-Phong-反射模型\"><a href=\"#Blinn-Phong-反射模型\" class=\"headerlink\" title=\"Blinn-Phong 反射模型\"></a>Blinn-Phong 反射模型</h2><h2 id=\"着色模型\"><a href=\"#着色模型\" class=\"headerlink\" title=\"着色模型\"></a>着色模型</h2><h3 id=\"Flat-Shading-平面着色\"><a href=\"#Flat-Shading-平面着色\" class=\"headerlink\" title=\"Flat Shading(平面着色)\"></a>Flat Shading(平面着色)</h3><h3 id=\"Gourand-Shading（定点着色）\"><a href=\"#Gourand-Shading（定点着色）\" class=\"headerlink\" title=\"Gourand Shading（定点着色）\"></a>Gourand Shading（定点着色）</h3><h3 id=\"Phong-Shading（像素着色）\"><a href=\"#Phong-Shading（像素着色）\" class=\"headerlink\" title=\"Phong Shading（像素着色）\"></a>Phong Shading（像素着色）</h3>"},{"title":"计算机图形学7 —— 渲染管线和纹理","index_img":"/images/graphics5/graphics5_banner.jpg","date":"2020-10-03T09:09:11.000Z","math":true,"_content":"","source":"_posts/ComputerGraphics7.md","raw":"---\ntitle: 计算机图形学7 —— 渲染管线和纹理 \ntags: [计算机图形学, 渲染管线, 纹理]\ncategories: [GAMES101]\nindex_img: /images/graphics5/graphics5_banner.jpg\ndate: 2020-10-03 17:09:11\nmath: true\n---","slug":"ComputerGraphics7","published":1,"updated":"2020-10-03T07:40:41.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckftgqfat000b2wqc7abu0ojc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"使用latex来书写数学公式1 —— latex基础知识","index_img":"/images/latex/latex_head.png","date":"2020-08-10T13:09:11.000Z","math":true,"_content":"## TEX && LATEX\n\nTEX 是Donald E. Knuth 编写的一个以排版文章及数学公式为目标的计算机程序。1977 年，在意识到恶劣的排版质量正在影响自己的著作及文章后，Knuth 开始编写TEX 排版系统引擎，探索当时开始进入出版工业的数字印刷设备的潜 力，尤为希望能扭转排版质量下滑的这一趋势。我们现在使用的TEX 系统发布于 1982 年，在 1989 年又稍做改进，增加了对 8 字节字符及多语言的支持。TEX 以其卓越的稳定性、可在不同类型的电脑上运行以及几乎没有缺陷而著称。TEX 的版本号不断趋近于 π，现在为 3.141592。\n\nLATEX 是一个宏集，它使用一个预先定义好的专业版面，可以使作者们高质量的 排版和打印他们的作品。LATEX 最初由 Leslie Lamport 编写，它使用 TEX 程序作为排版引擎。\n\n## LATEX源文件\n\nLATEX 源文件为普通的ASCII 文件，你可以使用任何文本编辑器来创建。LATEX 源文件不仅包含了要排版的文本，而且也包含了告诉LATEX 如何排版这些文本内 容的命令。\n\n### 空白\n\n空格和制表符等空白字符在LATEX 中被看作相同的空白距离(space)。多个连续 的空白字符等同于一个空白字符。在句首的空白距离一般会被忽略，单个空行也 被认为是一个“空白距离”。\n\n两行文本间的空白行标志着上段的结束和下段的开始。多个空白行的作用 等同于一个空白行。下面便是一个例子，上边是源文件中的文本，下边是排版后的结果。\n\n``` latex\n\nIt does not matter whether you enter one or several    spaces after a word.\n\nAn empty line starts a new paragraph.\n\n```\n![](/images/latex/latex1_graph1.png)\n\n### 特殊字符\n\n下面的这些字符是 LATEX 中的保留字符(reserved characters)，它们或在LATEX 中 有特殊的意义，或不一定存在于所有字库中。如果你直接在文本中输入这些字符，通常它们不会被输出，而且还会导致 LATEX 做一些你不希望发生的事情。需要在这些字符前加上反斜线，它们才可以正常的输出到文档中。\n``` latex\n# $ % ^ & _ { } \\ \n\n#添加反斜线可以输出到文档中\n\\# \\$ \\% \\^{} \\& \\_ \\{ \\} \\{}\n```\n### 命令\n\nATEX 命令(commands) 是大小写敏感的，有以下两种格式:\n\n* 以一个反斜线(backslash)\\开始，命令名只由字母组成。命令名后的空格 符、数字或任何非字母的字符都标志着该命令的结束。\n* 由一个反斜线和非字母的字符组成。\n\nLATEX 忽略命令之后的空白字符。如果你希望在命令后得到一个空格，可以 在命令后加上{} 和一个空格，或加上一个特殊的空格命令。{} 将阻止LATEX 吃掉命令后的所有空格。\n``` latex\nI read that Knuth divides the  \npeople working with \\TeX{} into \n\\TeX{}nicians and \\TeX perts.\\\\ \nToday is \\today. \n```\n![](/images/latex/latex1_graph2.png)\n\n有些命令需要一个参数(parameter)，该参数用花括号(curly braces) { } 括 住并写在命令的后面。一些命令支持可选参数(optional parameters)，可选参数可用方括号(square brackets) [ ] 括住，然后写在命令的后面。\n\n``` latex\nYou can \\textsl{lean} on me!\n```\n![](/images/latex/latex1_graph3.png)\n### 注释\n当LATEX 处理一个源文件时，如果遇到一个百分号%，LATEX 将忽略%后的该行内容，换行符以及下一行前的空白字符。\n\n我们可以据此在源文件中写一些注释，而且这些注释并不会出现在最后的排版结果中。\n\n``` latex\nThis is an % stupid\n% Better: instructive <---- example: Supercal%\n              ifragilist%\n    icexpialidocious\n```\n![](/images/latex/latex1_graph4.png)\n\n如果注释的内容较长，你可以使用verbatim 宏包提供的comment环境。\n``` latex\nThis is another \\begin{comment}\nrather stupid,\nbut helpful\n\\end{comment}\nexample for embedding comments in your document.\n```\n![](/images/latex/latex1_graph5.png)\n\n","source":"_posts/latexlearning1.md","raw":"---\ntitle: 使用latex来书写数学公式1 —— latex基础知识\ntags: [latex, 排版, 论文写作]\ncategories: [latex]\nindex_img: /images/latex/latex_head.png\ndate: 2020-08-10 21:09:11\nmath: true\n---\n## TEX && LATEX\n\nTEX 是Donald E. Knuth 编写的一个以排版文章及数学公式为目标的计算机程序。1977 年，在意识到恶劣的排版质量正在影响自己的著作及文章后，Knuth 开始编写TEX 排版系统引擎，探索当时开始进入出版工业的数字印刷设备的潜 力，尤为希望能扭转排版质量下滑的这一趋势。我们现在使用的TEX 系统发布于 1982 年，在 1989 年又稍做改进，增加了对 8 字节字符及多语言的支持。TEX 以其卓越的稳定性、可在不同类型的电脑上运行以及几乎没有缺陷而著称。TEX 的版本号不断趋近于 π，现在为 3.141592。\n\nLATEX 是一个宏集，它使用一个预先定义好的专业版面，可以使作者们高质量的 排版和打印他们的作品。LATEX 最初由 Leslie Lamport 编写，它使用 TEX 程序作为排版引擎。\n\n## LATEX源文件\n\nLATEX 源文件为普通的ASCII 文件，你可以使用任何文本编辑器来创建。LATEX 源文件不仅包含了要排版的文本，而且也包含了告诉LATEX 如何排版这些文本内 容的命令。\n\n### 空白\n\n空格和制表符等空白字符在LATEX 中被看作相同的空白距离(space)。多个连续 的空白字符等同于一个空白字符。在句首的空白距离一般会被忽略，单个空行也 被认为是一个“空白距离”。\n\n两行文本间的空白行标志着上段的结束和下段的开始。多个空白行的作用 等同于一个空白行。下面便是一个例子，上边是源文件中的文本，下边是排版后的结果。\n\n``` latex\n\nIt does not matter whether you enter one or several    spaces after a word.\n\nAn empty line starts a new paragraph.\n\n```\n![](/images/latex/latex1_graph1.png)\n\n### 特殊字符\n\n下面的这些字符是 LATEX 中的保留字符(reserved characters)，它们或在LATEX 中 有特殊的意义，或不一定存在于所有字库中。如果你直接在文本中输入这些字符，通常它们不会被输出，而且还会导致 LATEX 做一些你不希望发生的事情。需要在这些字符前加上反斜线，它们才可以正常的输出到文档中。\n``` latex\n# $ % ^ & _ { } \\ \n\n#添加反斜线可以输出到文档中\n\\# \\$ \\% \\^{} \\& \\_ \\{ \\} \\{}\n```\n### 命令\n\nATEX 命令(commands) 是大小写敏感的，有以下两种格式:\n\n* 以一个反斜线(backslash)\\开始，命令名只由字母组成。命令名后的空格 符、数字或任何非字母的字符都标志着该命令的结束。\n* 由一个反斜线和非字母的字符组成。\n\nLATEX 忽略命令之后的空白字符。如果你希望在命令后得到一个空格，可以 在命令后加上{} 和一个空格，或加上一个特殊的空格命令。{} 将阻止LATEX 吃掉命令后的所有空格。\n``` latex\nI read that Knuth divides the  \npeople working with \\TeX{} into \n\\TeX{}nicians and \\TeX perts.\\\\ \nToday is \\today. \n```\n![](/images/latex/latex1_graph2.png)\n\n有些命令需要一个参数(parameter)，该参数用花括号(curly braces) { } 括 住并写在命令的后面。一些命令支持可选参数(optional parameters)，可选参数可用方括号(square brackets) [ ] 括住，然后写在命令的后面。\n\n``` latex\nYou can \\textsl{lean} on me!\n```\n![](/images/latex/latex1_graph3.png)\n### 注释\n当LATEX 处理一个源文件时，如果遇到一个百分号%，LATEX 将忽略%后的该行内容，换行符以及下一行前的空白字符。\n\n我们可以据此在源文件中写一些注释，而且这些注释并不会出现在最后的排版结果中。\n\n``` latex\nThis is an % stupid\n% Better: instructive <---- example: Supercal%\n              ifragilist%\n    icexpialidocious\n```\n![](/images/latex/latex1_graph4.png)\n\n如果注释的内容较长，你可以使用verbatim 宏包提供的comment环境。\n``` latex\nThis is another \\begin{comment}\nrather stupid,\nbut helpful\n\\end{comment}\nexample for embedding comments in your document.\n```\n![](/images/latex/latex1_graph5.png)\n\n","slug":"latexlearning1","published":1,"updated":"2020-08-11T03:28:23.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckftgqfav000f2wqc1rng1e5k","content":"<h2 id=\"TEX-amp-amp-LATEX\"><a href=\"#TEX-amp-amp-LATEX\" class=\"headerlink\" title=\"TEX &amp;&amp; LATEX\"></a>TEX &amp;&amp; LATEX</h2><p>TEX 是Donald E. Knuth 编写的一个以排版文章及数学公式为目标的计算机程序。1977 年，在意识到恶劣的排版质量正在影响自己的著作及文章后，Knuth 开始编写TEX 排版系统引擎，探索当时开始进入出版工业的数字印刷设备的潜 力，尤为希望能扭转排版质量下滑的这一趋势。我们现在使用的TEX 系统发布于 1982 年，在 1989 年又稍做改进，增加了对 8 字节字符及多语言的支持。TEX 以其卓越的稳定性、可在不同类型的电脑上运行以及几乎没有缺陷而著称。TEX 的版本号不断趋近于 π，现在为 3.141592。</p>\n<p>LATEX 是一个宏集，它使用一个预先定义好的专业版面，可以使作者们高质量的 排版和打印他们的作品。LATEX 最初由 Leslie Lamport 编写，它使用 TEX 程序作为排版引擎。</p>\n<h2 id=\"LATEX源文件\"><a href=\"#LATEX源文件\" class=\"headerlink\" title=\"LATEX源文件\"></a>LATEX源文件</h2><p>LATEX 源文件为普通的ASCII 文件，你可以使用任何文本编辑器来创建。LATEX 源文件不仅包含了要排版的文本，而且也包含了告诉LATEX 如何排版这些文本内 容的命令。</p>\n<h3 id=\"空白\"><a href=\"#空白\" class=\"headerlink\" title=\"空白\"></a>空白</h3><p>空格和制表符等空白字符在LATEX 中被看作相同的空白距离(space)。多个连续 的空白字符等同于一个空白字符。在句首的空白距离一般会被忽略，单个空行也 被认为是一个“空白距离”。</p>\n<p>两行文本间的空白行标志着上段的结束和下段的开始。多个空白行的作用 等同于一个空白行。下面便是一个例子，上边是源文件中的文本，下边是排版后的结果。</p>\n<pre><code class=\"hljs latex\">\nIt does not matter whether you enter one or several    spaces after a word.\n\nAn empty line starts a new paragraph.\n</code></pre>\n<p><img src=\"/images/latex/latex1_graph1.png\" alt=\"\"></p>\n<h3 id=\"特殊字符\"><a href=\"#特殊字符\" class=\"headerlink\" title=\"特殊字符\"></a>特殊字符</h3><p>下面的这些字符是 LATEX 中的保留字符(reserved characters)，它们或在LATEX 中 有特殊的意义，或不一定存在于所有字库中。如果你直接在文本中输入这些字符，通常它们不会被输出，而且还会导致 LATEX 做一些你不希望发生的事情。需要在这些字符前加上反斜线，它们才可以正常的输出到文档中。<br><pre><code class=\"hljs latex\"># <span class=\"hljs-formula\">$ % ^ &amp; _ &#123; &#125; <span class=\"hljs-tag\">\\<span class=\"hljs-name\"> </span></span></span>\n<span class=\"hljs-formula\"></span>\n<span class=\"hljs-formula\">#添加反斜线可以输出到文档中</span>\n<span class=\"hljs-formula\"><span class=\"hljs-tag\">\\<span class=\"hljs-name\">#</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">$</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">%</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">^</span><span class=\"hljs-string\">&#123;&#125;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&amp;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">_</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&#123;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&#125;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&#123;</span></span>&#125;</span></code></pre></p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>ATEX 命令(commands) 是大小写敏感的，有以下两种格式:</p>\n<ul>\n<li>以一个反斜线(backslash)\\开始，命令名只由字母组成。命令名后的空格 符、数字或任何非字母的字符都标志着该命令的结束。</li>\n<li>由一个反斜线和非字母的字符组成。</li>\n</ul>\n<p>LATEX 忽略命令之后的空白字符。如果你希望在命令后得到一个空格，可以 在命令后加上{} 和一个空格，或加上一个特殊的空格命令。{} 将阻止LATEX 吃掉命令后的所有空格。<br><pre><code class=\"hljs latex\">I read that Knuth divides the  \npeople working with <span class=\"hljs-tag\">\\<span class=\"hljs-name\">TeX</span><span class=\"hljs-string\">&#123;&#125;</span></span> into \n<span class=\"hljs-tag\">\\<span class=\"hljs-name\">TeX</span><span class=\"hljs-string\">&#123;&#125;</span></span>nicians and <span class=\"hljs-tag\">\\<span class=\"hljs-name\">TeX</span></span> perts.<span class=\"hljs-tag\">\\<span class=\"hljs-name\">\\</span></span> \nToday is <span class=\"hljs-tag\">\\<span class=\"hljs-name\">today</span></span>. </code></pre><br><img src=\"/images/latex/latex1_graph2.png\" alt=\"\"></p>\n<p>有些命令需要一个参数(parameter)，该参数用花括号(curly braces) { } 括 住并写在命令的后面。一些命令支持可选参数(optional parameters)，可选参数可用方括号(square brackets) [ ] 括住，然后写在命令的后面。</p>\n<pre><code class=\"hljs latex\">You can <span class=\"hljs-tag\">\\<span class=\"hljs-name\">textsl</span><span class=\"hljs-string\">&#123;lean&#125;</span></span> on me!</code></pre>\n<p><img src=\"/images/latex/latex1_graph3.png\" alt=\"\"></p>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>当LATEX 处理一个源文件时，如果遇到一个百分号%，LATEX 将忽略%后的该行内容，换行符以及下一行前的空白字符。</p>\n<p>我们可以据此在源文件中写一些注释，而且这些注释并不会出现在最后的排版结果中。</p>\n<pre><code class=\"hljs latex\">This is an <span class=\"hljs-comment\">% stupid</span>\n<span class=\"hljs-comment\">% Better: instructive &lt;---- example: Supercal%</span>\n              ifragilist<span class=\"hljs-comment\">%</span>\n    icexpialidocious</code></pre>\n<p><img src=\"/images/latex/latex1_graph4.png\" alt=\"\"></p>\n<p>如果注释的内容较长，你可以使用verbatim 宏包提供的comment环境。<br><pre><code class=\"hljs latex\">This is another <span class=\"hljs-tag\">\\<span class=\"hljs-name\">begin</span><span class=\"hljs-string\">&#123;comment&#125;</span></span>\nrather stupid,\nbut helpful\n<span class=\"hljs-tag\">\\<span class=\"hljs-name\">end</span><span class=\"hljs-string\">&#123;comment&#125;</span></span>\nexample for embedding comments in your document.</code></pre><br><img src=\"/images/latex/latex1_graph5.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"TEX-amp-amp-LATEX\"><a href=\"#TEX-amp-amp-LATEX\" class=\"headerlink\" title=\"TEX &amp;&amp; LATEX\"></a>TEX &amp;&amp; LATEX</h2><p>TEX 是Donald E. Knuth 编写的一个以排版文章及数学公式为目标的计算机程序。1977 年，在意识到恶劣的排版质量正在影响自己的著作及文章后，Knuth 开始编写TEX 排版系统引擎，探索当时开始进入出版工业的数字印刷设备的潜 力，尤为希望能扭转排版质量下滑的这一趋势。我们现在使用的TEX 系统发布于 1982 年，在 1989 年又稍做改进，增加了对 8 字节字符及多语言的支持。TEX 以其卓越的稳定性、可在不同类型的电脑上运行以及几乎没有缺陷而著称。TEX 的版本号不断趋近于 π，现在为 3.141592。</p>\n<p>LATEX 是一个宏集，它使用一个预先定义好的专业版面，可以使作者们高质量的 排版和打印他们的作品。LATEX 最初由 Leslie Lamport 编写，它使用 TEX 程序作为排版引擎。</p>\n<h2 id=\"LATEX源文件\"><a href=\"#LATEX源文件\" class=\"headerlink\" title=\"LATEX源文件\"></a>LATEX源文件</h2><p>LATEX 源文件为普通的ASCII 文件，你可以使用任何文本编辑器来创建。LATEX 源文件不仅包含了要排版的文本，而且也包含了告诉LATEX 如何排版这些文本内 容的命令。</p>\n<h3 id=\"空白\"><a href=\"#空白\" class=\"headerlink\" title=\"空白\"></a>空白</h3><p>空格和制表符等空白字符在LATEX 中被看作相同的空白距离(space)。多个连续 的空白字符等同于一个空白字符。在句首的空白距离一般会被忽略，单个空行也 被认为是一个“空白距离”。</p>\n<p>两行文本间的空白行标志着上段的结束和下段的开始。多个空白行的作用 等同于一个空白行。下面便是一个例子，上边是源文件中的文本，下边是排版后的结果。</p>\n<pre><code class=\"hljs latex\">\nIt does not matter whether you enter one or several    spaces after a word.\n\nAn empty line starts a new paragraph.\n</code></pre>\n<p><img src=\"/images/latex/latex1_graph1.png\" alt=\"\"></p>\n<h3 id=\"特殊字符\"><a href=\"#特殊字符\" class=\"headerlink\" title=\"特殊字符\"></a>特殊字符</h3><p>下面的这些字符是 LATEX 中的保留字符(reserved characters)，它们或在LATEX 中 有特殊的意义，或不一定存在于所有字库中。如果你直接在文本中输入这些字符，通常它们不会被输出，而且还会导致 LATEX 做一些你不希望发生的事情。需要在这些字符前加上反斜线，它们才可以正常的输出到文档中。<br><pre><code class=\"hljs latex\"># <span class=\"hljs-formula\">$ % ^ &amp; _ &#123; &#125; <span class=\"hljs-tag\">\\<span class=\"hljs-name\"> </span></span></span>\n<span class=\"hljs-formula\"></span>\n<span class=\"hljs-formula\">#添加反斜线可以输出到文档中</span>\n<span class=\"hljs-formula\"><span class=\"hljs-tag\">\\<span class=\"hljs-name\">#</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">$</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">%</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">^</span><span class=\"hljs-string\">&#123;&#125;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&amp;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">_</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&#123;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&#125;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&#123;</span></span>&#125;</span></code></pre></p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>ATEX 命令(commands) 是大小写敏感的，有以下两种格式:</p>\n<ul>\n<li>以一个反斜线(backslash)\\开始，命令名只由字母组成。命令名后的空格 符、数字或任何非字母的字符都标志着该命令的结束。</li>\n<li>由一个反斜线和非字母的字符组成。</li>\n</ul>\n<p>LATEX 忽略命令之后的空白字符。如果你希望在命令后得到一个空格，可以 在命令后加上{} 和一个空格，或加上一个特殊的空格命令。{} 将阻止LATEX 吃掉命令后的所有空格。<br><pre><code class=\"hljs latex\">I read that Knuth divides the  \npeople working with <span class=\"hljs-tag\">\\<span class=\"hljs-name\">TeX</span><span class=\"hljs-string\">&#123;&#125;</span></span> into \n<span class=\"hljs-tag\">\\<span class=\"hljs-name\">TeX</span><span class=\"hljs-string\">&#123;&#125;</span></span>nicians and <span class=\"hljs-tag\">\\<span class=\"hljs-name\">TeX</span></span> perts.<span class=\"hljs-tag\">\\<span class=\"hljs-name\">\\</span></span> \nToday is <span class=\"hljs-tag\">\\<span class=\"hljs-name\">today</span></span>. </code></pre><br><img src=\"/images/latex/latex1_graph2.png\" alt=\"\"></p>\n<p>有些命令需要一个参数(parameter)，该参数用花括号(curly braces) { } 括 住并写在命令的后面。一些命令支持可选参数(optional parameters)，可选参数可用方括号(square brackets) [ ] 括住，然后写在命令的后面。</p>\n<pre><code class=\"hljs latex\">You can <span class=\"hljs-tag\">\\<span class=\"hljs-name\">textsl</span><span class=\"hljs-string\">&#123;lean&#125;</span></span> on me!</code></pre>\n<p><img src=\"/images/latex/latex1_graph3.png\" alt=\"\"></p>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>当LATEX 处理一个源文件时，如果遇到一个百分号%，LATEX 将忽略%后的该行内容，换行符以及下一行前的空白字符。</p>\n<p>我们可以据此在源文件中写一些注释，而且这些注释并不会出现在最后的排版结果中。</p>\n<pre><code class=\"hljs latex\">This is an <span class=\"hljs-comment\">% stupid</span>\n<span class=\"hljs-comment\">% Better: instructive &lt;---- example: Supercal%</span>\n              ifragilist<span class=\"hljs-comment\">%</span>\n    icexpialidocious</code></pre>\n<p><img src=\"/images/latex/latex1_graph4.png\" alt=\"\"></p>\n<p>如果注释的内容较长，你可以使用verbatim 宏包提供的comment环境。<br><pre><code class=\"hljs latex\">This is another <span class=\"hljs-tag\">\\<span class=\"hljs-name\">begin</span><span class=\"hljs-string\">&#123;comment&#125;</span></span>\nrather stupid,\nbut helpful\n<span class=\"hljs-tag\">\\<span class=\"hljs-name\">end</span><span class=\"hljs-string\">&#123;comment&#125;</span></span>\nexample for embedding comments in your document.</code></pre><br><img src=\"/images/latex/latex1_graph5.png\" alt=\"\"></p>\n"},{"title":"使用latex来书写数学公式2 —— latex数学公式","index_img":"/images/latex/latex_head.png","date":"2020-08-11T04:09:11.000Z","math":true,"_content":"## 综述\nLATEX 使用一种特有的模式来排版数学(mathematics) 公式。数学公式允许以 行间形式排版在一个段落之中，也可以以独立形式排版，此时段落可能会被拆 开。处于段内的数学文本要放在 `\\(` 与`\\)` 之间，$ 与$ 之间，或者`\\begin{math}` 与 `\\end{math}` 之间。\n\n例如`c^{2}=a^{2}+b^{2}`经过latex转换为公式：\n\n`$c^{2}=a^{2}+b^{2}$`\n\n`100 m^{3}  \\heartsuit`转换为：\n`$100 m^{3} \\heartsuit$`\n\n\n$$\\lim_{n \\to \\infty} \\sum_{k=1}^n \\frac{1}{k^2} = \\frac{\\pi^2}{6}$$","source":"_posts/latexlearning2.md","raw":"---\ntitle: 使用latex来书写数学公式2 —— latex数学公式\ntags: [latex, 排版, 论文写作]\ncategories: [latex]\nindex_img: /images/latex/latex_head.png\ndate: 2020-08-11 12:09:11\nmath: true\n---\n## 综述\nLATEX 使用一种特有的模式来排版数学(mathematics) 公式。数学公式允许以 行间形式排版在一个段落之中，也可以以独立形式排版，此时段落可能会被拆 开。处于段内的数学文本要放在 `\\(` 与`\\)` 之间，$ 与$ 之间，或者`\\begin{math}` 与 `\\end{math}` 之间。\n\n例如`c^{2}=a^{2}+b^{2}`经过latex转换为公式：\n\n`$c^{2}=a^{2}+b^{2}$`\n\n`100 m^{3}  \\heartsuit`转换为：\n`$100 m^{3} \\heartsuit$`\n\n\n$$\\lim_{n \\to \\infty} \\sum_{k=1}^n \\frac{1}{k^2} = \\frac{\\pi^2}{6}$$","slug":"latexlearning2","published":1,"updated":"2020-08-11T05:59:22.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckftgqfb7001p2wqcajpkd7u7","content":"<h2 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h2><p>LATEX 使用一种特有的模式来排版数学(mathematics) 公式。数学公式允许以 行间形式排版在一个段落之中，也可以以独立形式排版，此时段落可能会被拆 开。处于段内的数学文本要放在 <code>\\(</code> 与<code>\\)</code> 之间，$ 与$ 之间，或者<code>\\begin&#123;math&#125;</code> 与 <code>\\end&#123;math&#125;</code> 之间。</p>\n<p>例如<code>c^&#123;2&#125;=a^&#123;2&#125;+b^&#123;2&#125;</code>经过latex转换为公式：</p>\n<script type=\"math/tex; mode=display\">c^{2}=a^{2}+b^{2}</script><p><code>100 m^&#123;3&#125;  \\heartsuit</code>转换为：</p>\n<script type=\"math/tex; mode=display\">100 m^{3} \\heartsuit</script><script type=\"math/tex; mode=display\">\\lim_{n \\to \\infty} \\sum_{k=1}^n \\frac{1}{k^2} = \\frac{\\pi^2}{6}</script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h2><p>LATEX 使用一种特有的模式来排版数学(mathematics) 公式。数学公式允许以 行间形式排版在一个段落之中，也可以以独立形式排版，此时段落可能会被拆 开。处于段内的数学文本要放在 <code>\\(</code> 与<code>\\)</code> 之间，$ 与$ 之间，或者<code>\\begin&#123;math&#125;</code> 与 <code>\\end&#123;math&#125;</code> 之间。</p>\n<p>例如<code>c^&#123;2&#125;=a^&#123;2&#125;+b^&#123;2&#125;</code>经过latex转换为公式：</p>\n<script type=\"math/tex; mode=display\">c^{2}=a^{2}+b^{2}</script><p><code>100 m^&#123;3&#125;  \\heartsuit</code>转换为：</p>\n<script type=\"math/tex; mode=display\">100 m^{3} \\heartsuit</script><script type=\"math/tex; mode=display\">\\lim_{n \\to \\infty} \\sum_{k=1}^n \\frac{1}{k^2} = \\frac{\\pi^2}{6}</script>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckftgqfap00062wqcdu6h53cz","category_id":"ckftgqfan00032wqcbep27pap","_id":"ckftgqfau000c2wqcbperhf6b"},{"post_id":"ckftgqfac00002wqcfw1e2dzf","category_id":"ckftgqfan00032wqcbep27pap","_id":"ckftgqfaw000g2wqc9ly954da"},{"post_id":"ckftgqfaq00072wqc7mnhe534","category_id":"ckftgqfan00032wqcbep27pap","_id":"ckftgqfax000i2wqcetcqhvr2"},{"post_id":"ckftgqfas000a2wqc5y0k2yla","category_id":"ckftgqfan00032wqcbep27pap","_id":"ckftgqfay000m2wqc5j8844oy"},{"post_id":"ckftgqfal00022wqc31nx63tm","category_id":"ckftgqfan00032wqcbep27pap","_id":"ckftgqfay000n2wqc9bhz0uk7"},{"post_id":"ckftgqfat000b2wqc7abu0ojc","category_id":"ckftgqfan00032wqcbep27pap","_id":"ckftgqfaz000p2wqcb5034sx6"},{"post_id":"ckftgqfao00052wqccnkmfykg","category_id":"ckftgqfan00032wqcbep27pap","_id":"ckftgqfaz000r2wqc0gkt6zsd"},{"post_id":"ckftgqfav000f2wqc1rng1e5k","category_id":"ckftgqfax000l2wqcgdd72lcl","_id":"ckftgqfb0000u2wqc9rf643mc"},{"post_id":"ckftgqfb7001p2wqcajpkd7u7","category_id":"ckftgqfax000l2wqcgdd72lcl","_id":"ckftgqfb8001s2wqcc5a5cu0s"}],"PostTag":[{"post_id":"ckftgqfac00002wqcfw1e2dzf","tag_id":"ckftgqfao00042wqc9q5g1gxf","_id":"ckftgqfaw000h2wqcd1m0fw8f"},{"post_id":"ckftgqfac00002wqcfw1e2dzf","tag_id":"ckftgqfar00092wqc0o40bqhh","_id":"ckftgqfax000j2wqcen736wim"},{"post_id":"ckftgqfal00022wqc31nx63tm","tag_id":"ckftgqfao00042wqc9q5g1gxf","_id":"ckftgqfaz000q2wqccjdmd776"},{"post_id":"ckftgqfal00022wqc31nx63tm","tag_id":"ckftgqfar00092wqc0o40bqhh","_id":"ckftgqfaz000s2wqc4qt10xtb"},{"post_id":"ckftgqfao00052wqccnkmfykg","tag_id":"ckftgqfao00042wqc9q5g1gxf","_id":"ckftgqfb1000w2wqcf9ag5myw"},{"post_id":"ckftgqfao00052wqccnkmfykg","tag_id":"ckftgqfaz000t2wqc30rc0ve3","_id":"ckftgqfb1000x2wqc37qfdoqw"},{"post_id":"ckftgqfap00062wqcdu6h53cz","tag_id":"ckftgqfao00042wqc9q5g1gxf","_id":"ckftgqfb100102wqcd8zr6yjl"},{"post_id":"ckftgqfap00062wqcdu6h53cz","tag_id":"ckftgqfb0000v2wqc6mqweawn","_id":"ckftgqfb200112wqccu3gd6kf"},{"post_id":"ckftgqfap00062wqcdu6h53cz","tag_id":"ckftgqfb1000y2wqcdh8xa2yc","_id":"ckftgqfb200132wqchg1s6g98"},{"post_id":"ckftgqfaq00072wqc7mnhe534","tag_id":"ckftgqfao00042wqc9q5g1gxf","_id":"ckftgqfb200152wqc1oolh6fm"},{"post_id":"ckftgqfaq00072wqc7mnhe534","tag_id":"ckftgqfb0000v2wqc6mqweawn","_id":"ckftgqfb300162wqc8p5c0upb"},{"post_id":"ckftgqfaq00072wqc7mnhe534","tag_id":"ckftgqfb200122wqc1z62aa2y","_id":"ckftgqfb300182wqc0vz52wz0"},{"post_id":"ckftgqfas000a2wqc5y0k2yla","tag_id":"ckftgqfao00042wqc9q5g1gxf","_id":"ckftgqfb3001b2wqcg06ihxja"},{"post_id":"ckftgqfas000a2wqc5y0k2yla","tag_id":"ckftgqfb200142wqc0ep45piy","_id":"ckftgqfb4001c2wqc8tdj7an9"},{"post_id":"ckftgqfas000a2wqc5y0k2yla","tag_id":"ckftgqfb300172wqc2t5b83tu","_id":"ckftgqfb4001e2wqchhmdc3am"},{"post_id":"ckftgqfas000a2wqc5y0k2yla","tag_id":"ckftgqfb300192wqc5xd83rqa","_id":"ckftgqfb4001f2wqc38gq21bg"},{"post_id":"ckftgqfat000b2wqc7abu0ojc","tag_id":"ckftgqfao00042wqc9q5g1gxf","_id":"ckftgqfb4001h2wqc5frdbvdi"},{"post_id":"ckftgqfat000b2wqc7abu0ojc","tag_id":"ckftgqfb3001a2wqc2c0ghmf1","_id":"ckftgqfb5001i2wqc4loodj4w"},{"post_id":"ckftgqfat000b2wqc7abu0ojc","tag_id":"ckftgqfb4001d2wqc8mzm03jx","_id":"ckftgqfb5001k2wqc58w33o3m"},{"post_id":"ckftgqfav000f2wqc1rng1e5k","tag_id":"ckftgqfb4001g2wqc4m66f5ah","_id":"ckftgqfb6001m2wqc2qk2cu5u"},{"post_id":"ckftgqfav000f2wqc1rng1e5k","tag_id":"ckftgqfb5001j2wqc3yvz0q2b","_id":"ckftgqfb6001n2wqcgpahfrvm"},{"post_id":"ckftgqfav000f2wqc1rng1e5k","tag_id":"ckftgqfb5001l2wqc3gljf6rn","_id":"ckftgqfb6001o2wqcgjwqdfnw"},{"post_id":"ckftgqfb7001p2wqcajpkd7u7","tag_id":"ckftgqfb4001g2wqc4m66f5ah","_id":"ckftgqfb8001q2wqc5y9l26l6"},{"post_id":"ckftgqfb7001p2wqcajpkd7u7","tag_id":"ckftgqfb5001j2wqc3yvz0q2b","_id":"ckftgqfb8001r2wqc4zrq48b6"},{"post_id":"ckftgqfb7001p2wqcajpkd7u7","tag_id":"ckftgqfb5001l2wqc3gljf6rn","_id":"ckftgqfb8001t2wqc1ora63r0"}],"Tag":[{"name":"计算机图形学","_id":"ckftgqfao00042wqc9q5g1gxf"},{"name":"线性代数","_id":"ckftgqfar00092wqc0o40bqhh"},{"name":"投影，视图变换","_id":"ckftgqfaz000t2wqc30rc0ve3"},{"name":"光栅化","_id":"ckftgqfb0000v2wqc6mqweawn"},{"name":"bresenham","_id":"ckftgqfb1000y2wqcdh8xa2yc"},{"name":"反走样","_id":"ckftgqfb200122wqc1z62aa2y"},{"name":"光照","_id":"ckftgqfb200142wqc0ep45piy"},{"name":"着色","_id":"ckftgqfb300172wqc2t5b83tu"},{"name":"渲染模型","_id":"ckftgqfb300192wqc5xd83rqa"},{"name":"渲染管线","_id":"ckftgqfb3001a2wqc2c0ghmf1"},{"name":"纹理","_id":"ckftgqfb4001d2wqc8mzm03jx"},{"name":"latex","_id":"ckftgqfb4001g2wqc4m66f5ah"},{"name":"排版","_id":"ckftgqfb5001j2wqc3yvz0q2b"},{"name":"论文写作","_id":"ckftgqfb5001l2wqc3gljf6rn"}]}}
{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/code_image.png","path":"img/code_image.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/computer_tools.jpg","path":"img/computer_tools.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/cyber1.jpg","path":"img/cyber1.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/cyber2.jpg","path":"img/cyber2.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/cyber3.jpg","path":"img/cyber3.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/spaceBanner.jpg","path":"img/spaceBanner.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/clipboard-use.js","path":"js/clipboard-use.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/debouncer.js","path":"js/debouncer.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/images/graphics1/graphics1_banner.jpeg","path":"images/graphics1/graphics1_banner.jpeg","modified":0,"renderable":0},{"_id":"source/images/graphics1/graphics1_reflection.png","path":"images/graphics1/graphics1_reflection.png","modified":0,"renderable":0},{"_id":"source/images/graphics1/graphics1_rotate.png","path":"images/graphics1/graphics1_rotate.png","modified":0,"renderable":0},{"_id":"source/images/graphics1/graphics1_shear.png","path":"images/graphics1/graphics1_shear.png","modified":0,"renderable":0},{"_id":"source/images/graphics1/graphics1_scale.png","path":"images/graphics1/graphics1_scale.png","modified":0,"renderable":0},{"_id":"source/images/graphics2/graphics2_banner.jpeg","path":"images/graphics2/graphics2_banner.jpeg","modified":0,"renderable":0},{"_id":"source/images/graphics2/graphics2_compose.png","path":"images/graphics2/graphics2_compose.png","modified":0,"renderable":0},{"_id":"source/images/graphics2/graphics2_decompose.png","path":"images/graphics2/graphics2_decompose.png","modified":0,"renderable":0},{"_id":"source/images/graphics3/graphic3_orthographic.png","path":"images/graphics3/graphic3_orthographic.png","modified":0,"renderable":0},{"_id":"source/images/graphics3/graphic3_orthographic_point.png","path":"images/graphics3/graphic3_orthographic_point.png","modified":0,"renderable":0},{"_id":"source/images/graphics3/graphics3_banner.png","path":"images/graphics3/graphics3_banner.png","modified":0,"renderable":0},{"_id":"source/images/graphics3/graphics3_camera.png","path":"images/graphics3/graphics3_camera.png","modified":0,"renderable":0},{"_id":"source/images/graphics3/graphics3_orthographic_transform.png","path":"images/graphics3/graphics3_orthographic_transform.png","modified":0,"renderable":0},{"_id":"source/images/graphics3/graphics3_transformation.png","path":"images/graphics3/graphics3_transformation.png","modified":0,"renderable":0},{"_id":"source/images/graphics6/graphics6_Ambient.png","path":"images/graphics6/graphics6_Ambient.png","modified":0,"renderable":0},{"_id":"source/images/graphics6/graphics6_Diffuse.png","path":"images/graphics6/graphics6_Diffuse.png","modified":0,"renderable":0},{"_id":"source/images/graphics6/graphics6_Specular.png","path":"images/graphics6/graphics6_Specular.png","modified":0,"renderable":0},{"_id":"source/images/graphics6/graphics6_banner.jpg","path":"images/graphics6/graphics6_banner.jpg","modified":0,"renderable":0},{"_id":"source/images/graphics6/graphics6_combine.png","path":"images/graphics6/graphics6_combine.png","modified":0,"renderable":0},{"_id":"source/images/graphics6/graphics6_diffuse_function.png","path":"images/graphics6/graphics6_diffuse_function.png","modified":0,"renderable":0},{"_id":"source/images/graphics6/graphics6_energy.png","path":"images/graphics6/graphics6_energy.png","modified":0,"renderable":0},{"_id":"source/images/graphics6/graphics6_painter.png","path":"images/graphics6/graphics6_painter.png","modified":0,"renderable":0},{"_id":"source/images/graphics6/graphics6_lambertian.png","path":"images/graphics6/graphics6_lambertian.png","modified":0,"renderable":0},{"_id":"source/images/graphics6/graphics6_shading.png","path":"images/graphics6/graphics6_shading.png","modified":0,"renderable":0},{"_id":"source/images/graphics6/graphics6_spe_param.png","path":"images/graphics6/graphics6_spe_param.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_banner.png","path":"images/graphics4/graphics4_banner.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_bound_box.png","path":"images/graphics4/graphics4_bound_box.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_bresenham.png","path":"images/graphics4/graphics4_bresenham.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_inside.png","path":"images/graphics4/graphics4_inside.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_lines.png","path":"images/graphics4/graphics4_lines.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_pixels.png","path":"images/graphics4/graphics4_pixels.png","modified":0,"renderable":0},{"_id":"source/images/graphics4/graphics4_sample.png","path":"images/graphics4/graphics4_sample.png","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_Moiré.jpg","path":"images/graphics5/graphics5_Moiré.jpg","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_SSAA.png","path":"images/graphics5/graphics5_SSAA.png","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_aliasing.png","path":"images/graphics5/graphics5_aliasing.png","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_frequency.png","path":"images/graphics5/graphics5_frequency.png","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_banner.jpg","path":"images/graphics5/graphics5_banner.jpg","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_jaggies.png","path":"images/graphics5/graphics5_jaggies.png","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_reconstructed.png","path":"images/graphics5/graphics5_reconstructed.png","modified":0,"renderable":0},{"_id":"source/images/graphics5/graphics5_sample.png","path":"images/graphics5/graphics5_sample.png","modified":0,"renderable":0},{"_id":"source/images/graphics7/graphics7_banner.png","path":"images/graphics7/graphics7_banner.png","modified":0,"renderable":0},{"_id":"source/images/graphics7/graphics7_rasterization.jpg","path":"images/graphics7/graphics7_rasterization.jpg","modified":0,"renderable":0},{"_id":"source/images/graphics7/graphics7_shading.jpg","path":"images/graphics7/graphics7_shading.jpg","modified":0,"renderable":0},{"_id":"source/images/graphics7/graphics7_vertex.jpg","path":"images/graphics7/graphics7_vertex.jpg","modified":0,"renderable":0},{"_id":"source/images/graphics7/graphics7_zbuffer.jpg","path":"images/graphics7/graphics7_zbuffer.jpg","modified":0,"renderable":0},{"_id":"source/images/graphics7.5/Areal_coordinates.png","path":"images/graphics7.5/Areal_coordinates.png","modified":0,"renderable":0},{"_id":"source/images/graphics7.5/barycentric_coordinates.png","path":"images/graphics7.5/barycentric_coordinates.png","modified":0,"renderable":0},{"_id":"source/images/graphics7.5/graphics7.5_banner.png","path":"images/graphics7.5/graphics7.5_banner.png","modified":0,"renderable":0},{"_id":"source/images/latex/latex1_graph1.png","path":"images/latex/latex1_graph1.png","modified":0,"renderable":0},{"_id":"source/images/latex/latex1_graph2.png","path":"images/latex/latex1_graph2.png","modified":0,"renderable":0},{"_id":"source/images/latex/latex1_graph4.png","path":"images/latex/latex1_graph4.png","modified":0,"renderable":0},{"_id":"source/images/latex/latex1_graph3.png","path":"images/latex/latex1_graph3.png","modified":0,"renderable":0},{"_id":"source/images/latex/latex_head.png","path":"images/latex/latex_head.png","modified":0,"renderable":0},{"_id":"source/images/latex/latex1_graph5.png","path":"images/latex/latex1_graph5.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/anisotropic.png","path":"images/graphics8/anisotropic.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/bilinear1.png","path":"images/graphics8/bilinear1.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/bilinear2.png","path":"images/graphics8/bilinear2.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/bilinear3.png","path":"images/graphics8/bilinear3.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/earth_mapping.png","path":"images/graphics8/earth_mapping.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/filter_better.png","path":"images/graphics8/filter_better.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/footprint.png","path":"images/graphics8/footprint.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/graphics8_banner.jpeg","path":"images/graphics8/graphics8_banner.jpeg","modified":0,"renderable":0},{"_id":"source/images/graphics8/huge_texture.png","path":"images/graphics8/huge_texture.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/integerD.png","path":"images/graphics8/integerD.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/levelD.png","path":"images/graphics8/levelD.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/mipmap.png","path":"images/graphics8/mipmap.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/mipmap_limitations.png","path":"images/graphics8/mipmap_limitations.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/monster.png","path":"images/graphics8/monster.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/monster_uv.png","path":"images/graphics8/monster_uv.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/projection.png","path":"images/graphics8/projection.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/screen_to_texture.png","path":"images/graphics8/screen_to_texture.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/ssaa.png","path":"images/graphics8/ssaa.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/texture_code.png","path":"images/graphics8/texture_code.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/texture_mapping_lamp.png","path":"images/graphics8/texture_mapping_lamp.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/tiny_texture.png","path":"images/graphics8/tiny_texture.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/trilinear.png","path":"images/graphics8/trilinear.png","modified":0,"renderable":0},{"_id":"source/images/graphics8/trilinearD.png","path":"images/graphics8/trilinearD.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/about/index.md","hash":"d62e53649a8f4a2706d0c68ab0ca93acab0c85af","modified":1597037261740},{"_id":"source/images/.DS_Store","hash":"900fc045c1f2d51332513e21d43daf016aaa6e66","modified":1616488976831},{"_id":"source/.DS_Store","hash":"308441878d6d0573d5c1d52f568a7bbaaf9c7718","modified":1616412502490},{"_id":"source/_posts/.DS_Store","hash":"293323e0edca0a9b854c7c41e07873b8e974a045","modified":1604554420478},{"_id":"source/_posts/ComputerGraphics1.md","hash":"7a5a64db9cf09953d02f181566969e06d2a65488","modified":1601710823072},{"_id":"source/_posts/ComputerGraphics10.md","hash":"400129dcc7d872407e720793d8e6ddc8c14e7020","modified":1603527024452},{"_id":"source/_posts/ComputerGraphics13.md","hash":"f8299d92a9b9305b9e4e1fd7ba0c10dc69306fdd","modified":1603609977081},{"_id":"source/_posts/ComputerGraphics12.md","hash":"9e79813723f932ae88e96a602a7b300859f8473d","modified":1603798085321},{"_id":"source/_posts/ComputerGraphics2.md","hash":"2cc4134a4260c3df400e885f62a3329f40151d45","modified":1601710524581},{"_id":"source/_posts/ComputerGraphics11.md","hash":"31746ef336f5c28a7aa2a60be5961efe803141f2","modified":1603527003743},{"_id":"source/_posts/ComputerGraphics4.md","hash":"a08e4d8ceb83f05ee475e031862b4ef9618e0fe2","modified":1601710821658},{"_id":"source/_posts/ComputerGraphics5.md","hash":"0c06421b09dd2543f9af17faa5bdb2ea827b03ee","modified":1601716296667},{"_id":"source/_posts/ComputerGraphics3.md","hash":"c71a92e3d603a17b2ed6894c7633c6179b29e23d","modified":1601710820317},{"_id":"source/_posts/ComputerGraphics7.5.md","hash":"fac7b6fdcede67d181959730aab56ffb1494298f","modified":1616152507960},{"_id":"source/_posts/ComputerGraphics8.md","hash":"8f44e110a21dc00e189337c8d07831f5fe17aaff","modified":1616494409707},{"_id":"source/_posts/ComputerGraphics7.md","hash":"aec8aeba3014ecfffc1ae55cdda2d808a94a6218","modified":1616134903364},{"_id":"source/_posts/ComputerGraphics6.md","hash":"d4a2624fcf5a78e6be0813010280e8fb349eb807","modified":1602840023719},{"_id":"source/_posts/ComputerGraphics9.md","hash":"984494166cefe8bbd13c198d5cd42eaf5bfd3508","modified":1603527063965},{"_id":"source/_posts/latexlearning2.md","hash":"35e9d07778becafeb8bc5b27a9a953441f0465f4","modified":1597125562346},{"_id":"source/images/graphics1/.DS_Store","hash":"02b0950f2867a15aa8503c6e46847d3dca5d7268","modified":1601716467424},{"_id":"source/images/graphics1/graphics1_banner.jpeg","hash":"67e0c1dcfc0277f456474198cb37161d74997e6f","modified":1601687784000},{"_id":"source/images/graphics1/graphics1_rotate.png","hash":"87f933a2979fa357383b912e5099c023c00556d7","modified":1601687784000},{"_id":"source/images/graphics1/graphics1_shear.png","hash":"4b6f7e2b826a54f583170d8c0d8a88824c612bf1","modified":1601687786000},{"_id":"source/_posts/latexlearning1.md","hash":"a801e559268a9cfaf6674cd17f7c26b7783ba8b6","modified":1597116503746},{"_id":"source/images/graphics1/graphics1_reflection.png","hash":"f1403c8080f54b84a0a353b5d9284db0de91d41d","modified":1601687784000},{"_id":"source/images/graphics1/graphics1_scale.png","hash":"7e2d1af3f5545c706664a180ca1608e66ad86744","modified":1601687784000},{"_id":"source/images/graphics2/graphics2_decompose.png","hash":"2a4b0122cec80d8db30ff5be56368c29006f8bc1","modified":1601687832000},{"_id":"source/images/graphics2/graphics2_compose.png","hash":"2d9c1f16bb2c5ad144fe98edba69383c21f53683","modified":1601687832000},{"_id":"source/images/graphics2/.DS_Store","hash":"7535f5bf7cc37482bc8bf3d686d9bce5a044bdf6","modified":1601716501053},{"_id":"source/images/graphics3/graphic3_orthographic.png","hash":"bb2ec145ea331024692e9d97a498419a95cb70ec","modified":1601687862000},{"_id":"source/images/graphics3/.DS_Store","hash":"1042c6723400d6ecb0cd6b7471d48b3e3cc8107a","modified":1601716533478},{"_id":"source/images/graphics3/graphics3_camera.png","hash":"da6b99e4cb56a867f48f164c8b711438507294e0","modified":1601687862000},{"_id":"source/images/graphics3/graphics3_orthographic_transform.png","hash":"58b34804bddc2cc2a34123faac5bcefb33fc203d","modified":1601687862000},{"_id":"source/images/graphics3/graphics3_transformation.png","hash":"fa2bd2ddffe3a1f2c64e3291a8bbd26dd1946697","modified":1601687862000},{"_id":"source/images/graphics6/graphics6_Ambient.png","hash":"8ad4106e0dd925e69ea16fb8b7c801883f15a9d1","modified":1601971488703},{"_id":"source/images/graphics6/.DS_Store","hash":"511bbfb3c74e2e9a4fd4872358d7b4be2ec69a20","modified":1602304231929},{"_id":"source/images/graphics6/graphics6_Specular.png","hash":"104fdc6ee7038d87410b8f68f80c948db5840a19","modified":1601969615979},{"_id":"source/images/graphics6/graphics6_banner.jpg","hash":"eb6e62e9b30bd8733a14226a8a318ddd3047e746","modified":1601716780485},{"_id":"source/images/graphics4/graphics4_banner.png","hash":"95a3b203897307e7aec529c881f1f9c8874493b1","modified":1601687892000},{"_id":"source/images/graphics4/graphics4_bound_box.png","hash":"42c7ad20384c763210c2f3c9755e620d47d74baf","modified":1601687892000},{"_id":"source/images/graphics4/graphics4_bresenham.png","hash":"98314d14ea732c093eef8a6350fe7cd5f4365b25","modified":1601687892000},{"_id":"source/images/graphics4/graphics4_inside.png","hash":"e2e3eea5291b88a0231e54fdbb811a2a945aa372","modified":1601687892000},{"_id":"source/images/graphics4/.DS_Store","hash":"290462fec27446a2b601fe9262c4e3a32603e24f","modified":1601716560539},{"_id":"source/images/graphics4/graphics4_lines.png","hash":"ee409c72df646791e566f290562b442f32e029c0","modified":1601687892000},{"_id":"source/images/graphics4/graphics4_sample.png","hash":"1785a9591ce6fbb287e4512d4e33777d947fc977","modified":1601687892000},{"_id":"source/images/graphics4/graphics4_pixels.png","hash":"418dc105a6cbf84e4b13294f6e5f8e505bc6bef9","modified":1601687892000},{"_id":"source/images/graphics5/.DS_Store","hash":"57db843f0b328d908d6afd368ae06461876f05c3","modified":1601715619807},{"_id":"source/images/graphics5/graphics5_sample.png","hash":"f257764d7f935cb240fb9f989cbf50f4a33a5ae9","modified":1600926141517},{"_id":"source/images/graphics2/graphics2_banner.jpeg","hash":"37da4d3b58631297d7d5cd82157dad1d191856eb","modified":1601687832000},{"_id":"source/images/graphics7/graphics7_vertex.jpg","hash":"b49cd12eb2bde7aec047aa34f7e9590991862fdf","modified":1603086016321},{"_id":"source/images/graphics7/graphics7_zbuffer.jpg","hash":"e9cf5be0e691ee24854fb6cd86835e28b885cc69","modified":1603088352163},{"_id":"source/images/graphics7.5/Areal_coordinates.png","hash":"416f024d8f45031d1f8c8eaea530173c29f3f88b","modified":1616133105490},{"_id":"source/images/graphics7.5/graphics7.5_banner.png","hash":"9086ecf67506301c3e03aa5b39d9d178195db16c","modified":1616126391292},{"_id":"source/images/latex/latex1_graph1.png","hash":"ab13b12abe952ac3bdb4d8d537b1ce6de5e35872","modified":1597113792835},{"_id":"source/images/latex/latex1_graph4.png","hash":"5a28ff28638f940672333fdb20021acb63aad9b5","modified":1597116203358},{"_id":"source/images/latex/latex1_graph3.png","hash":"9aac9d36160a2226f46a821ad6ade7c35385d443","modified":1597116073034},{"_id":"source/images/graphics7/.DS_Store","hash":"a96a9dd87b5f53d1aba70e959df71c68536ea800","modified":1603089335601},{"_id":"source/images/graphics7/graphics7_shading.jpg","hash":"ad5ce532051ef7c082ad2b646e944f06d554957e","modified":1603087170603},{"_id":"source/images/latex/latex1_graph2.png","hash":"adeafb354599b21eab18179a37efe22d321db754","modified":1597115655881},{"_id":"source/images/latex/latex1_graph5.png","hash":"92c02f0ba26533621f3afe8a788d26d76c352f0d","modified":1597116326970},{"_id":"source/images/graphics3/graphic3_orthographic_point.png","hash":"e636284be174f911d1466c641c87f3e932b81d96","modified":1601687862000},{"_id":"source/images/graphics8/.DS_Store","hash":"c86d6621202dc3377dc1995de700668d568c4950","modified":1616478825872},{"_id":"source/images/graphics6/graphics6_Diffuse.png","hash":"39aa14a22576dd764266f2599908fc26dc2cfaea","modified":1601784820676},{"_id":"source/images/graphics3/graphics3_banner.png","hash":"822b9a3a4527ecd7394662daf9e3e1670e18b83c","modified":1601687862000},{"_id":"source/images/graphics6/graphics6_diffuse_function.png","hash":"5f7186584bdaebc84bb5116302691b922ec02daf","modified":1601788461067},{"_id":"source/images/graphics6/graphics6_lambertian.png","hash":"b0e2431d719213c75073e8a643c23a1b43cfdfd4","modified":1601785494676},{"_id":"source/images/graphics6/graphics6_spe_param.png","hash":"916d5fca80df77a9f44d1575d09aec5267ded9cf","modified":1602238436223},{"_id":"source/images/graphics5/graphics5_banner.jpg","hash":"f721a393d1ec3b3c30a1f07307a3edde80748a9c","modified":1599617536521},{"_id":"source/images/graphics5/graphics5_SSAA.png","hash":"4ae7f970a6e47493726c1411973e09a59fff144f","modified":1601711789052},{"_id":"source/images/graphics5/graphics5_Moiré.jpg","hash":"caed5bedb970e632662792c256fc47db4c00018b","modified":1601205112797},{"_id":"source/images/graphics7/graphics7_rasterization.jpg","hash":"506d40c10facfa0478d19d1fba0a8d43a750cc1a","modified":1603086718680},{"_id":"source/images/graphics8/mipmap.png","hash":"5071bb8827d7d42af6a7ad4ede6e8a1e531938be","modified":1616476121982},{"_id":"source/images/graphics8/texture_mapping_lamp.png","hash":"0a49db21e977858a03dfb60e570b657f08153ff2","modified":1616152894172},{"_id":"source/images/graphics5/graphics5_frequency.png","hash":"1bc1e776b996b49005d688c8a5e20bdc3722a213","modified":1601709979896},{"_id":"source/images/graphics5/graphics5_aliasing.png","hash":"7b236d2a7c66167926db7acda42b8f43a40e98fa","modified":1601205489520},{"_id":"source/images/graphics8/graphics8_banner.jpeg","hash":"d81252df3c378df0bc6917cdfa4b838a2531eb9e","modified":1616125937031},{"_id":"source/images/graphics8/monster_uv.png","hash":"d567e0625b3cfc1f8cc6c2677951833e3271063b","modified":1616380953935},{"_id":"source/images/graphics8/mipmap_limitations.png","hash":"8401011e4919962705552a07615617f3c7bf005f","modified":1616477929736},{"_id":"source/images/graphics7/graphics7_banner.png","hash":"59ef68ec00ba77883217f0e810dc102d6c3baf71","modified":1602304169889},{"_id":"source/images/graphics5/graphics5_reconstructed.png","hash":"ecdd4b9e8a2ead12ef00696f9c6efa62609872be","modified":1601271810769},{"_id":"source/images/graphics8/bilinear3.png","hash":"0f50dfd987372db59a578b06986335c5696e7d19","modified":1616383858757},{"_id":"source/images/graphics8/filter_better.png","hash":"ee0e53e3b09ba8d9f48d973dd4a5bdae73d8248c","modified":1616478798100},{"_id":"source/images/graphics8/monster.png","hash":"f440f9db4badd000be3bc0769d5e2af7ba1e3c5d","modified":1616380208260},{"_id":"source/images/graphics6/graphics6_painter.png","hash":"be49881d065b0caf5dba335185373013850f2eeb","modified":1601732021489},{"_id":"source/images/graphics6/graphics6_shading.png","hash":"49e328545eb0d1838657c572bad0d352da6d951b","modified":1601737834149},{"_id":"source/images/graphics8/bilinear2.png","hash":"bc054e95464ed4baed6929c8954323fe6f47ebbc","modified":1616383360396},{"_id":"source/images/graphics8/anisotropic.png","hash":"9b95e6e37f4c1fdd92d602cd672a05386e22fbf0","modified":1616478639395},{"_id":"source/images/graphics6/graphics6_energy.png","hash":"f4dfb23bb10fd8df206c0776bdcfef9aa7775fd5","modified":1601788210836},{"_id":"source/images/graphics8/trilinearD.png","hash":"6f1097d74a0f3eff775c41052acd600b3e9a772b","modified":1616477777708},{"_id":"source/images/graphics8/integerD.png","hash":"35e377ea956c0b5079d82692dc8e7eb63bb0cab0","modified":1616477297984},{"_id":"source/images/graphics8/ssaa.png","hash":"db50f5b4807146e212b0b4fcfddf339335845aee","modified":1616412981762},{"_id":"source/images/graphics6/graphics6_combine.png","hash":"7cff98c34ef0cb373a8d7af87a7c92e1db391663","modified":1602237433683},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1591272997000},{"_id":"source/images/graphics8/bilinear1.png","hash":"b61c756d0393e0b2b486f012a918e398e6bfa75c","modified":1616383160130},{"_id":"source/images/graphics8/screen_to_texture.png","hash":"68c5bb6c2218efce465b6d8dc64ba18d920ea083","modified":1616478356512},{"_id":"themes/fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1591272997000},{"_id":"themes/fluid/LICENSE","hash":"5b919c12e4f5f5cdebb7c17ded4f10f1ebe64811","modified":1591272997000},{"_id":"themes/fluid/.DS_Store","hash":"a4f71eb0200abd95044f0440094b10bc71a3e410","modified":1597041781196},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1591272997000},{"_id":"themes/fluid/.eslintrc","hash":"0a59eec340b771758cf736290272c549d81ef88c","modified":1591272997000},{"_id":"themes/fluid/README.md","hash":"23729af73d967cd11a84bed7c839454df3169eb9","modified":1591272997000},{"_id":"themes/fluid/README_en.md","hash":"7db56a9214405dd3612b808baaf0847ae4986c6a","modified":1591272997000},{"_id":"themes/fluid/_static_prefix.yml","hash":"19b4414055b720ece8d78674085f4e1199ccc128","modified":1591272997000},{"_id":"themes/fluid/package.json","hash":"d37c2637ed470ed61dd63142ab1291233267abdb","modified":1591272997000},{"_id":"themes/fluid/_config.yml","hash":"da332583febff203a9cdf4f4b34201b16132f4a5","modified":1597207749461},{"_id":"themes/fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":1591272997000},{"_id":"themes/fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1591272997000},{"_id":"themes/fluid/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1591272997000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1591272997000},{"_id":"themes/fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1591272997000},{"_id":"themes/fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1591272997000},{"_id":"themes/fluid/layout/about.ejs","hash":"a23e73c92b6d3ff0df55dbd1aa774065a3291d8d","modified":1591272997000},{"_id":"themes/fluid/layout/archive.ejs","hash":"783ce7efe83bd72e3c767fd5a190ad38113ff34f","modified":1591272997000},{"_id":"themes/fluid/layout/index.ejs","hash":"31c62687deb7d224c9b7f4e6d0d5f43406dd3fce","modified":1591272997000},{"_id":"themes/fluid/layout/category.ejs","hash":"a3f1195424a24ea2b6d996e504b503e9c156f517","modified":1591272997000},{"_id":"themes/fluid/layout/categories.ejs","hash":"3b8589675338c7b3e1849104b7bb15ac477fce4e","modified":1591272997000},{"_id":"themes/fluid/layout/layout.ejs","hash":"941b922aae1e0f8c0dfd57cc14d50c0c85a8ec60","modified":1591272997000},{"_id":"themes/fluid/layout/page.ejs","hash":"8cab50ead4cdb992d35710147a9a5308fb5df290","modified":1591272997000},{"_id":"themes/fluid/layout/links.ejs","hash":"0bb8360ad6a2433fdeddf01fbd39b4f2db67b08f","modified":1591272997000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1591272997000},{"_id":"themes/fluid/layout/post.ejs","hash":"7ecfa13fe363799c7620d3386a79a889d6a7545d","modified":1591272997000},{"_id":"themes/fluid/layout/tag.ejs","hash":"86d1c27b1536eb3f12c18f7264abb1d6fa6d96f6","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"4f3acc8dc822c85d0d778552a15875f71c0cd80a","modified":1591272997000},{"_id":"themes/fluid/source/.DS_Store","hash":"4087f0f8c44d6a87e3fec684e3cc78e050f144fa","modified":1597061651786},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"cc6f4130c14ba7ebdb68bb5664f05dc16d7cecb1","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"5dbb5ae9a8d10b43beb0495788c83629c81e9922","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"03defcd4409dce27447aa8dfe7ce41a2d47e373b","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"502f9cdf526e850833d87415cda352a2e1002a51","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"783eee847562ce14db8f723b4ae742fb69aaf620","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/post-meta.ejs","hash":"411fe0b8b169cd4e94d00450ae76a3b7ce994c44","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"0d818a43079d9a2da12d9c974426d675cc0b66ea","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1591272997000},{"_id":"themes/fluid/scripts/events/index.js","hash":"36b137b75c76ff08523016dc8eac702f397d771b","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"3cf1d9b9032919d6b936e1f2410911df3b325670","modified":1591272997000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"bb90a128a999b276c10a822c44851fa27d6d64ae","modified":1591272997000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1591272997000},{"_id":"themes/fluid/.github/workflows/lint.yaml","hash":"0c02cc7e5a1318c481a6f523747407b29da58645","modified":1591272997000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"f64d2121d99225e9f6d12ce646af618232f5f366","modified":1591272997000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"48e1b46b4c34b79a128dda7a0592b43be47cf955","modified":1591272997000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"6665f19fa30cbbe0853d8140a0832f8638538f89","modified":1591272997000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"c131fb22805cec89d647e643299508487fc72576","modified":1591272997000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1591272997000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"d50f5aeb1a95adbc88cea9cca4a07165d6725408","modified":1591272997000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":1591272997000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"0886cfe3f8589671a1d289495e359c20a9908080","modified":1591272997000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":1591272997000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"d45dce23532c17367c7eb86b94afa8c9e40d16c6","modified":1591272997000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":1591272997000},{"_id":"themes/fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1591272997000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":1591272997000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1591272997000},{"_id":"themes/fluid/source/img/.DS_Store","hash":"704e21bfe6edae5bde4828e3b6d8d3a854090d64","modified":1597058873202},{"_id":"themes/fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1591272997000},{"_id":"themes/fluid/source/img/favicon.png","hash":"c2c40a9604c8e857b685bfcba36706138b67f9c8","modified":1597037890305},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1591272997000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1591272997000},{"_id":"themes/fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1591272997000},{"_id":"themes/fluid/source/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1591272997000},{"_id":"themes/fluid/source/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1591272997000},{"_id":"themes/fluid/source/js/main.js","hash":"863a68ca6fac43dc2a42f6ffcad2ccbdd7d249cc","modified":1591272997000},{"_id":"themes/fluid/source/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1591272997000},{"_id":"themes/fluid/source/js/local-search.js","hash":"5e36b80ad9594246f78da743a742527382b7cd50","modified":1591272997000},{"_id":"themes/fluid/source/js/utils.js","hash":"24b1f871f74f9bed7ac59bb0ad28a60f1491e4c2","modified":1591272997000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"d3a3204d9bb2b43a69c9cb0be59bada8cb91e412","modified":1591272997000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"272067b338530bee68c0c08b839da552cfe486b4","modified":1591272997000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"7fcdcd44f3a851722e8ffc511b3ed336c30d7561","modified":1591272997000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"a413dc14e4737dbcaa8fb797d37f85121ede6551","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"fe37916cb431c8842427797aa1e4edf55b30af0a","modified":1591272997000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1591272997000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"93cf5e1f1e0362adee0f63f4edcc7738cd4fc842","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"3f2b188bc108d8354ffd9d74511125d50ec02979","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"3a13813e62f0b5f57ae4b9d6b7c9b32d7bca70d6","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"0a34a8c809209089466116c46d7a2daac5a4f326","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"4171a45f75525251ffd4e15756b34e5b9c4cb167","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"db103077a6957c9d4786e98fd8144d6a5b03c495","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/anchor.ejs","hash":"3738c2ef427b4b400225b92e638a17b7ab2125ed","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"872f8915a791c6015017d026225de6bc76441a8a","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/daovoice.ejs","hash":"cfc684ba48608abd25afd155ee373d9936bbe84e","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/aplayer.ejs","hash":"e843cdbe64af3dee9385eb1d763539d3ac10ed72","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/local-search.ejs","hash":"03b024c7bab51b64e5187c9dbfac039d020f1e97","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/tocjs.ejs","hash":"4d961ce5cc706445f12b9636801e80a521579f72","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/mouse-click.ejs","hash":"eb19991199c201ceb103a6ef025e4dfd1e7dbfb7","modified":1591272997000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1591272997000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da4c281a8b2d2ed813da1236950c9dff87334adc","modified":1591272997000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"a382f567d95e53ef614246098fd844dd3b86ac44","modified":1591272997000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"374583fd419ac6477dfca69e09756db543d7ec80","modified":1591272997000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"ee7dfef805af96195c11223cca53983deace8bda","modified":1591272997000},{"_id":"themes/fluid/scripts/events/lib/version.js","hash":"5fed24e25662a1b08fd857fde2d770fdc6250475","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"38334350425008d1f64323de221457ee0948af0e","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/leancloud.ejs","hash":"7807e58722dcf992fba11bc879b0fac0e904dc76","modified":1591272997000},{"_id":"themes/fluid/layout/_partial/plugins/fancybox.ejs","hash":"c447e35c93c61a70c1c2dfc34948615832989660","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1591272997000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1591272997000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1591272997000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"3cca1d1ed5fe23d9025ec5fe28d2a215b93efade","modified":1591272997000},{"_id":"themes/fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"2637dce25ee7c00b94e64d15834d178f3c78a912","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"c34979b9b8e5c9cb54dcdd73a1fe877bcb943548","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_base/rewrite.styl","hash":"7288884ed0f3bf5e4d8ae790269357ca073eab64","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"9ce4d5d708047520345a85bbfc101b3e67dbf7b8","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_post/tag_plugin.styl","hash":"37043762d345f33dc1817c18e4ac6c47551f6d42","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"4f27a4bdf703aec6f900727df2596bac902c441a","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"a13243e6281432e312ea73683cfd1a3dd50f6ebf","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"63152526c501e674085235982603ba60b659cb84","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"934a6ae74b29a6903d2309498653910c19a77c8b","modified":1591272997000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"7e07e44fa0e77ddbdd3aa0c0abdb3be6822df2e0","modified":1591272997000},{"_id":"source/images/latex/latex_head.png","hash":"2ebc6e6e8130d5a7f1b8f4f91318d17a800cb659","modified":1597113728875},{"_id":"source/images/graphics8/huge_texture.png","hash":"2663cf608d113cb384bddb810eecedb916109ccb","modified":1616384439433},{"_id":"source/images/graphics8/projection.png","hash":"eabbf4fc84a7e6c259cc97ba07e2dd33cba12477","modified":1616475337402},{"_id":"source/images/graphics8/trilinear.png","hash":"b06ce5563984ea5604821fdb9a5eb5e14b4bd22d","modified":1616477417597},{"_id":"source/images/graphics8/tiny_texture.png","hash":"4e577f13b7a80b836ebd08fa85a42fb826b49956","modified":1616382543085},{"_id":"themes/fluid/source/img/computer_tools.jpg","hash":"1a4d0dfc2a1e78f14e2048ca7bdd80feccceb866","modified":1597041746796},{"_id":"source/images/graphics8/texture_code.png","hash":"53493d54d5e91cce5686000a1fe1cde5da244287","modified":1616381281734},{"_id":"themes/fluid/source/img/cyber1.jpg","hash":"d4ca7f895b0ef976679b4866227b94884c04ecb5","modified":1597058723923},{"_id":"source/images/graphics7.5/barycentric_coordinates.png","hash":"3f4b6aca3cd037cbde651b979386625620b13c45","modified":1616132157571},{"_id":"source/images/graphics5/graphics5_jaggies.png","hash":"d246ef0d5edb456b279e6fc85fef12c9ea37b6b9","modified":1601709018434},{"_id":"themes/fluid/source/img/cyber3.jpg","hash":"94d3c568972fe23f9f539b690bd263de9245dc0f","modified":1597058198048},{"_id":"source/images/graphics8/footprint.png","hash":"0d56a4704f2abbc48d4107bd23849354212e3add","modified":1616412476363},{"_id":"themes/fluid/source/img/spaceBanner.jpg","hash":"e6a9ecd066b8968bb32900fe0aef78defd728e5f","modified":1597038573251},{"_id":"themes/fluid/source/img/code_image.png","hash":"201f6e216dd369afe5c210f5052d44a4010f70cd","modified":1597058528574},{"_id":"themes/fluid/source/img/cyber2.jpg","hash":"35788ca04003ec6699da9dda38b6364504fd5e62","modified":1597058804347},{"_id":"source/images/graphics8/levelD.png","hash":"2c2ac49da12d2fa3dbdcf887d667e552ee2e61f6","modified":1616476837067},{"_id":"source/images/graphics8/earth_mapping.png","hash":"2ddc584c91d33c869192799e665ffb4fdd1518ab","modified":1616379985891},{"_id":"public/local-search.xml","hash":"b637ae8f0bf994356f865cbecb0a8bb9e42317af","modified":1616494438707},{"_id":"public/about/index.html","hash":"ea508c3dbd72552b8e99b93a26e07f84afd5b2d4","modified":1616494438707},{"_id":"public/2020/10/25/ComputerGraphics12/index.html","hash":"f6ac7a2a8db06aa9016a2584b910b2c3007a8607","modified":1616494438707},{"_id":"public/2020/10/03/ComputerGraphics11/index.html","hash":"280caedb32b69dec7a10fcb2ea7bb3b866febe50","modified":1616494438707},{"_id":"public/2020/10/03/ComputerGraphics10/index.html","hash":"be77178260cda8be7db3d64e4e2ca6dd67291b94","modified":1616494438707},{"_id":"public/2020/10/03/ComputerGraphics13/index.html","hash":"c8dc4a6149e66552127c415bfda2ff21bd6690f7","modified":1616494438707},{"_id":"public/2020/10/03/ComputerGraphics9/index.html","hash":"e9558bef50d2da313125df037ac5a5cc4cfe28be","modified":1616494438707},{"_id":"public/2020/08/11/latexlearning2/index.html","hash":"e626841caccb5fd1892bff15f37c5e5d3df8d2ac","modified":1616494438707},{"_id":"public/archives/index.html","hash":"6cac55305108403eeb3f3e1b8fc37540cac6618b","modified":1616494438707},{"_id":"public/archives/page/2/index.html","hash":"ce74c271ed0a40affc6bec346dc1871edccbb991","modified":1616494438707},{"_id":"public/archives/2020/index.html","hash":"5329180a86579330fb668c8cdc56b2f497504be2","modified":1616494438707},{"_id":"public/archives/2020/page/2/index.html","hash":"0dbe4e72c47da22ed01669e2e1c23c6461a8fc76","modified":1616494438707},{"_id":"public/archives/2020/08/index.html","hash":"b45b2198e405f3ce312d341ace7a3301a292b116","modified":1616494438707},{"_id":"public/archives/2020/09/index.html","hash":"ad6452bf2d124ac3c83095dc25752ff12367d050","modified":1616494438707},{"_id":"public/archives/2020/10/index.html","hash":"1064a426dec7efecae5bfe61cfbf73507ea281ff","modified":1616494438707},{"_id":"public/categories/GAMES101/index.html","hash":"5812d9e2b2f2f1fd843ed005e0517fed7faf6b2f","modified":1616494438707},{"_id":"public/categories/GAMES101/page/2/index.html","hash":"329840c75960d45e3c475ac1d74affdc5ea66303","modified":1616494438707},{"_id":"public/categories/latex/index.html","hash":"6500637da601f5b04cf01ef28953b302f4463ca9","modified":1616494438707},{"_id":"public/tags/计算机图形学/index.html","hash":"99dfbd5050cc71efb7c22ee3b81684a3385a5368","modified":1616494438707},{"_id":"public/tags/计算机图形学/page/2/index.html","hash":"51ab27af6e601f97e71d974a18d43c250ba17605","modified":1616494438707},{"_id":"public/tags/线性代数/index.html","hash":"db0bec888c492e100c374b873f6228600212014a","modified":1616494438707},{"_id":"public/tags/几何/index.html","hash":"7f64e1afae0f34d4e032e21acf3e8be80f86c858","modified":1616494438707},{"_id":"public/tags/曲面细分/index.html","hash":"c8b5762de4596f5a1778d1bf536233734749b717","modified":1616494438707},{"_id":"public/tags/贝塞尔曲线/index.html","hash":"92753f456b417a57080e680872d6e565c57dcc86","modified":1616494438707},{"_id":"public/tags/光线追踪/index.html","hash":"2427a61ddfde8cad5d074cb8540d1ae0cb028d1c","modified":1616494438707},{"_id":"public/tags/阴影/index.html","hash":"ae85f86ec160dc4a67cf7dba3aeefef98f761bf8","modified":1616494438707},{"_id":"public/tags/投影，视图变换/index.html","hash":"c4a74111a96c0bc7cb0c426f54f6411a6f7cf28f","modified":1616494438707},{"_id":"public/tags/光栅化/index.html","hash":"a6ce10e0d8426a408affede3cb35c7715f8ada81","modified":1616494438707},{"_id":"public/tags/bresenham/index.html","hash":"308400a6acabc00220f8f05f6b8241bf67061a18","modified":1616494438707},{"_id":"public/tags/反走样/index.html","hash":"48f23a52cb0ddef4c8cf74100d90f3d986318f6b","modified":1616494438707},{"_id":"public/tags/光照/index.html","hash":"ebef6392095acf6b6460194ad045f7919e4b94e7","modified":1616494438707},{"_id":"public/tags/着色/index.html","hash":"ddcc413677f808e8a4ff8edc7d94e328df0f4814","modified":1616494438707},{"_id":"public/tags/渲染模型/index.html","hash":"99491783131897a17143e52ae1acede3e39573f1","modified":1616494438707},{"_id":"public/tags/重心坐标/index.html","hash":"8204b4594ff8d5a1b7637ff8be3cd8fbd6742ecd","modified":1616494438707},{"_id":"public/tags/线性插值/index.html","hash":"628a5fa77099e55607e0aaa403b8cb90d278b28d","modified":1616494438707},{"_id":"public/tags/渲染管线/index.html","hash":"8c3bb7a3ca2bec225451b03ecae4bf5e59ecfe6d","modified":1616494438707},{"_id":"public/tags/隐式曲面/index.html","hash":"032fae683c9544d81a9a91882ea488d0ca93fae0","modified":1616494438707},{"_id":"public/tags/显式曲面/index.html","hash":"db87150ca046af9aef2a6729395ca2cd46424719","modified":1616494438707},{"_id":"public/tags/纹理映射/index.html","hash":"a5a370c1a33c1f128aea1337f6e590f150eb5bb3","modified":1616494438707},{"_id":"public/tags/Mipmap/index.html","hash":"1f04dcbcbdb2daa01fb87d60f89cfe1cf3bc74e8","modified":1616494438707},{"_id":"public/tags/latex/index.html","hash":"ef7a166a0e1ca800ba8eff37f9168c07f2d981e5","modified":1616494438707},{"_id":"public/tags/排版/index.html","hash":"d8a34e62d999b0626ebb889c405d34e22abf81df","modified":1616494438707},{"_id":"public/tags/论文写作/index.html","hash":"b5f1185fe8d617a7f6e61f7e6c39ddc76325c6b2","modified":1616494438707},{"_id":"public/404.html","hash":"5f6e28fecff0abb035e4dad1bd0975f0fe2a7ccd","modified":1616494438707},{"_id":"public/tags/index.html","hash":"b10a15e43a54a6847d3bf1ec93dfb0ab26d928b1","modified":1616494438707},{"_id":"public/categories/index.html","hash":"08af6c9b8f39ae6d7629f4ae30c622405294e960","modified":1616494438707},{"_id":"public/links/index.html","hash":"e9c752f82e06041d79d6fa5612f82c65c4d6ab26","modified":1616494438707},{"_id":"public/2020/10/03/ComputerGraphics7.5/index.html","hash":"64dee25d9891d6a2978fc06c21ec6a677d6a48b5","modified":1616494438707},{"_id":"public/2020/10/03/ComputerGraphics7/index.html","hash":"890b5d40e58c4e9aae477c659aee4933b82a0384","modified":1616494438707},{"_id":"public/2020/10/03/ComputerGraphics8/index.html","hash":"7b3116ff022f6fb3d809a171821c785f3ae46836","modified":1616494438707},{"_id":"public/2020/10/01/ComputerGraphics6/index.html","hash":"e8332aef90cccba65968d028c68dec9975a14a1d","modified":1616494438707},{"_id":"public/2020/09/13/ComputerGraphics5/index.html","hash":"34c8e8b19e4d45ed5296ff328eb682e76733f963","modified":1616494438707},{"_id":"public/2020/09/01/ComputerGraphics4/index.html","hash":"ca2fae39dc55f468e2ae02bfcf790c3c358fc1e9","modified":1616494438707},{"_id":"public/2020/08/24/ComputerGraphics3/index.html","hash":"00b422b0d00c1bdb13b077f9311855063e6a1203","modified":1616494438707},{"_id":"public/2020/08/17/ComputerGraphics2/index.html","hash":"7b440338b61ea8e2b10a134a0d7af3df24b9bb9c","modified":1616494438707},{"_id":"public/2020/08/10/latexlearning1/index.html","hash":"9a15b66020a6a807a7f7b53e284084e724d3471a","modified":1616494438707},{"_id":"public/2020/08/10/ComputerGraphics1/index.html","hash":"ec6106efa1474b1ffb8755be9796a8263f3c8e46","modified":1616494438707},{"_id":"public/index.html","hash":"3cff1f5a223ca8c7c49b5020b48c4d40c055bc42","modified":1616494438707},{"_id":"public/page/2/index.html","hash":"b5bb01bb8513bd678f3b3d9e7b61f0e33eb35956","modified":1616494438707},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1616494438707},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1616494438707},{"_id":"public/img/favicon.png","hash":"c2c40a9604c8e857b685bfcba36706138b67f9c8","modified":1616494438707},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1616494438707},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1616494438707},{"_id":"public/images/graphics1/graphics1_banner.jpeg","hash":"67e0c1dcfc0277f456474198cb37161d74997e6f","modified":1616494438707},{"_id":"public/images/graphics1/graphics1_reflection.png","hash":"f1403c8080f54b84a0a353b5d9284db0de91d41d","modified":1616494438707},{"_id":"public/images/graphics1/graphics1_rotate.png","hash":"87f933a2979fa357383b912e5099c023c00556d7","modified":1616494438707},{"_id":"public/images/graphics1/graphics1_shear.png","hash":"4b6f7e2b826a54f583170d8c0d8a88824c612bf1","modified":1616494438707},{"_id":"public/images/graphics1/graphics1_scale.png","hash":"7e2d1af3f5545c706664a180ca1608e66ad86744","modified":1616494438707},{"_id":"public/images/graphics2/graphics2_banner.jpeg","hash":"37da4d3b58631297d7d5cd82157dad1d191856eb","modified":1616494438707},{"_id":"public/images/graphics2/graphics2_compose.png","hash":"2d9c1f16bb2c5ad144fe98edba69383c21f53683","modified":1616494438707},{"_id":"public/images/graphics2/graphics2_decompose.png","hash":"2a4b0122cec80d8db30ff5be56368c29006f8bc1","modified":1616494438707},{"_id":"public/images/graphics3/graphic3_orthographic.png","hash":"bb2ec145ea331024692e9d97a498419a95cb70ec","modified":1616494438707},{"_id":"public/images/graphics3/graphic3_orthographic_point.png","hash":"e636284be174f911d1466c641c87f3e932b81d96","modified":1616494438707},{"_id":"public/images/graphics3/graphics3_camera.png","hash":"da6b99e4cb56a867f48f164c8b711438507294e0","modified":1616494438707},{"_id":"public/images/graphics3/graphics3_transformation.png","hash":"fa2bd2ddffe3a1f2c64e3291a8bbd26dd1946697","modified":1616494438707},{"_id":"public/images/graphics3/graphics3_orthographic_transform.png","hash":"58b34804bddc2cc2a34123faac5bcefb33fc203d","modified":1616494438707},{"_id":"public/images/graphics6/graphics6_Ambient.png","hash":"8ad4106e0dd925e69ea16fb8b7c801883f15a9d1","modified":1616494438707},{"_id":"public/images/graphics6/graphics6_Specular.png","hash":"104fdc6ee7038d87410b8f68f80c948db5840a19","modified":1616494438707},{"_id":"public/images/graphics6/graphics6_banner.jpg","hash":"eb6e62e9b30bd8733a14226a8a318ddd3047e746","modified":1616494438707},{"_id":"public/images/graphics4/graphics4_banner.png","hash":"95a3b203897307e7aec529c881f1f9c8874493b1","modified":1616494438707},{"_id":"public/images/graphics4/graphics4_bound_box.png","hash":"42c7ad20384c763210c2f3c9755e620d47d74baf","modified":1616494438707},{"_id":"public/images/graphics4/graphics4_bresenham.png","hash":"98314d14ea732c093eef8a6350fe7cd5f4365b25","modified":1616494438707},{"_id":"public/images/graphics4/graphics4_inside.png","hash":"e2e3eea5291b88a0231e54fdbb811a2a945aa372","modified":1616494438707},{"_id":"public/images/graphics4/graphics4_lines.png","hash":"ee409c72df646791e566f290562b442f32e029c0","modified":1616494438707},{"_id":"public/images/graphics4/graphics4_pixels.png","hash":"418dc105a6cbf84e4b13294f6e5f8e505bc6bef9","modified":1616494438707},{"_id":"public/images/graphics4/graphics4_sample.png","hash":"1785a9591ce6fbb287e4512d4e33777d947fc977","modified":1616494438707},{"_id":"public/images/graphics7/graphics7_vertex.jpg","hash":"b49cd12eb2bde7aec047aa34f7e9590991862fdf","modified":1616494438707},{"_id":"public/images/graphics7/graphics7_zbuffer.jpg","hash":"e9cf5be0e691ee24854fb6cd86835e28b885cc69","modified":1616494438707},{"_id":"public/images/graphics7.5/Areal_coordinates.png","hash":"416f024d8f45031d1f8c8eaea530173c29f3f88b","modified":1616494438707},{"_id":"public/images/graphics7.5/graphics7.5_banner.png","hash":"9086ecf67506301c3e03aa5b39d9d178195db16c","modified":1616494438707},{"_id":"public/images/latex/latex1_graph2.png","hash":"adeafb354599b21eab18179a37efe22d321db754","modified":1616494438707},{"_id":"public/images/latex/latex1_graph4.png","hash":"5a28ff28638f940672333fdb20021acb63aad9b5","modified":1616494438707},{"_id":"public/images/latex/latex1_graph3.png","hash":"9aac9d36160a2226f46a821ad6ade7c35385d443","modified":1616494438707},{"_id":"public/images/latex/latex1_graph5.png","hash":"92c02f0ba26533621f3afe8a788d26d76c352f0d","modified":1616494438707},{"_id":"public/img/computer_tools.jpg","hash":"1a4d0dfc2a1e78f14e2048ca7bdd80feccceb866","modified":1616494438707},{"_id":"public/images/graphics3/graphics3_banner.png","hash":"822b9a3a4527ecd7394662daf9e3e1670e18b83c","modified":1616494438707},{"_id":"public/images/graphics6/graphics6_Diffuse.png","hash":"39aa14a22576dd764266f2599908fc26dc2cfaea","modified":1616494438707},{"_id":"public/images/graphics6/graphics6_diffuse_function.png","hash":"5f7186584bdaebc84bb5116302691b922ec02daf","modified":1616494438707},{"_id":"public/images/graphics6/graphics6_lambertian.png","hash":"b0e2431d719213c75073e8a643c23a1b43cfdfd4","modified":1616494438707},{"_id":"public/images/graphics6/graphics6_spe_param.png","hash":"916d5fca80df77a9f44d1575d09aec5267ded9cf","modified":1616494438707},{"_id":"public/images/graphics5/graphics5_Moiré.jpg","hash":"caed5bedb970e632662792c256fc47db4c00018b","modified":1616494438707},{"_id":"public/images/graphics5/graphics5_SSAA.png","hash":"4ae7f970a6e47493726c1411973e09a59fff144f","modified":1616494438707},{"_id":"public/images/graphics5/graphics5_banner.jpg","hash":"f721a393d1ec3b3c30a1f07307a3edde80748a9c","modified":1616494438707},{"_id":"public/images/graphics5/graphics5_sample.png","hash":"f257764d7f935cb240fb9f989cbf50f4a33a5ae9","modified":1616494438707},{"_id":"public/images/graphics7/graphics7_rasterization.jpg","hash":"506d40c10facfa0478d19d1fba0a8d43a750cc1a","modified":1616494438707},{"_id":"public/images/graphics7/graphics7_shading.jpg","hash":"ad5ce532051ef7c082ad2b646e944f06d554957e","modified":1616494438707},{"_id":"public/images/latex/latex1_graph1.png","hash":"ab13b12abe952ac3bdb4d8d537b1ce6de5e35872","modified":1616494438707},{"_id":"public/images/graphics8/mipmap.png","hash":"5071bb8827d7d42af6a7ad4ede6e8a1e531938be","modified":1616494438707},{"_id":"public/images/graphics8/texture_mapping_lamp.png","hash":"0a49db21e977858a03dfb60e570b657f08153ff2","modified":1616494438707},{"_id":"public/images/graphics5/graphics5_aliasing.png","hash":"7b236d2a7c66167926db7acda42b8f43a40e98fa","modified":1616494438707},{"_id":"public/images/graphics5/graphics5_frequency.png","hash":"1bc1e776b996b49005d688c8a5e20bdc3722a213","modified":1616494438707},{"_id":"public/images/graphics8/graphics8_banner.jpeg","hash":"d81252df3c378df0bc6917cdfa4b838a2531eb9e","modified":1616494438707},{"_id":"public/images/graphics8/mipmap_limitations.png","hash":"8401011e4919962705552a07615617f3c7bf005f","modified":1616494438707},{"_id":"public/images/graphics8/monster_uv.png","hash":"d567e0625b3cfc1f8cc6c2677951833e3271063b","modified":1616494438707},{"_id":"public/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1616494438707},{"_id":"public/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1616494438707},{"_id":"public/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1616494438707},{"_id":"public/js/local-search.js","hash":"5e36b80ad9594246f78da743a742527382b7cd50","modified":1616494438707},{"_id":"public/js/main.js","hash":"863a68ca6fac43dc2a42f6ffcad2ccbdd7d249cc","modified":1616494438707},{"_id":"public/js/utils.js","hash":"24b1f871f74f9bed7ac59bb0ad28a60f1491e4c2","modified":1616494438707},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1616494438707},{"_id":"public/css/main.css","hash":"038f25decff0b72baa21874a140e527c62c5d6c1","modified":1616494438707},{"_id":"public/images/graphics7/graphics7_banner.png","hash":"59ef68ec00ba77883217f0e810dc102d6c3baf71","modified":1616494438707},{"_id":"public/images/graphics8/bilinear3.png","hash":"0f50dfd987372db59a578b06986335c5696e7d19","modified":1616494438707},{"_id":"public/images/graphics8/filter_better.png","hash":"ee0e53e3b09ba8d9f48d973dd4a5bdae73d8248c","modified":1616494438707},{"_id":"public/images/graphics8/monster.png","hash":"f440f9db4badd000be3bc0769d5e2af7ba1e3c5d","modified":1616494438707},{"_id":"public/images/graphics6/graphics6_shading.png","hash":"49e328545eb0d1838657c572bad0d352da6d951b","modified":1616494438707},{"_id":"public/images/graphics5/graphics5_reconstructed.png","hash":"ecdd4b9e8a2ead12ef00696f9c6efa62609872be","modified":1616494438707},{"_id":"public/images/graphics8/anisotropic.png","hash":"9b95e6e37f4c1fdd92d602cd672a05386e22fbf0","modified":1616494438707},{"_id":"public/images/graphics8/bilinear2.png","hash":"bc054e95464ed4baed6929c8954323fe6f47ebbc","modified":1616494438707},{"_id":"public/images/graphics8/integerD.png","hash":"35e377ea956c0b5079d82692dc8e7eb63bb0cab0","modified":1616494438707},{"_id":"public/images/graphics8/trilinearD.png","hash":"6f1097d74a0f3eff775c41052acd600b3e9a772b","modified":1616494438707},{"_id":"public/img/cyber1.jpg","hash":"d4ca7f895b0ef976679b4866227b94884c04ecb5","modified":1616494438707},{"_id":"public/img/cyber3.jpg","hash":"94d3c568972fe23f9f539b690bd263de9245dc0f","modified":1616494438707},{"_id":"public/images/graphics6/graphics6_combine.png","hash":"7cff98c34ef0cb373a8d7af87a7c92e1db391663","modified":1616494438707},{"_id":"public/images/graphics6/graphics6_painter.png","hash":"be49881d065b0caf5dba335185373013850f2eeb","modified":1616494438707},{"_id":"public/images/graphics6/graphics6_energy.png","hash":"f4dfb23bb10fd8df206c0776bdcfef9aa7775fd5","modified":1616494438707},{"_id":"public/images/graphics8/screen_to_texture.png","hash":"68c5bb6c2218efce465b6d8dc64ba18d920ea083","modified":1616494438707},{"_id":"public/images/graphics8/ssaa.png","hash":"db50f5b4807146e212b0b4fcfddf339335845aee","modified":1616494438707},{"_id":"public/images/latex/latex_head.png","hash":"2ebc6e6e8130d5a7f1b8f4f91318d17a800cb659","modified":1616494438707},{"_id":"public/images/graphics8/bilinear1.png","hash":"b61c756d0393e0b2b486f012a918e398e6bfa75c","modified":1616494438707},{"_id":"public/images/graphics8/huge_texture.png","hash":"2663cf608d113cb384bddb810eecedb916109ccb","modified":1616494438707},{"_id":"public/images/graphics8/projection.png","hash":"eabbf4fc84a7e6c259cc97ba07e2dd33cba12477","modified":1616494438707},{"_id":"public/images/graphics8/trilinear.png","hash":"b06ce5563984ea5604821fdb9a5eb5e14b4bd22d","modified":1616494438707},{"_id":"public/img/spaceBanner.jpg","hash":"e6a9ecd066b8968bb32900fe0aef78defd728e5f","modified":1616494438707},{"_id":"public/images/graphics5/graphics5_jaggies.png","hash":"d246ef0d5edb456b279e6fc85fef12c9ea37b6b9","modified":1616494438707},{"_id":"public/images/graphics8/tiny_texture.png","hash":"4e577f13b7a80b836ebd08fa85a42fb826b49956","modified":1616494438707},{"_id":"public/img/code_image.png","hash":"201f6e216dd369afe5c210f5052d44a4010f70cd","modified":1616494438707},{"_id":"public/img/cyber2.jpg","hash":"35788ca04003ec6699da9dda38b6364504fd5e62","modified":1616494438707},{"_id":"public/images/graphics8/texture_code.png","hash":"53493d54d5e91cce5686000a1fe1cde5da244287","modified":1616494438707},{"_id":"public/images/graphics7.5/barycentric_coordinates.png","hash":"3f4b6aca3cd037cbde651b979386625620b13c45","modified":1616494438707},{"_id":"public/images/graphics8/footprint.png","hash":"0d56a4704f2abbc48d4107bd23849354212e3add","modified":1616494438707},{"_id":"public/images/graphics8/earth_mapping.png","hash":"2ddc584c91d33c869192799e665ffb4fdd1518ab","modified":1616494438707},{"_id":"public/images/graphics8/levelD.png","hash":"2c2ac49da12d2fa3dbdcf887d667e552ee2e61f6","modified":1616494438707}],"Category":[{"name":"GAMES101","_id":"ckmlv1wa20003nwqcfoose1ck"},{"name":"latex","_id":"ckmlv1wan0018nwqch8h08hwj"}],"Data":[],"Page":[{"title":"about","date":"2020-02-23T11:20:33.000Z","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-02-23 19:20:33\nlayout: about\n---","updated":"2020-08-10T05:27:41.740Z","path":"about/index.html","comments":1,"_id":"ckmlv1w9t0000nwqce88ihw1w","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"计算机图形学1 —— 线性变换","index_img":"/images/graphics1/graphics1_banner.jpeg","date":"2020-08-10T03:09:11.000Z","math":true,"_content":"\n## 摘要\n在图形学中，图形位置形态的数学定义是坐标中的一个个坐标点的集合，因此图形的变换操作通过数学计算来进行。为了简化计算思路，通常我们会将这些变化通过线性代数的方式抽象为变换矩阵 (Transformation Marices)。一切物体的缩放，旋转，位移，都可以通过变换矩阵作用得到。当我们确定好了某种变化的变换矩阵后，可以将其应用在任何其他图形上。本文将介绍基本图形变化中如何利用变换矩阵来进行图形变换。\n\n## 2D线性变换\n在2D图形中，我们规定 $[x, y]^T$ 为图形上的任意一个点（也可以看作是一个二维向量），2D基于原点的线性变化可以被定义为向量 $[x, y]^T$ 左乘变换矩阵的数学表示：\n\n$$\n\\begin{bmatrix}\n a_{11} & a_{12}\\\\\n a_{21} & a_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\n x \\\\\n y\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n a_{11}x & a_{12}y\\\\\n a_{21}x & a_{22}y\n\\end{bmatrix}\n$$\n\n### 缩放（scale）\n缩放操作是将图形中所有点的坐标整体放大或者缩小某个数值，如下图所示的变换分别将$x, y$分别缩小了0.5:\n\n![](/images/graphics1/graphics1_scale.png)\n$[x, y]^T$经过变换后表示为$[x\\prime, y\\prime]^T$，经过变化后的值可以表示为：\n$$\nx\\prime = 0.5 \\times x + 0 \\times y\n$$\n\n$$\ny\\prime = 0 \\times x + 0.5 \\times y\n$$\n\n上述操作可以使用变换矩阵表示为：\n$$\nscale(s_x, s_y)\n= \n\\begin{bmatrix}\n s_x & 0\\\\\n 0 & s_y\n\\end{bmatrix} \n$$\n\n### 剪切（Shear）\n剪切变换可以简单理解为将图形的一段固定，将其对端沿着固定方向拉动。以固定x轴为例：\n![](/images/graphics1/graphics1_shear.png)\n所有点的\b$y$值保持不变，x坐标加上了对应的y值，经过变化后的值表示为：\n$$\nx\\prime =  x + 1 \\times y\n$$\n\n$$\ny\\prime = 0 \\times x + y\n$$\n\n上述操作可以使用变换矩阵表示为：\n$$\nshearX(s)\n= \n\\begin{bmatrix}\n 1 & s\\\\\n 0 & 1\n\\end{bmatrix} \n$$\n\n$$\nshearY(s)\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n s & 1\n\\end{bmatrix} \n$$\n\n### 翻转（reflection）\n翻转一般是通过将某个坐标轴的所有值取反得到的，其变换矩阵可以表示为：\n上述操作可以使用变换矩阵表示为：\n$$\nreflectionY\n= \n\\begin{bmatrix}\n -1 & 0\\\\\n 0 & 1\n\\end{bmatrix} \n$$\n\n$$\nreflectionX\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n 0 & -1\n\\end{bmatrix} \n$$\n以X轴翻转为例，经过变化矩阵计算后，图形变换如下：\n![](/images/graphics1/graphics1_reflection.png)\n\n### 旋转（rotate）\n旋转的几何意义很容易理解，图形绕着原点逆时针旋转，但是数学上的变换关系并没有上述几种变换直观。为了便于理解，我们先假定图形中的一个任意向量 $\\vec{a}$ ，它与x轴的夹角为$\\alpha$，坐标为 $[x_a, y_a]$ 。向量的长度表示为  $r^2 = x_a^2 + y_a^2$ ，因此其坐标可以表示为：\n$$\nx_a = rcos\\alpha\n$$\n$$\ny_a = rsin\\alpha\n$$\n当 $\\vec{a}$ 旋转了任意角度 $\\varphi$ 之后得到 $\\vec{b}$，此时 $\\vec{b}$ 与x轴的夹角为 $(\\alpha + \\varphi)$，坐标为$[x_b, y_b]$ 被表示为：\n$$\nx_b = rcos(\\alpha + \\varphi) = rcos\\alpha cos\\varphi - rsin\\alpha sin\\varphi\n$$\n$$\ny_b = rsin(\\alpha + \\varphi) = rsin\\alpha cos\\varphi + r sin\\alpha sin\\varphi\n$$\n\n根据$x_a = rcos\\alpha$以及$y_a = rsin\\alpha$我们可以化简得到：\n$$\nx_b = x_a cos\\varphi - y_a sin\\varphi\n$$\n$$\ny_b = y_a cos\\varphi + x_a sin\\varphi\n$$\n\n变换矩阵可以表示为：\n$$\nrotate(\\varphi) = \n\\begin{bmatrix}\n cos\\varphi & -sin\\varphi\\\\\n sin\\varphi & cos\\varphi\n\\end{bmatrix} \n$$\n\n举一个简单的旋转的例子，让图形逆时针旋转$\\pi/4$，变换矩阵的值为：\n$$\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi\\\\\nsin\\varphi & cos\\varphi\n\\end{bmatrix}\n= \n\\begin{bmatrix}\n0.707 & -0.707\\\\\n0.707 & 0.707\n\\end{bmatrix}\n$$\n图形坐标经过计算后的样式如下：\n![](/images/graphics1/graphics1_rotate.png)\n\n\n## 3D线性变换\n了解了2D线性变换之后，3D线性变换的推倒思路是一致的，仅仅是多增加了一个纬度的判断罢了。\n\n### 缩放、剪切、翻转\n3D缩放比较简单，直接通过2D缩放进行扩展：\n$$\nscale(s_x, s_y, s_z) = \n\\begin{bmatrix}\ns_x & 0 & 0\\\\\n0 & s_y & 0\\\\\n0 & 0 & s_z\n\\end{bmatrix}\n$$\n3D剪切也可以通过2D剪切做类似的扩展：\n$$\nshearX(d_y, d_z) = \n\\begin{bmatrix}\n1 & d_y & d_z\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n\n3D的旋转稍稍复杂一点点，因为在3D场景下旋转可以是以原点为中心绕着任意轴进行旋转。在2D中是由x轴向y轴旋转，换算到3D空间中就是绕着z轴进行旋转(绕z轴，z的值不会发生变化，因此变换矩阵第三行没有变化)：\n$$\nrotateZ(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix} \n$$\n\n绕着x轴的旋转可以理解为在2D场景下的yz平面，由y轴转向z轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：\n$$\nrotateX(\\varphi) = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & cos\\varphi & -sin\\varphi\\\\\n0 & sin\\varphi & cos\\varphi\n\\end{bmatrix} \n$$\n\n\n绕着y轴的旋转可以理解为在2D场景下的xz平面，由z轴转向x轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：\n$$\nrotateY(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & 0 & sin\\varphi\\\\\n0 & 1 & 0\\\\\n-sin\\varphi & 0  & cos\\varphi\n\\end{bmatrix} \n$$\n","source":"_posts/ComputerGraphics1.md","raw":"---\ntitle: 计算机图形学1 —— 线性变换\ntags: [计算机图形学, 线性代数]\ncategories: [GAMES101]\nindex_img: /images/graphics1/graphics1_banner.jpeg\ndate: 2020-08-10 11:09:11\nmath: true\n---\n\n## 摘要\n在图形学中，图形位置形态的数学定义是坐标中的一个个坐标点的集合，因此图形的变换操作通过数学计算来进行。为了简化计算思路，通常我们会将这些变化通过线性代数的方式抽象为变换矩阵 (Transformation Marices)。一切物体的缩放，旋转，位移，都可以通过变换矩阵作用得到。当我们确定好了某种变化的变换矩阵后，可以将其应用在任何其他图形上。本文将介绍基本图形变化中如何利用变换矩阵来进行图形变换。\n\n## 2D线性变换\n在2D图形中，我们规定 $[x, y]^T$ 为图形上的任意一个点（也可以看作是一个二维向量），2D基于原点的线性变化可以被定义为向量 $[x, y]^T$ 左乘变换矩阵的数学表示：\n\n$$\n\\begin{bmatrix}\n a_{11} & a_{12}\\\\\n a_{21} & a_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\n x \\\\\n y\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n a_{11}x & a_{12}y\\\\\n a_{21}x & a_{22}y\n\\end{bmatrix}\n$$\n\n### 缩放（scale）\n缩放操作是将图形中所有点的坐标整体放大或者缩小某个数值，如下图所示的变换分别将$x, y$分别缩小了0.5:\n\n![](/images/graphics1/graphics1_scale.png)\n$[x, y]^T$经过变换后表示为$[x\\prime, y\\prime]^T$，经过变化后的值可以表示为：\n$$\nx\\prime = 0.5 \\times x + 0 \\times y\n$$\n\n$$\ny\\prime = 0 \\times x + 0.5 \\times y\n$$\n\n上述操作可以使用变换矩阵表示为：\n$$\nscale(s_x, s_y)\n= \n\\begin{bmatrix}\n s_x & 0\\\\\n 0 & s_y\n\\end{bmatrix} \n$$\n\n### 剪切（Shear）\n剪切变换可以简单理解为将图形的一段固定，将其对端沿着固定方向拉动。以固定x轴为例：\n![](/images/graphics1/graphics1_shear.png)\n所有点的\b$y$值保持不变，x坐标加上了对应的y值，经过变化后的值表示为：\n$$\nx\\prime =  x + 1 \\times y\n$$\n\n$$\ny\\prime = 0 \\times x + y\n$$\n\n上述操作可以使用变换矩阵表示为：\n$$\nshearX(s)\n= \n\\begin{bmatrix}\n 1 & s\\\\\n 0 & 1\n\\end{bmatrix} \n$$\n\n$$\nshearY(s)\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n s & 1\n\\end{bmatrix} \n$$\n\n### 翻转（reflection）\n翻转一般是通过将某个坐标轴的所有值取反得到的，其变换矩阵可以表示为：\n上述操作可以使用变换矩阵表示为：\n$$\nreflectionY\n= \n\\begin{bmatrix}\n -1 & 0\\\\\n 0 & 1\n\\end{bmatrix} \n$$\n\n$$\nreflectionX\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n 0 & -1\n\\end{bmatrix} \n$$\n以X轴翻转为例，经过变化矩阵计算后，图形变换如下：\n![](/images/graphics1/graphics1_reflection.png)\n\n### 旋转（rotate）\n旋转的几何意义很容易理解，图形绕着原点逆时针旋转，但是数学上的变换关系并没有上述几种变换直观。为了便于理解，我们先假定图形中的一个任意向量 $\\vec{a}$ ，它与x轴的夹角为$\\alpha$，坐标为 $[x_a, y_a]$ 。向量的长度表示为  $r^2 = x_a^2 + y_a^2$ ，因此其坐标可以表示为：\n$$\nx_a = rcos\\alpha\n$$\n$$\ny_a = rsin\\alpha\n$$\n当 $\\vec{a}$ 旋转了任意角度 $\\varphi$ 之后得到 $\\vec{b}$，此时 $\\vec{b}$ 与x轴的夹角为 $(\\alpha + \\varphi)$，坐标为$[x_b, y_b]$ 被表示为：\n$$\nx_b = rcos(\\alpha + \\varphi) = rcos\\alpha cos\\varphi - rsin\\alpha sin\\varphi\n$$\n$$\ny_b = rsin(\\alpha + \\varphi) = rsin\\alpha cos\\varphi + r sin\\alpha sin\\varphi\n$$\n\n根据$x_a = rcos\\alpha$以及$y_a = rsin\\alpha$我们可以化简得到：\n$$\nx_b = x_a cos\\varphi - y_a sin\\varphi\n$$\n$$\ny_b = y_a cos\\varphi + x_a sin\\varphi\n$$\n\n变换矩阵可以表示为：\n$$\nrotate(\\varphi) = \n\\begin{bmatrix}\n cos\\varphi & -sin\\varphi\\\\\n sin\\varphi & cos\\varphi\n\\end{bmatrix} \n$$\n\n举一个简单的旋转的例子，让图形逆时针旋转$\\pi/4$，变换矩阵的值为：\n$$\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi\\\\\nsin\\varphi & cos\\varphi\n\\end{bmatrix}\n= \n\\begin{bmatrix}\n0.707 & -0.707\\\\\n0.707 & 0.707\n\\end{bmatrix}\n$$\n图形坐标经过计算后的样式如下：\n![](/images/graphics1/graphics1_rotate.png)\n\n\n## 3D线性变换\n了解了2D线性变换之后，3D线性变换的推倒思路是一致的，仅仅是多增加了一个纬度的判断罢了。\n\n### 缩放、剪切、翻转\n3D缩放比较简单，直接通过2D缩放进行扩展：\n$$\nscale(s_x, s_y, s_z) = \n\\begin{bmatrix}\ns_x & 0 & 0\\\\\n0 & s_y & 0\\\\\n0 & 0 & s_z\n\\end{bmatrix}\n$$\n3D剪切也可以通过2D剪切做类似的扩展：\n$$\nshearX(d_y, d_z) = \n\\begin{bmatrix}\n1 & d_y & d_z\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n\n3D的旋转稍稍复杂一点点，因为在3D场景下旋转可以是以原点为中心绕着任意轴进行旋转。在2D中是由x轴向y轴旋转，换算到3D空间中就是绕着z轴进行旋转(绕z轴，z的值不会发生变化，因此变换矩阵第三行没有变化)：\n$$\nrotateZ(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix} \n$$\n\n绕着x轴的旋转可以理解为在2D场景下的yz平面，由y轴转向z轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：\n$$\nrotateX(\\varphi) = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & cos\\varphi & -sin\\varphi\\\\\n0 & sin\\varphi & cos\\varphi\n\\end{bmatrix} \n$$\n\n\n绕着y轴的旋转可以理解为在2D场景下的xz平面，由z轴转向x轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：\n$$\nrotateY(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & 0 & sin\\varphi\\\\\n0 & 1 & 0\\\\\n-sin\\varphi & 0  & cos\\varphi\n\\end{bmatrix} \n$$\n","slug":"ComputerGraphics1","published":1,"updated":"2020-10-03T07:40:23.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1w9z0001nwqc2fn70ljb","content":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>在图形学中，图形位置形态的数学定义是坐标中的一个个坐标点的集合，因此图形的变换操作通过数学计算来进行。为了简化计算思路，通常我们会将这些变化通过线性代数的方式抽象为变换矩阵 (Transformation Marices)。一切物体的缩放，旋转，位移，都可以通过变换矩阵作用得到。当我们确定好了某种变化的变换矩阵后，可以将其应用在任何其他图形上。本文将介绍基本图形变化中如何利用变换矩阵来进行图形变换。</p>\n<h2 id=\"2D线性变换\"><a href=\"#2D线性变换\" class=\"headerlink\" title=\"2D线性变换\"></a>2D线性变换</h2><p>在2D图形中，我们规定 $[x, y]^T$ 为图形上的任意一个点（也可以看作是一个二维向量），2D基于原点的线性变化可以被定义为向量 $[x, y]^T$ 左乘变换矩阵的数学表示：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n a_{11} & a_{12}\\\\\n a_{21} & a_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\n x \\\\\n y\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n a_{11}x & a_{12}y\\\\\n a_{21}x & a_{22}y\n\\end{bmatrix}</script><h3 id=\"缩放（scale）\"><a href=\"#缩放（scale）\" class=\"headerlink\" title=\"缩放（scale）\"></a>缩放（scale）</h3><p>缩放操作是将图形中所有点的坐标整体放大或者缩小某个数值，如下图所示的变换分别将$x, y$分别缩小了0.5:</p>\n<p><img src=\"/images/graphics1/graphics1_scale.png\" alt=\"\"><br>$[x, y]^T$经过变换后表示为$[x\\prime, y\\prime]^T$，经过变化后的值可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nx\\prime = 0.5 \\times x + 0 \\times y</script><script type=\"math/tex; mode=display\">\ny\\prime = 0 \\times x + 0.5 \\times y</script><p>上述操作可以使用变换矩阵表示为：</p>\n<script type=\"math/tex; mode=display\">\nscale(s_x, s_y)\n= \n\\begin{bmatrix}\n s_x & 0\\\\\n 0 & s_y\n\\end{bmatrix}</script><h3 id=\"剪切（Shear）\"><a href=\"#剪切（Shear）\" class=\"headerlink\" title=\"剪切（Shear）\"></a>剪切（Shear）</h3><p>剪切变换可以简单理解为将图形的一段固定，将其对端沿着固定方向拉动。以固定x轴为例：<br><img src=\"/images/graphics1/graphics1_shear.png\" alt=\"\"><br>所有点的\b$y$值保持不变，x坐标加上了对应的y值，经过变化后的值表示为：</p>\n<script type=\"math/tex; mode=display\">\nx\\prime =  x + 1 \\times y</script><script type=\"math/tex; mode=display\">\ny\\prime = 0 \\times x + y</script><p>上述操作可以使用变换矩阵表示为：</p>\n<script type=\"math/tex; mode=display\">\nshearX(s)\n= \n\\begin{bmatrix}\n 1 & s\\\\\n 0 & 1\n\\end{bmatrix}</script><script type=\"math/tex; mode=display\">\nshearY(s)\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n s & 1\n\\end{bmatrix}</script><h3 id=\"翻转（reflection）\"><a href=\"#翻转（reflection）\" class=\"headerlink\" title=\"翻转（reflection）\"></a>翻转（reflection）</h3><p>翻转一般是通过将某个坐标轴的所有值取反得到的，其变换矩阵可以表示为：<br>上述操作可以使用变换矩阵表示为：</p>\n<script type=\"math/tex; mode=display\">\nreflectionY\n= \n\\begin{bmatrix}\n -1 & 0\\\\\n 0 & 1\n\\end{bmatrix}</script><script type=\"math/tex; mode=display\">\nreflectionX\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n 0 & -1\n\\end{bmatrix}</script><p>以X轴翻转为例，经过变化矩阵计算后，图形变换如下：<br><img src=\"/images/graphics1/graphics1_reflection.png\" alt=\"\"></p>\n<h3 id=\"旋转（rotate）\"><a href=\"#旋转（rotate）\" class=\"headerlink\" title=\"旋转（rotate）\"></a>旋转（rotate）</h3><p>旋转的几何意义很容易理解，图形绕着原点逆时针旋转，但是数学上的变换关系并没有上述几种变换直观。为了便于理解，我们先假定图形中的一个任意向量 $\\vec{a}$ ，它与x轴的夹角为$\\alpha$，坐标为 $[x_a, y_a]$ 。向量的长度表示为  $r^2 = x_a^2 + y_a^2$ ，因此其坐标可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nx_a = rcos\\alpha</script><script type=\"math/tex; mode=display\">\ny_a = rsin\\alpha</script><p>当 $\\vec{a}$ 旋转了任意角度 $\\varphi$ 之后得到 $\\vec{b}$，此时 $\\vec{b}$ 与x轴的夹角为 $(\\alpha + \\varphi)$，坐标为$[x_b, y_b]$ 被表示为：</p>\n<script type=\"math/tex; mode=display\">\nx_b = rcos(\\alpha + \\varphi) = rcos\\alpha cos\\varphi - rsin\\alpha sin\\varphi</script><script type=\"math/tex; mode=display\">\ny_b = rsin(\\alpha + \\varphi) = rsin\\alpha cos\\varphi + r sin\\alpha sin\\varphi</script><p>根据$x_a = rcos\\alpha$以及$y_a = rsin\\alpha$我们可以化简得到：</p>\n<script type=\"math/tex; mode=display\">\nx_b = x_a cos\\varphi - y_a sin\\varphi</script><script type=\"math/tex; mode=display\">\ny_b = y_a cos\\varphi + x_a sin\\varphi</script><p>变换矩阵可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nrotate(\\varphi) = \n\\begin{bmatrix}\n cos\\varphi & -sin\\varphi\\\\\n sin\\varphi & cos\\varphi\n\\end{bmatrix}</script><p>举一个简单的旋转的例子，让图形逆时针旋转$\\pi/4$，变换矩阵的值为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi\\\\\nsin\\varphi & cos\\varphi\n\\end{bmatrix}\n= \n\\begin{bmatrix}\n0.707 & -0.707\\\\\n0.707 & 0.707\n\\end{bmatrix}</script><p>图形坐标经过计算后的样式如下：<br><img src=\"/images/graphics1/graphics1_rotate.png\" alt=\"\"></p>\n<h2 id=\"3D线性变换\"><a href=\"#3D线性变换\" class=\"headerlink\" title=\"3D线性变换\"></a>3D线性变换</h2><p>了解了2D线性变换之后，3D线性变换的推倒思路是一致的，仅仅是多增加了一个纬度的判断罢了。</p>\n<h3 id=\"缩放、剪切、翻转\"><a href=\"#缩放、剪切、翻转\" class=\"headerlink\" title=\"缩放、剪切、翻转\"></a>缩放、剪切、翻转</h3><p>3D缩放比较简单，直接通过2D缩放进行扩展：</p>\n<script type=\"math/tex; mode=display\">\nscale(s_x, s_y, s_z) = \n\\begin{bmatrix}\ns_x & 0 & 0\\\\\n0 & s_y & 0\\\\\n0 & 0 & s_z\n\\end{bmatrix}</script><p>3D剪切也可以通过2D剪切做类似的扩展：</p>\n<script type=\"math/tex; mode=display\">\nshearX(d_y, d_z) = \n\\begin{bmatrix}\n1 & d_y & d_z\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>3D的旋转稍稍复杂一点点，因为在3D场景下旋转可以是以原点为中心绕着任意轴进行旋转。在2D中是由x轴向y轴旋转，换算到3D空间中就是绕着z轴进行旋转(绕z轴，z的值不会发生变化，因此变换矩阵第三行没有变化)：</p>\n<script type=\"math/tex; mode=display\">\nrotateZ(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>绕着x轴的旋转可以理解为在2D场景下的yz平面，由y轴转向z轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：</p>\n<script type=\"math/tex; mode=display\">\nrotateX(\\varphi) = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & cos\\varphi & -sin\\varphi\\\\\n0 & sin\\varphi & cos\\varphi\n\\end{bmatrix}</script><p>绕着y轴的旋转可以理解为在2D场景下的xz平面，由z轴转向x轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：</p>\n<script type=\"math/tex; mode=display\">\nrotateY(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & 0 & sin\\varphi\\\\\n0 & 1 & 0\\\\\n-sin\\varphi & 0  & cos\\varphi\n\\end{bmatrix}</script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>在图形学中，图形位置形态的数学定义是坐标中的一个个坐标点的集合，因此图形的变换操作通过数学计算来进行。为了简化计算思路，通常我们会将这些变化通过线性代数的方式抽象为变换矩阵 (Transformation Marices)。一切物体的缩放，旋转，位移，都可以通过变换矩阵作用得到。当我们确定好了某种变化的变换矩阵后，可以将其应用在任何其他图形上。本文将介绍基本图形变化中如何利用变换矩阵来进行图形变换。</p>\n<h2 id=\"2D线性变换\"><a href=\"#2D线性变换\" class=\"headerlink\" title=\"2D线性变换\"></a>2D线性变换</h2><p>在2D图形中，我们规定 $[x, y]^T$ 为图形上的任意一个点（也可以看作是一个二维向量），2D基于原点的线性变化可以被定义为向量 $[x, y]^T$ 左乘变换矩阵的数学表示：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n a_{11} & a_{12}\\\\\n a_{21} & a_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\n x \\\\\n y\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n a_{11}x & a_{12}y\\\\\n a_{21}x & a_{22}y\n\\end{bmatrix}</script><h3 id=\"缩放（scale）\"><a href=\"#缩放（scale）\" class=\"headerlink\" title=\"缩放（scale）\"></a>缩放（scale）</h3><p>缩放操作是将图形中所有点的坐标整体放大或者缩小某个数值，如下图所示的变换分别将$x, y$分别缩小了0.5:</p>\n<p><img src=\"/images/graphics1/graphics1_scale.png\" alt=\"\"><br>$[x, y]^T$经过变换后表示为$[x\\prime, y\\prime]^T$，经过变化后的值可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nx\\prime = 0.5 \\times x + 0 \\times y</script><script type=\"math/tex; mode=display\">\ny\\prime = 0 \\times x + 0.5 \\times y</script><p>上述操作可以使用变换矩阵表示为：</p>\n<script type=\"math/tex; mode=display\">\nscale(s_x, s_y)\n= \n\\begin{bmatrix}\n s_x & 0\\\\\n 0 & s_y\n\\end{bmatrix}</script><h3 id=\"剪切（Shear）\"><a href=\"#剪切（Shear）\" class=\"headerlink\" title=\"剪切（Shear）\"></a>剪切（Shear）</h3><p>剪切变换可以简单理解为将图形的一段固定，将其对端沿着固定方向拉动。以固定x轴为例：<br><img src=\"/images/graphics1/graphics1_shear.png\" alt=\"\"><br>所有点的\b$y$值保持不变，x坐标加上了对应的y值，经过变化后的值表示为：</p>\n<script type=\"math/tex; mode=display\">\nx\\prime =  x + 1 \\times y</script><script type=\"math/tex; mode=display\">\ny\\prime = 0 \\times x + y</script><p>上述操作可以使用变换矩阵表示为：</p>\n<script type=\"math/tex; mode=display\">\nshearX(s)\n= \n\\begin{bmatrix}\n 1 & s\\\\\n 0 & 1\n\\end{bmatrix}</script><script type=\"math/tex; mode=display\">\nshearY(s)\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n s & 1\n\\end{bmatrix}</script><h3 id=\"翻转（reflection）\"><a href=\"#翻转（reflection）\" class=\"headerlink\" title=\"翻转（reflection）\"></a>翻转（reflection）</h3><p>翻转一般是通过将某个坐标轴的所有值取反得到的，其变换矩阵可以表示为：<br>上述操作可以使用变换矩阵表示为：</p>\n<script type=\"math/tex; mode=display\">\nreflectionY\n= \n\\begin{bmatrix}\n -1 & 0\\\\\n 0 & 1\n\\end{bmatrix}</script><script type=\"math/tex; mode=display\">\nreflectionX\n= \n\\begin{bmatrix}\n 1 & 0\\\\\n 0 & -1\n\\end{bmatrix}</script><p>以X轴翻转为例，经过变化矩阵计算后，图形变换如下：<br><img src=\"/images/graphics1/graphics1_reflection.png\" alt=\"\"></p>\n<h3 id=\"旋转（rotate）\"><a href=\"#旋转（rotate）\" class=\"headerlink\" title=\"旋转（rotate）\"></a>旋转（rotate）</h3><p>旋转的几何意义很容易理解，图形绕着原点逆时针旋转，但是数学上的变换关系并没有上述几种变换直观。为了便于理解，我们先假定图形中的一个任意向量 $\\vec{a}$ ，它与x轴的夹角为$\\alpha$，坐标为 $[x_a, y_a]$ 。向量的长度表示为  $r^2 = x_a^2 + y_a^2$ ，因此其坐标可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nx_a = rcos\\alpha</script><script type=\"math/tex; mode=display\">\ny_a = rsin\\alpha</script><p>当 $\\vec{a}$ 旋转了任意角度 $\\varphi$ 之后得到 $\\vec{b}$，此时 $\\vec{b}$ 与x轴的夹角为 $(\\alpha + \\varphi)$，坐标为$[x_b, y_b]$ 被表示为：</p>\n<script type=\"math/tex; mode=display\">\nx_b = rcos(\\alpha + \\varphi) = rcos\\alpha cos\\varphi - rsin\\alpha sin\\varphi</script><script type=\"math/tex; mode=display\">\ny_b = rsin(\\alpha + \\varphi) = rsin\\alpha cos\\varphi + r sin\\alpha sin\\varphi</script><p>根据$x_a = rcos\\alpha$以及$y_a = rsin\\alpha$我们可以化简得到：</p>\n<script type=\"math/tex; mode=display\">\nx_b = x_a cos\\varphi - y_a sin\\varphi</script><script type=\"math/tex; mode=display\">\ny_b = y_a cos\\varphi + x_a sin\\varphi</script><p>变换矩阵可以表示为：</p>\n<script type=\"math/tex; mode=display\">\nrotate(\\varphi) = \n\\begin{bmatrix}\n cos\\varphi & -sin\\varphi\\\\\n sin\\varphi & cos\\varphi\n\\end{bmatrix}</script><p>举一个简单的旋转的例子，让图形逆时针旋转$\\pi/4$，变换矩阵的值为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi\\\\\nsin\\varphi & cos\\varphi\n\\end{bmatrix}\n= \n\\begin{bmatrix}\n0.707 & -0.707\\\\\n0.707 & 0.707\n\\end{bmatrix}</script><p>图形坐标经过计算后的样式如下：<br><img src=\"/images/graphics1/graphics1_rotate.png\" alt=\"\"></p>\n<h2 id=\"3D线性变换\"><a href=\"#3D线性变换\" class=\"headerlink\" title=\"3D线性变换\"></a>3D线性变换</h2><p>了解了2D线性变换之后，3D线性变换的推倒思路是一致的，仅仅是多增加了一个纬度的判断罢了。</p>\n<h3 id=\"缩放、剪切、翻转\"><a href=\"#缩放、剪切、翻转\" class=\"headerlink\" title=\"缩放、剪切、翻转\"></a>缩放、剪切、翻转</h3><p>3D缩放比较简单，直接通过2D缩放进行扩展：</p>\n<script type=\"math/tex; mode=display\">\nscale(s_x, s_y, s_z) = \n\\begin{bmatrix}\ns_x & 0 & 0\\\\\n0 & s_y & 0\\\\\n0 & 0 & s_z\n\\end{bmatrix}</script><p>3D剪切也可以通过2D剪切做类似的扩展：</p>\n<script type=\"math/tex; mode=display\">\nshearX(d_y, d_z) = \n\\begin{bmatrix}\n1 & d_y & d_z\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>3D的旋转稍稍复杂一点点，因为在3D场景下旋转可以是以原点为中心绕着任意轴进行旋转。在2D中是由x轴向y轴旋转，换算到3D空间中就是绕着z轴进行旋转(绕z轴，z的值不会发生变化，因此变换矩阵第三行没有变化)：</p>\n<script type=\"math/tex; mode=display\">\nrotateZ(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>绕着x轴的旋转可以理解为在2D场景下的yz平面，由y轴转向z轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：</p>\n<script type=\"math/tex; mode=display\">\nrotateX(\\varphi) = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & cos\\varphi & -sin\\varphi\\\\\n0 & sin\\varphi & cos\\varphi\n\\end{bmatrix}</script><p>绕着y轴的旋转可以理解为在2D场景下的xz平面，由z轴转向x轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：</p>\n<script type=\"math/tex; mode=display\">\nrotateY(\\varphi) = \n\\begin{bmatrix}\ncos\\varphi & 0 & sin\\varphi\\\\\n0 & 1 & 0\\\\\n-sin\\varphi & 0  & cos\\varphi\n\\end{bmatrix}</script>"},{"title":"计算机图形学11 —— 曲面细分","index_img":"/images/graphics7/graphics7_banner.png","date":"2020-10-03T09:09:11.000Z","math":true,"_content":" ","source":"_posts/ComputerGraphics11.md","raw":"---\ntitle: 计算机图形学11 —— 曲面细分 \ntags: [计算机图形学, 几何, 曲面细分]\ncategories: [GAMES101]\nindex_img: /images/graphics7/graphics7_banner.png\ndate: 2020-10-03 17:09:11\nmath: true\n---\n ","slug":"ComputerGraphics11","published":1,"updated":"2020-10-24T08:10:03.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wa10002nwqcbc1kfjyt","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"计算机图形学10 ——  贝塞尔曲线","index_img":"/images/graphics7/graphics7_banner.png","date":"2020-10-03T09:09:11.000Z","math":true,"_content":" ","source":"_posts/ComputerGraphics10.md","raw":"---\ntitle: 计算机图形学10 ——  贝塞尔曲线\ntags: [计算机图形学, 几何, 贝塞尔曲线]\ncategories: [GAMES101]\nindex_img: /images/graphics7/graphics7_banner.png\ndate: 2020-10-03 17:09:11\nmath: true\n---\n ","slug":"ComputerGraphics10","published":1,"updated":"2020-10-24T08:10:24.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wa40005nwqc17hu88z5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"计算机图形学13 -","index_img":"/images/graphics7/graphics7_banner.png","date":"2020-10-03T09:09:11.000Z","math":true,"_content":" ","source":"_posts/ComputerGraphics13.md","raw":"---\ntitle: 计算机图形学13 -  \ntags: [计算机图形学, 光线追踪, 阴影]\ncategories: [GAMES101]\nindex_img: /images/graphics7/graphics7_banner.png\ndate: 2020-10-03 17:09:11\nmath: true\n---\n ","slug":"ComputerGraphics13","published":1,"updated":"2020-10-25T07:12:57.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wa50006nwqc18zp7i40","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"---\ntitle: 计算机图形学12 —— 阴影和光线追踪介绍\ntags: [计算机图形学, 光线追踪, 阴影]\ncategories: [GAMES101]\nindex_img: /images/graphics7/graphics7_banner.png\ndate: 2020-10-03 17:09:11\n\n\n\n## 阴影光栅化方式表示\n\n## 光线追踪简介\n\n## whitted ray tracing\n\n## calculate intersection\n\n## Axis-Aligned Bounding box","source":"_posts/ComputerGraphics12.md","raw":"---\ntitle: 计算机图形学12 —— 阴影和光线追踪介绍\ntags: [计算机图形学, 光线追踪, 阴影]\ncategories: [GAMES101]\nindex_img: /images/graphics7/graphics7_banner.png\ndate: 2020-10-03 17:09:11\n\n\n\n## 阴影光栅化方式表示\n\n## 光线追踪简介\n\n## whitted ray tracing\n\n## calculate intersection\n\n## Axis-Aligned Bounding box","slug":"ComputerGraphics12","published":1,"date":"2020-10-25T07:09:49.175Z","updated":"2020-10-27T11:28:05.321Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wa60007nwqcajj68ksz","content":"<hr>\n<p>title: 计算机图形学12 —— 阴影和光线追踪介绍<br>tags: [计算机图形学, 光线追踪, 阴影]<br>categories: [GAMES101]<br>index_img: /images/graphics7/graphics7_banner.png<br>date: 2020-10-03 17:09:11</p>\n<h2 id=\"阴影光栅化方式表示\"><a href=\"#阴影光栅化方式表示\" class=\"headerlink\" title=\"阴影光栅化方式表示\"></a>阴影光栅化方式表示</h2><h2 id=\"光线追踪简介\"><a href=\"#光线追踪简介\" class=\"headerlink\" title=\"光线追踪简介\"></a>光线追踪简介</h2><h2 id=\"whitted-ray-tracing\"><a href=\"#whitted-ray-tracing\" class=\"headerlink\" title=\"whitted ray tracing\"></a>whitted ray tracing</h2><h2 id=\"calculate-intersection\"><a href=\"#calculate-intersection\" class=\"headerlink\" title=\"calculate intersection\"></a>calculate intersection</h2><h2 id=\"Axis-Aligned-Bounding-box\"><a href=\"#Axis-Aligned-Bounding-box\" class=\"headerlink\" title=\"Axis-Aligned Bounding box\"></a>Axis-Aligned Bounding box</h2>","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>title: 计算机图形学12 —— 阴影和光线追踪介绍<br>tags: [计算机图形学, 光线追踪, 阴影]<br>categories: [GAMES101]<br>index_img: /images/graphics7/graphics7_banner.png<br>date: 2020-10-03 17:09:11</p>\n<h2 id=\"阴影光栅化方式表示\"><a href=\"#阴影光栅化方式表示\" class=\"headerlink\" title=\"阴影光栅化方式表示\"></a>阴影光栅化方式表示</h2><h2 id=\"光线追踪简介\"><a href=\"#光线追踪简介\" class=\"headerlink\" title=\"光线追踪简介\"></a>光线追踪简介</h2><h2 id=\"whitted-ray-tracing\"><a href=\"#whitted-ray-tracing\" class=\"headerlink\" title=\"whitted ray tracing\"></a>whitted ray tracing</h2><h2 id=\"calculate-intersection\"><a href=\"#calculate-intersection\" class=\"headerlink\" title=\"calculate intersection\"></a>calculate intersection</h2><h2 id=\"Axis-Aligned-Bounding-box\"><a href=\"#Axis-Aligned-Bounding-box\" class=\"headerlink\" title=\"Axis-Aligned Bounding box\"></a>Axis-Aligned Bounding box</h2>"},{"title":"计算机图形学2 —— 图形变换扩展","index_img":"/images/graphics2/graphics2_banner.jpeg","date":"2020-08-17T13:09:11.000Z","math":true,"_content":"## 线性变换的组合和分解\n\n### 线性变换的组合\n在前文我们提到，所有的线性变换都可以扩展成为变换矩阵左乘于源坐标点的数学表示。当对一个向量应用多次变换时的数学表示则是按照顺序分别左乘变换矩阵：\n$$\nfirst, v_2 = Sv_1, then, v_3 = Rv_2\n$$\n可以被表示为：\n$$\nv_3 = R(Sv_1)\n$$\n根据矩阵计算的结合律可以推导为：\n$$\nv_3 = (RS)v_1\n$$\n根据上面的推导可以发现一个规律，矩阵经过的两次变换$S$、$R$，可以表示为一次变换矩阵$M$，其中$M = RS$。其中矩阵乘法的顺序很重要。\n![](/images/graphics2/graphics2_compose.png)\n\n### 线性变换的分解\n既然多个变换矩阵可以合并为同一个变换矩阵，那么一个变换矩阵也可以被分解为多个变换矩阵的乘积。利用矩阵分解知识我们知道，对于给定 $A_{n*n}$ 的方阵，如果其具有n个线性无关的特征向量，那么可以被分解为，正交矩阵与对角矩阵相乘的形式，这个过程：\n$$\nA = RSR^T\n$$\n其中 $R$ 为特征向量组成的正交矩阵，$S$ 为其特征值组成的对角矩阵。在$n=2$的情况下，$R$ 由其特征向量 $v_1, v_2$ 组成，$R = [v_1, v_2]$。$S$的对角值分别为其特征值 $\\lambda_1$、$\\lambda_2$。\n\n根据其分解出的矩阵的特点，我们可以通过几何意义来对 $A$ 进行线性变换分解，$R$ 可以看作是一个旋转变换，$S$可以看作是缩放变换，因此原变换矩阵 $A$ 被分解为以下三个步骤：\n\n1. 将其特征向量 $v_1$ 和 $v_2$ 旋转到 $x, y$轴上即变换矩阵 $R^T$。\n2. 将变换后的矩阵进行缩放，$x, y$ 方向分别被缩放 $(\\lambda_1, \\lambda_2)$ 即变换矩阵$S$。\n3. 将变换后的特征向量 $v_1$ 和 $v_2$ 旋转回原来的位置即变换矩阵 $R$\n![](/images/graphics2/graphics2_decompose.png)\n\n### 绕任意轴旋转\n\n前文中提到了绕 $x, y, z$轴旋转的变换矩阵，根据矩阵分解和组合的特性我们可以推倒出绕任意轴旋转的变换矩阵。绕任意轴旋转可以被分解为以下三步：\n1. 通过变换矩阵$R_{uvw}^T$将需要做旋转的向量的向量空间变换到笛卡尔坐标系中，使得原向量空间下的 $u, v ,w$ 和 $x, y, z$做对齐。\n2. 做绕 $x$ 轴的旋转，变换矩阵为标准旋转矩阵$R_x$\n3. 通过变换矩阵$R_{uvw}$将旋转后的矩阵, 在重新变换为原向量空间下的 $u, v, w$中。\n\n以上过程可以用以下公式表示：\n$$\nR_a = R_{uvw} R_x R_{uvw}^T\n$$\n\n下面讨论下$R_{uvw}$这个矩阵，这里面会涉及到一部分向量空间的知识。为了方便理解，这里先不过多的讨论理论知识，按照方便理解的方式来进行讨论。假设$x, y, z$轴三个方向上的单位向量组成的矩阵：\n$$\nR_E = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n这三个向量互为正交，因此当我们为其做一些线性变换后(比如说绕z轴旋转45度后再绕y轴旋转45度，然后在缩放2倍)，三个向量依旧是正交的，通过线性变换 $R_{uvw}^T$ 变换之后，我们可以得到正交矩阵 $R_{uvw}$ \n$$\nR_{uvw} = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n$$\n下面证明上面的表达式为何能成立，假定$u = x_ux + y_uy + z_uz$，$v, w$同理，根据正交矩阵的特性，可以得到以下推倒：\n$$\nu  \\cdot u = v \\cdot v = w \\cdot w = 1\n$$\n$$\nu \\cdot v = v \\cdot w = w \\cdot u = 0\n$$\n利用这个特性，我们可以使用变换矩阵$R_{uvw}$将u变换到x轴上：\n$$\nR_{uvw}u = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u \\\\\ny_u \\\\\nz_u\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nx_ux_u + y_vy_v + z_wz_w\\\\\nx_vx_u + y_vy_u + z_vy_u\\\\\nx_wx_u + y_wy_u + z_wx_u\n\\end{bmatrix}\n$$\n上式可以被化简为：\n$$\nR_{uvw}u = \n\\begin{bmatrix}\nu \\cdot u\\\\\nv \\cdot u\\\\\nw \\cdot u\n= \n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n= \nx\n$$\n同理可以推导出$R_{uvw}v = y$以及$R_{uvw}w = z$\n对于还原变换矩阵$R_{uvw}^T$同理也可以通过上述方式推导如何将坐标轴${x, y, z}$变换到$u, v, w$上去。\n总结来看，对于任意轴的旋转可以用下列公式进行表示：\n$$\nR_a = R_{uvw} R_x R_{uvw}^T = \n\\begin{bmatrix}\nx_u & y_u & z_u\\\\\nx_v & y_v & z_v\\\\\nx_w & y_w & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n$$\n\n## 齐次坐标\n平移操作也是矩阵中经常会出现的情况，它变换后的坐标$x^\\prime,y^\\prime$可以很方便的通过公式表示:\n$$\nx^\\prime = x + x_t\n$$\n$$\ny^\\prime = y = y_t\n$$\n但是平移变换很难通过与待变换矩阵同纬度的变换矩阵来进行表示，因为它不属于线性变换。这里需要引入其次坐标的概念，通过原本是n维的向量用一个n+1维向量来表示。比如我们原有的平面中的点$(x, y)$升纬到3D表示为：$[x, y, 1]^T$，这样就可以将平移操作表示3D中的线性变换矩阵：\n$$\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n此时再对$x^\\prime,y^\\prime$做计算，可以得到：\n$$\n\\begin{bmatrix}\nx^\\prime \\\\\ny^\\prime \\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nm_{11}x + m_{12}y + x_t\\\\\nm_{21}x + m_{22}y + y_t\\\\\n1\n\\end{bmatrix}\n$$\n\n**注：在其次坐标中最后一维取值为0时，代表一个方向，取值为1时代表一个点**","source":"_posts/ComputerGraphics2.md","raw":"---\ntitle: 计算机图形学2 —— 图形变换扩展\ntags: [计算机图形学, 线性代数]\ncategories: [GAMES101]\nindex_img: /images/graphics2/graphics2_banner.jpeg\ndate: 2020-08-17 21:09:11\nmath: true\n---\n## 线性变换的组合和分解\n\n### 线性变换的组合\n在前文我们提到，所有的线性变换都可以扩展成为变换矩阵左乘于源坐标点的数学表示。当对一个向量应用多次变换时的数学表示则是按照顺序分别左乘变换矩阵：\n$$\nfirst, v_2 = Sv_1, then, v_3 = Rv_2\n$$\n可以被表示为：\n$$\nv_3 = R(Sv_1)\n$$\n根据矩阵计算的结合律可以推导为：\n$$\nv_3 = (RS)v_1\n$$\n根据上面的推导可以发现一个规律，矩阵经过的两次变换$S$、$R$，可以表示为一次变换矩阵$M$，其中$M = RS$。其中矩阵乘法的顺序很重要。\n![](/images/graphics2/graphics2_compose.png)\n\n### 线性变换的分解\n既然多个变换矩阵可以合并为同一个变换矩阵，那么一个变换矩阵也可以被分解为多个变换矩阵的乘积。利用矩阵分解知识我们知道，对于给定 $A_{n*n}$ 的方阵，如果其具有n个线性无关的特征向量，那么可以被分解为，正交矩阵与对角矩阵相乘的形式，这个过程：\n$$\nA = RSR^T\n$$\n其中 $R$ 为特征向量组成的正交矩阵，$S$ 为其特征值组成的对角矩阵。在$n=2$的情况下，$R$ 由其特征向量 $v_1, v_2$ 组成，$R = [v_1, v_2]$。$S$的对角值分别为其特征值 $\\lambda_1$、$\\lambda_2$。\n\n根据其分解出的矩阵的特点，我们可以通过几何意义来对 $A$ 进行线性变换分解，$R$ 可以看作是一个旋转变换，$S$可以看作是缩放变换，因此原变换矩阵 $A$ 被分解为以下三个步骤：\n\n1. 将其特征向量 $v_1$ 和 $v_2$ 旋转到 $x, y$轴上即变换矩阵 $R^T$。\n2. 将变换后的矩阵进行缩放，$x, y$ 方向分别被缩放 $(\\lambda_1, \\lambda_2)$ 即变换矩阵$S$。\n3. 将变换后的特征向量 $v_1$ 和 $v_2$ 旋转回原来的位置即变换矩阵 $R$\n![](/images/graphics2/graphics2_decompose.png)\n\n### 绕任意轴旋转\n\n前文中提到了绕 $x, y, z$轴旋转的变换矩阵，根据矩阵分解和组合的特性我们可以推倒出绕任意轴旋转的变换矩阵。绕任意轴旋转可以被分解为以下三步：\n1. 通过变换矩阵$R_{uvw}^T$将需要做旋转的向量的向量空间变换到笛卡尔坐标系中，使得原向量空间下的 $u, v ,w$ 和 $x, y, z$做对齐。\n2. 做绕 $x$ 轴的旋转，变换矩阵为标准旋转矩阵$R_x$\n3. 通过变换矩阵$R_{uvw}$将旋转后的矩阵, 在重新变换为原向量空间下的 $u, v, w$中。\n\n以上过程可以用以下公式表示：\n$$\nR_a = R_{uvw} R_x R_{uvw}^T\n$$\n\n下面讨论下$R_{uvw}$这个矩阵，这里面会涉及到一部分向量空间的知识。为了方便理解，这里先不过多的讨论理论知识，按照方便理解的方式来进行讨论。假设$x, y, z$轴三个方向上的单位向量组成的矩阵：\n$$\nR_E = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n这三个向量互为正交，因此当我们为其做一些线性变换后(比如说绕z轴旋转45度后再绕y轴旋转45度，然后在缩放2倍)，三个向量依旧是正交的，通过线性变换 $R_{uvw}^T$ 变换之后，我们可以得到正交矩阵 $R_{uvw}$ \n$$\nR_{uvw} = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n$$\n下面证明上面的表达式为何能成立，假定$u = x_ux + y_uy + z_uz$，$v, w$同理，根据正交矩阵的特性，可以得到以下推倒：\n$$\nu  \\cdot u = v \\cdot v = w \\cdot w = 1\n$$\n$$\nu \\cdot v = v \\cdot w = w \\cdot u = 0\n$$\n利用这个特性，我们可以使用变换矩阵$R_{uvw}$将u变换到x轴上：\n$$\nR_{uvw}u = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u \\\\\ny_u \\\\\nz_u\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nx_ux_u + y_vy_v + z_wz_w\\\\\nx_vx_u + y_vy_u + z_vy_u\\\\\nx_wx_u + y_wy_u + z_wx_u\n\\end{bmatrix}\n$$\n上式可以被化简为：\n$$\nR_{uvw}u = \n\\begin{bmatrix}\nu \\cdot u\\\\\nv \\cdot u\\\\\nw \\cdot u\n= \n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n= \nx\n$$\n同理可以推导出$R_{uvw}v = y$以及$R_{uvw}w = z$\n对于还原变换矩阵$R_{uvw}^T$同理也可以通过上述方式推导如何将坐标轴${x, y, z}$变换到$u, v, w$上去。\n总结来看，对于任意轴的旋转可以用下列公式进行表示：\n$$\nR_a = R_{uvw} R_x R_{uvw}^T = \n\\begin{bmatrix}\nx_u & y_u & z_u\\\\\nx_v & y_v & z_v\\\\\nx_w & y_w & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n$$\n\n## 齐次坐标\n平移操作也是矩阵中经常会出现的情况，它变换后的坐标$x^\\prime,y^\\prime$可以很方便的通过公式表示:\n$$\nx^\\prime = x + x_t\n$$\n$$\ny^\\prime = y = y_t\n$$\n但是平移变换很难通过与待变换矩阵同纬度的变换矩阵来进行表示，因为它不属于线性变换。这里需要引入其次坐标的概念，通过原本是n维的向量用一个n+1维向量来表示。比如我们原有的平面中的点$(x, y)$升纬到3D表示为：$[x, y, 1]^T$，这样就可以将平移操作表示3D中的线性变换矩阵：\n$$\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n此时再对$x^\\prime,y^\\prime$做计算，可以得到：\n$$\n\\begin{bmatrix}\nx^\\prime \\\\\ny^\\prime \\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nm_{11}x + m_{12}y + x_t\\\\\nm_{21}x + m_{22}y + y_t\\\\\n1\n\\end{bmatrix}\n$$\n\n**注：在其次坐标中最后一维取值为0时，代表一个方向，取值为1时代表一个点**","slug":"ComputerGraphics2","published":1,"updated":"2020-10-03T07:35:24.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wa9000anwqccmecfhan","content":"<h2 id=\"线性变换的组合和分解\"><a href=\"#线性变换的组合和分解\" class=\"headerlink\" title=\"线性变换的组合和分解\"></a>线性变换的组合和分解</h2><h3 id=\"线性变换的组合\"><a href=\"#线性变换的组合\" class=\"headerlink\" title=\"线性变换的组合\"></a>线性变换的组合</h3><p>在前文我们提到，所有的线性变换都可以扩展成为变换矩阵左乘于源坐标点的数学表示。当对一个向量应用多次变换时的数学表示则是按照顺序分别左乘变换矩阵：</p>\n<script type=\"math/tex; mode=display\">\nfirst, v_2 = Sv_1, then, v_3 = Rv_2</script><p>可以被表示为：</p>\n<script type=\"math/tex; mode=display\">\nv_3 = R(Sv_1)</script><p>根据矩阵计算的结合律可以推导为：</p>\n<script type=\"math/tex; mode=display\">\nv_3 = (RS)v_1</script><p>根据上面的推导可以发现一个规律，矩阵经过的两次变换$S$、$R$，可以表示为一次变换矩阵$M$，其中$M = RS$。其中矩阵乘法的顺序很重要。<br><img src=\"/images/graphics2/graphics2_compose.png\" alt=\"\"></p>\n<h3 id=\"线性变换的分解\"><a href=\"#线性变换的分解\" class=\"headerlink\" title=\"线性变换的分解\"></a>线性变换的分解</h3><p>既然多个变换矩阵可以合并为同一个变换矩阵，那么一个变换矩阵也可以被分解为多个变换矩阵的乘积。利用矩阵分解知识我们知道，对于给定 $A_{n*n}$ 的方阵，如果其具有n个线性无关的特征向量，那么可以被分解为，正交矩阵与对角矩阵相乘的形式，这个过程：</p>\n<script type=\"math/tex; mode=display\">\nA = RSR^T</script><p>其中 $R$ 为特征向量组成的正交矩阵，$S$ 为其特征值组成的对角矩阵。在$n=2$的情况下，$R$ 由其特征向量 $v_1, v_2$ 组成，$R = [v_1, v_2]$。$S$的对角值分别为其特征值 $\\lambda_1$、$\\lambda_2$。</p>\n<p>根据其分解出的矩阵的特点，我们可以通过几何意义来对 $A$ 进行线性变换分解，$R$ 可以看作是一个旋转变换，$S$可以看作是缩放变换，因此原变换矩阵 $A$ 被分解为以下三个步骤：</p>\n<ol>\n<li>将其特征向量 $v_1$ 和 $v_2$ 旋转到 $x, y$轴上即变换矩阵 $R^T$。</li>\n<li>将变换后的矩阵进行缩放，$x, y$ 方向分别被缩放 $(\\lambda_1, \\lambda_2)$ 即变换矩阵$S$。</li>\n<li>将变换后的特征向量 $v_1$ 和 $v_2$ 旋转回原来的位置即变换矩阵 $R$<br><img src=\"/images/graphics2/graphics2_decompose.png\" alt=\"\"></li>\n</ol>\n<h3 id=\"绕任意轴旋转\"><a href=\"#绕任意轴旋转\" class=\"headerlink\" title=\"绕任意轴旋转\"></a>绕任意轴旋转</h3><p>前文中提到了绕 $x, y, z$轴旋转的变换矩阵，根据矩阵分解和组合的特性我们可以推倒出绕任意轴旋转的变换矩阵。绕任意轴旋转可以被分解为以下三步：</p>\n<ol>\n<li>通过变换矩阵$R_{uvw}^T$将需要做旋转的向量的向量空间变换到笛卡尔坐标系中，使得原向量空间下的 $u, v ,w$ 和 $x, y, z$做对齐。</li>\n<li>做绕 $x$ 轴的旋转，变换矩阵为标准旋转矩阵$R_x$</li>\n<li>通过变换矩阵$R_{uvw}$将旋转后的矩阵, 在重新变换为原向量空间下的 $u, v, w$中。</li>\n</ol>\n<p>以上过程可以用以下公式表示：</p>\n<script type=\"math/tex; mode=display\">\nR_a = R_{uvw} R_x R_{uvw}^T</script><p>下面讨论下$R_{uvw}$这个矩阵，这里面会涉及到一部分向量空间的知识。为了方便理解，这里先不过多的讨论理论知识，按照方便理解的方式来进行讨论。假设$x, y, z$轴三个方向上的单位向量组成的矩阵：</p>\n<script type=\"math/tex; mode=display\">\nR_E = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>这三个向量互为正交，因此当我们为其做一些线性变换后(比如说绕z轴旋转45度后再绕y轴旋转45度，然后在缩放2倍)，三个向量依旧是正交的，通过线性变换 $R<em>{uvw}^T$ 变换之后，我们可以得到正交矩阵 $R</em>{uvw}$ </p>\n<script type=\"math/tex; mode=display\">\nR_{uvw} = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}</script><p>下面证明上面的表达式为何能成立，假定$u = x_ux + y_uy + z_uz$，$v, w$同理，根据正交矩阵的特性，可以得到以下推倒：</p>\n<script type=\"math/tex; mode=display\">\nu  \\cdot u = v \\cdot v = w \\cdot w = 1</script><script type=\"math/tex; mode=display\">\nu \\cdot v = v \\cdot w = w \\cdot u = 0</script><p>利用这个特性，我们可以使用变换矩阵$R_{uvw}$将u变换到x轴上：</p>\n<script type=\"math/tex; mode=display\">\nR_{uvw}u = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u \\\\\ny_u \\\\\nz_u\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nx_ux_u + y_vy_v + z_wz_w\\\\\nx_vx_u + y_vy_u + z_vy_u\\\\\nx_wx_u + y_wy_u + z_wx_u\n\\end{bmatrix}</script><p>上式可以被化简为：</p>\n<script type=\"math/tex; mode=display\">\nR_{uvw}u = \n\\begin{bmatrix}\nu \\cdot u\\\\\nv \\cdot u\\\\\nw \\cdot u\n= \n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n= \nx</script><p>同理可以推导出$R<em>{uvw}v = y$以及$R</em>{uvw}w = z$<br>对于还原变换矩阵$R_{uvw}^T$同理也可以通过上述方式推导如何将坐标轴${x, y, z}$变换到$u, v, w$上去。<br>总结来看，对于任意轴的旋转可以用下列公式进行表示：</p>\n<script type=\"math/tex; mode=display\">\nR_a = R_{uvw} R_x R_{uvw}^T = \n\\begin{bmatrix}\nx_u & y_u & z_u\\\\\nx_v & y_v & z_v\\\\\nx_w & y_w & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}</script><h2 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h2><p>平移操作也是矩阵中经常会出现的情况，它变换后的坐标$x^\\prime,y^\\prime$可以很方便的通过公式表示:</p>\n<script type=\"math/tex; mode=display\">\nx^\\prime = x + x_t</script><script type=\"math/tex; mode=display\">\ny^\\prime = y = y_t</script><p>但是平移变换很难通过与待变换矩阵同纬度的变换矩阵来进行表示，因为它不属于线性变换。这里需要引入其次坐标的概念，通过原本是n维的向量用一个n+1维向量来表示。比如我们原有的平面中的点$(x, y)$升纬到3D表示为：$[x, y, 1]^T$，这样就可以将平移操作表示3D中的线性变换矩阵：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>此时再对$x^\\prime,y^\\prime$做计算，可以得到：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\nx^\\prime \\\\\ny^\\prime \\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nm_{11}x + m_{12}y + x_t\\\\\nm_{21}x + m_{22}y + y_t\\\\\n1\n\\end{bmatrix}</script><p><strong>注：在其次坐标中最后一维取值为0时，代表一个方向，取值为1时代表一个点</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"线性变换的组合和分解\"><a href=\"#线性变换的组合和分解\" class=\"headerlink\" title=\"线性变换的组合和分解\"></a>线性变换的组合和分解</h2><h3 id=\"线性变换的组合\"><a href=\"#线性变换的组合\" class=\"headerlink\" title=\"线性变换的组合\"></a>线性变换的组合</h3><p>在前文我们提到，所有的线性变换都可以扩展成为变换矩阵左乘于源坐标点的数学表示。当对一个向量应用多次变换时的数学表示则是按照顺序分别左乘变换矩阵：</p>\n<script type=\"math/tex; mode=display\">\nfirst, v_2 = Sv_1, then, v_3 = Rv_2</script><p>可以被表示为：</p>\n<script type=\"math/tex; mode=display\">\nv_3 = R(Sv_1)</script><p>根据矩阵计算的结合律可以推导为：</p>\n<script type=\"math/tex; mode=display\">\nv_3 = (RS)v_1</script><p>根据上面的推导可以发现一个规律，矩阵经过的两次变换$S$、$R$，可以表示为一次变换矩阵$M$，其中$M = RS$。其中矩阵乘法的顺序很重要。<br><img src=\"/images/graphics2/graphics2_compose.png\" alt=\"\"></p>\n<h3 id=\"线性变换的分解\"><a href=\"#线性变换的分解\" class=\"headerlink\" title=\"线性变换的分解\"></a>线性变换的分解</h3><p>既然多个变换矩阵可以合并为同一个变换矩阵，那么一个变换矩阵也可以被分解为多个变换矩阵的乘积。利用矩阵分解知识我们知道，对于给定 $A_{n*n}$ 的方阵，如果其具有n个线性无关的特征向量，那么可以被分解为，正交矩阵与对角矩阵相乘的形式，这个过程：</p>\n<script type=\"math/tex; mode=display\">\nA = RSR^T</script><p>其中 $R$ 为特征向量组成的正交矩阵，$S$ 为其特征值组成的对角矩阵。在$n=2$的情况下，$R$ 由其特征向量 $v_1, v_2$ 组成，$R = [v_1, v_2]$。$S$的对角值分别为其特征值 $\\lambda_1$、$\\lambda_2$。</p>\n<p>根据其分解出的矩阵的特点，我们可以通过几何意义来对 $A$ 进行线性变换分解，$R$ 可以看作是一个旋转变换，$S$可以看作是缩放变换，因此原变换矩阵 $A$ 被分解为以下三个步骤：</p>\n<ol>\n<li>将其特征向量 $v_1$ 和 $v_2$ 旋转到 $x, y$轴上即变换矩阵 $R^T$。</li>\n<li>将变换后的矩阵进行缩放，$x, y$ 方向分别被缩放 $(\\lambda_1, \\lambda_2)$ 即变换矩阵$S$。</li>\n<li>将变换后的特征向量 $v_1$ 和 $v_2$ 旋转回原来的位置即变换矩阵 $R$<br><img src=\"/images/graphics2/graphics2_decompose.png\" alt=\"\"></li>\n</ol>\n<h3 id=\"绕任意轴旋转\"><a href=\"#绕任意轴旋转\" class=\"headerlink\" title=\"绕任意轴旋转\"></a>绕任意轴旋转</h3><p>前文中提到了绕 $x, y, z$轴旋转的变换矩阵，根据矩阵分解和组合的特性我们可以推倒出绕任意轴旋转的变换矩阵。绕任意轴旋转可以被分解为以下三步：</p>\n<ol>\n<li>通过变换矩阵$R_{uvw}^T$将需要做旋转的向量的向量空间变换到笛卡尔坐标系中，使得原向量空间下的 $u, v ,w$ 和 $x, y, z$做对齐。</li>\n<li>做绕 $x$ 轴的旋转，变换矩阵为标准旋转矩阵$R_x$</li>\n<li>通过变换矩阵$R_{uvw}$将旋转后的矩阵, 在重新变换为原向量空间下的 $u, v, w$中。</li>\n</ol>\n<p>以上过程可以用以下公式表示：</p>\n<script type=\"math/tex; mode=display\">\nR_a = R_{uvw} R_x R_{uvw}^T</script><p>下面讨论下$R_{uvw}$这个矩阵，这里面会涉及到一部分向量空间的知识。为了方便理解，这里先不过多的讨论理论知识，按照方便理解的方式来进行讨论。假设$x, y, z$轴三个方向上的单位向量组成的矩阵：</p>\n<script type=\"math/tex; mode=display\">\nR_E = \n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>这三个向量互为正交，因此当我们为其做一些线性变换后(比如说绕z轴旋转45度后再绕y轴旋转45度，然后在缩放2倍)，三个向量依旧是正交的，通过线性变换 $R<em>{uvw}^T$ 变换之后，我们可以得到正交矩阵 $R</em>{uvw}$ </p>\n<script type=\"math/tex; mode=display\">\nR_{uvw} = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}</script><p>下面证明上面的表达式为何能成立，假定$u = x_ux + y_uy + z_uz$，$v, w$同理，根据正交矩阵的特性，可以得到以下推倒：</p>\n<script type=\"math/tex; mode=display\">\nu  \\cdot u = v \\cdot v = w \\cdot w = 1</script><script type=\"math/tex; mode=display\">\nu \\cdot v = v \\cdot w = w \\cdot u = 0</script><p>利用这个特性，我们可以使用变换矩阵$R_{uvw}$将u变换到x轴上：</p>\n<script type=\"math/tex; mode=display\">\nR_{uvw}u = \n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u \\\\\ny_u \\\\\nz_u\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nx_ux_u + y_vy_v + z_wz_w\\\\\nx_vx_u + y_vy_u + z_vy_u\\\\\nx_wx_u + y_wy_u + z_wx_u\n\\end{bmatrix}</script><p>上式可以被化简为：</p>\n<script type=\"math/tex; mode=display\">\nR_{uvw}u = \n\\begin{bmatrix}\nu \\cdot u\\\\\nv \\cdot u\\\\\nw \\cdot u\n= \n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n0\n\\end{bmatrix}\n= \nx</script><p>同理可以推导出$R<em>{uvw}v = y$以及$R</em>{uvw}w = z$<br>对于还原变换矩阵$R_{uvw}^T$同理也可以通过上述方式推导如何将坐标轴${x, y, z}$变换到$u, v, w$上去。<br>总结来看，对于任意轴的旋转可以用下列公式进行表示：</p>\n<script type=\"math/tex; mode=display\">\nR_a = R_{uvw} R_x R_{uvw}^T = \n\\begin{bmatrix}\nx_u & y_u & z_u\\\\\nx_v & y_v & z_v\\\\\nx_w & y_w & z_w\n\\end{bmatrix}\n\\begin{bmatrix}\ncos\\varphi & -sin\\varphi & 0\\\\\nsin\\varphi & cos\\varphi & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx_u & x_v & x_w\\\\\ny_u & y_v & y_w\\\\\nz_u & z_v & z_w\n\\end{bmatrix}</script><h2 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h2><p>平移操作也是矩阵中经常会出现的情况，它变换后的坐标$x^\\prime,y^\\prime$可以很方便的通过公式表示:</p>\n<script type=\"math/tex; mode=display\">\nx^\\prime = x + x_t</script><script type=\"math/tex; mode=display\">\ny^\\prime = y = y_t</script><p>但是平移变换很难通过与待变换矩阵同纬度的变换矩阵来进行表示，因为它不属于线性变换。这里需要引入其次坐标的概念，通过原本是n维的向量用一个n+1维向量来表示。比如我们原有的平面中的点$(x, y)$升纬到3D表示为：$[x, y, 1]^T$，这样就可以将平移操作表示3D中的线性变换矩阵：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}</script><p>此时再对$x^\\prime,y^\\prime$做计算，可以得到：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\nx^\\prime \\\\\ny^\\prime \\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nm_{11} & m_{12} & x_t\\\\\nm_{21} & m_{22} & y_t\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nm_{11}x + m_{12}y + x_t\\\\\nm_{21}x + m_{22}y + y_t\\\\\n1\n\\end{bmatrix}</script><p><strong>注：在其次坐标中最后一维取值为0时，代表一个方向，取值为1时代表一个点</strong></p>\n"},{"title":"计算机图形学3 —— 视图变换","index_img":"/images/graphics3/graphics3_banner.png","date":"2020-08-24T14:19:33.000Z","math":true,"_content":"视图变换（viewing transform）的主要职责是将3D物体的坐标（我们取标准坐标$(x, y, z)$映射到屏幕的一个个像素点上来。它的过程可以说是比较复杂的，因为在视图变换的过程中很多因素可以决定最后成像的效果。视图变换可以分为四个过程，模型变换（modal transform）、 视角变换（view transform）、投影变换（projection transform）以及视口变换（viewport transformation）。这个过程可以拿拍照片来类比：\n1. 站好位置，摆好姿势（modal transform）\n2. 找好角度，调整相机位置（view transform）\n3. 拍摄照片，将3D场景拍摄到2D的照片（projection transform && viewport transformation）\n\n在拍照片的过程中我们模拟了视图变换的过程。首先是模型变换，我们需要将模型从模型坐标变换到世界坐标中来，也就是在拍照过程中让人站好姿势、摆好位置。调整相机位置，也就是调整在世界坐标中从哪个方向去观测。这个过程我们需要确定两个方向，一个方向是观测的朝向，另一个方向就是与观测朝向“向上”的方向，比如说我们朝着$-Z$方向去看，那么“向上”方向就是$Y$方向。当以上过程都完成后，我们需要将3D场景转换到2D屏幕上，就需要通过投影的方式做像素映射。\n\n![](/images/graphics3/graphics3_transformation.png)\n\n## 相机变换 view/camera transform\n结合在上一篇我们讨论的绕任意轴旋转的变换推导中，我们其实可以很容易使用类似的思路来进行推导相机变换。还记得为什么在相机变换的过程中，为什么除了看向方向（look-at direction）之外表示为$g$，还需要一个“向上”的方向（up direction）表示为$t$，有了着两个方向以及相机的位置$e$。\n我们在根据坐标系法则就可以建立起一个三位坐标$u,v,w$。定义如下：\n$$\nw =  -\\frac{g}{\\left |\\left | g \\right |   \\right | } \n$$\n\n$$\nu = \\frac{t \\times w }{ \\left |\\left | {t \\times w} \\right |   \\right |  }  \n$$\n\n$$\nv = w \\times u\n$$\n\n![](/images/graphics3/graphics3_camera.png)\n摄像机变换就可以看作将$x,y,z$坐标系转换到$u,v,w$坐标系的过程。我们将变换矩阵写作$M_{view}$，令\n\n$$\nM_{view} = R_{view}T_{view}\n$$\n\n其中$R$是改变相机朝向的的变换矩阵，它的作用是使得$-Z$旋转到看向方向$u$，$Y$旋转到“向上“的方向$v$。$T_{view}$是移动相机位置的矩阵，是一个平移矩阵，可以被表示为：\n\n$$\nT_{view} =\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n旋转的过程在前面的章节有提过，如果需要使用$R$变换矩阵，因此$M$可以被表示为：\n\n$$\nM_{view} = \n\n\\begin{bmatrix}\nx_u & y_u & z_u & 0\\\\\nx_v & y_v & z_v & 0\\\\\nx_w & y_w & z_w & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n## 投影变换 pojection transform\n投影变换的过程主要是将3D的点投影到2D的屏幕上来，根据变换条件的不同，可以将投影区分为正交投影和透视投影。如下图所示展现了两种投影的变换方式和成像结果。\n![](/images/graphics3/graphics3_banner.png)\n### 正交投影 Orthographic Projection Transformation\n正交投影很好理解，在正交投影之后图形中所有点的的相对位置都不会发生改变，可以将其看作直接将图形“压扁”，然后放置在某一平面上。\n![](/images/graphics3/graphic3_orthographic.png)\n在实际渲染过程中，我们总是希望在某个空间区域来渲染图形，而非根据整个视图区域来做渲染。假设渲染发生在一个沿着$Z$轴负方向，底面（bottom）与$XY$平面平行的一个立方体。这时候可以定义左右面（left, right）以及近远面（near, far），以及上下面（top, bottom）用以下代数表示：\n$$\nx = l = left{\\space}plane\n$$\n\n$$\nx = r = right{\\space}plane\n$$\n\n$$\ny = v = bottom{\\space}plane\n$$\n\n$$\ny = t = left{\\space}plane\n$$\n\n$$\nz = n = near{\\space}plane\n$$\n\n$$\nz = f = far{\\space}plane\n$$\n简单来说，正交投影的主要原理是将上述区域变换到一个”正则、规范、标准“的立方体$[-1, 1]^3$中来。这个变换过程可以分解为两个变换：\n1. 将渲染盒子平移到以原点为中心的位置，即每个定点到投影平面的距离为 边长/2\n2. 将渲染盒子缩放为立方体$[-1, 1]^3$\n![](/images/graphics3/graphics3_orthographic_transform.png)\n这个过程可以用变换矩阵表示为：\n$$\nM_{ortho} = \n\\begin{bmatrix}\n\\frac{2}{r - l} & 0 & 0 & 0\\\\\n0 & \\frac{2}{t - b} & 0 & 0\\\\\n0 & 0 & \\frac{2}{n - f} & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n\\begin{bmatrix}\n1 & 0 & 0 & -\\frac{r+l}{2}\\\\\n0 & 1 & 0 & -\\frac{t+b}{2}\\\\\n0 & 0 & 1 & -\\frac{n+f}{2}\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n$$\n### 透视投影 Perspective Projection Transformation\n透视投影和正交投影最大的区别在于，透视投影的过程不是“平行的”，投影的线最终会相交。因为透视投影需要实现真实的透视关系，也就是相等大小的物体，处于场景近端他会显示得更大，处于场景远端它会显示得更小。对于任意一点的投影过程可以用下图来表示：\n\n![](/images/graphics3/graphic3_orthographic_point.png)\n\n对于任意点$[x, y, z]$, 经过透视投影变换后到投影平面上，形成$[x^{\\prime}, y^{\\prime}, z^{\\prime}]$。图中的$z = -n$为投影平面，也就是我们的$near$面，假定$[x, y, z]$所在的与$XY$平面平行的面为$far$面。根据相似三角形法则，对于$y^{\\prime}$可以得到：\n$$\ny^{\\prime} = \\frac{n}{z}y {\\space}{\\space}{\\space}{\\space}{\\space}x^{\\prime} = \\frac{n}{z}x \n$$\n\n为了推导投影矩阵，我们列出其原点和投影点的关系，当被投影点坐标全部乘以$z$的时候，被投影点坐标变化如下：\n$$\n \\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n \\begin{pmatrix}\n nx/z\\\\\n ny/z\\\\\n unknown\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix}\n$$\n\n因此我们想要求的投影矩阵是执行了如下变化：\n$$\nM_{persp{\\to}ortho}^{4\\times4}:\n{\\space}\n\\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix} \n$$\n根据上面的变换过程我们可以将变换矩阵的确定项先写出来：\n$$\nM_{persp{\\to}ortho}^{4\\times4}=\n \\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n ? & ? & ? & ?\\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix} \n$$\n接下来就是如何确定不确定的这行的值了，在透视投影的可视空间中，发生透视变换后有两个特性：\n1. 所有在$near$面上的点，经过透视投影变换后其坐标值是不变的。\n2. 所有在$far$面上的点，经过透视投影变换后其$z$值是不变的。\n\n对于特性1，我们可以假定在near平面上的点$(x,y,n,1)^T$，经过变换之后，其坐标仍然保持不变。将所有坐标乘以$n$，得到：\n$$\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n nx\\\\\n ny\\\\\n n^2\\\\\n n\n\\end{pmatrix}\n$$\n通过上面的变换，我们可以得出一个结论——未知行额前两项必定为0，因为经过变换后的$z$值与$x,y$无关。因此假定最后一行为$(0,0,A,B)$，再计算第三行的乘法：\n$$\n\\begin{pmatrix}\n 0 {\\space}\n 0 {\\space}\n A {\\space}\n B \n\\end{pmatrix}\n\\begin{pmatrix}\n x \\\\\n y \\\\\n n \\\\\n 1 \n\\end{pmatrix}\n=\nn^2\n\\Rightarrow \nAn + B = n^2\n$$\n同理，利用特性二所有在$far$平面上的点的$z$值不会发生变化：\n$$\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f^2\\\\\n f\n\\end{pmatrix}\n\n\\Rightarrow \nAf + B = f^2\n$$\n\n联立两个等式，得到：\n$$\nA = f + n\n$$\n$$\nB = -nf\n$$\n因此变换矩阵$M_{persp{\\to}ortho}^{4\\times4}$的值为：\n$$\nM_{persp{\\to}ortho}^{4\\times4} =   \n\\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n 0 & 0 & f+n & -nf \\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix}  \n$$\n实际上，完成透视变换之后，再进行一次正交投影变换就彻底完成了以上透视投影变换：\n$$\nM_{persp} = M_{ortho}M_{persp{\\to}ortho}\n$$","source":"_posts/ComputerGraphics3.md","raw":"---\ntitle: 计算机图形学3 —— 视图变换\ntags: [计算机图形学, 投影，视图变换]\ncategories: [GAMES101]\nindex_img: /images/graphics3/graphics3_banner.png\ndate: 2020-08-24 22:19:33\nmath: true\n---\n视图变换（viewing transform）的主要职责是将3D物体的坐标（我们取标准坐标$(x, y, z)$映射到屏幕的一个个像素点上来。它的过程可以说是比较复杂的，因为在视图变换的过程中很多因素可以决定最后成像的效果。视图变换可以分为四个过程，模型变换（modal transform）、 视角变换（view transform）、投影变换（projection transform）以及视口变换（viewport transformation）。这个过程可以拿拍照片来类比：\n1. 站好位置，摆好姿势（modal transform）\n2. 找好角度，调整相机位置（view transform）\n3. 拍摄照片，将3D场景拍摄到2D的照片（projection transform && viewport transformation）\n\n在拍照片的过程中我们模拟了视图变换的过程。首先是模型变换，我们需要将模型从模型坐标变换到世界坐标中来，也就是在拍照过程中让人站好姿势、摆好位置。调整相机位置，也就是调整在世界坐标中从哪个方向去观测。这个过程我们需要确定两个方向，一个方向是观测的朝向，另一个方向就是与观测朝向“向上”的方向，比如说我们朝着$-Z$方向去看，那么“向上”方向就是$Y$方向。当以上过程都完成后，我们需要将3D场景转换到2D屏幕上，就需要通过投影的方式做像素映射。\n\n![](/images/graphics3/graphics3_transformation.png)\n\n## 相机变换 view/camera transform\n结合在上一篇我们讨论的绕任意轴旋转的变换推导中，我们其实可以很容易使用类似的思路来进行推导相机变换。还记得为什么在相机变换的过程中，为什么除了看向方向（look-at direction）之外表示为$g$，还需要一个“向上”的方向（up direction）表示为$t$，有了着两个方向以及相机的位置$e$。\n我们在根据坐标系法则就可以建立起一个三位坐标$u,v,w$。定义如下：\n$$\nw =  -\\frac{g}{\\left |\\left | g \\right |   \\right | } \n$$\n\n$$\nu = \\frac{t \\times w }{ \\left |\\left | {t \\times w} \\right |   \\right |  }  \n$$\n\n$$\nv = w \\times u\n$$\n\n![](/images/graphics3/graphics3_camera.png)\n摄像机变换就可以看作将$x,y,z$坐标系转换到$u,v,w$坐标系的过程。我们将变换矩阵写作$M_{view}$，令\n\n$$\nM_{view} = R_{view}T_{view}\n$$\n\n其中$R$是改变相机朝向的的变换矩阵，它的作用是使得$-Z$旋转到看向方向$u$，$Y$旋转到“向上“的方向$v$。$T_{view}$是移动相机位置的矩阵，是一个平移矩阵，可以被表示为：\n\n$$\nT_{view} =\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n旋转的过程在前面的章节有提过，如果需要使用$R$变换矩阵，因此$M$可以被表示为：\n\n$$\nM_{view} = \n\n\\begin{bmatrix}\nx_u & y_u & z_u & 0\\\\\nx_v & y_v & z_v & 0\\\\\nx_w & y_w & z_w & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n## 投影变换 pojection transform\n投影变换的过程主要是将3D的点投影到2D的屏幕上来，根据变换条件的不同，可以将投影区分为正交投影和透视投影。如下图所示展现了两种投影的变换方式和成像结果。\n![](/images/graphics3/graphics3_banner.png)\n### 正交投影 Orthographic Projection Transformation\n正交投影很好理解，在正交投影之后图形中所有点的的相对位置都不会发生改变，可以将其看作直接将图形“压扁”，然后放置在某一平面上。\n![](/images/graphics3/graphic3_orthographic.png)\n在实际渲染过程中，我们总是希望在某个空间区域来渲染图形，而非根据整个视图区域来做渲染。假设渲染发生在一个沿着$Z$轴负方向，底面（bottom）与$XY$平面平行的一个立方体。这时候可以定义左右面（left, right）以及近远面（near, far），以及上下面（top, bottom）用以下代数表示：\n$$\nx = l = left{\\space}plane\n$$\n\n$$\nx = r = right{\\space}plane\n$$\n\n$$\ny = v = bottom{\\space}plane\n$$\n\n$$\ny = t = left{\\space}plane\n$$\n\n$$\nz = n = near{\\space}plane\n$$\n\n$$\nz = f = far{\\space}plane\n$$\n简单来说，正交投影的主要原理是将上述区域变换到一个”正则、规范、标准“的立方体$[-1, 1]^3$中来。这个变换过程可以分解为两个变换：\n1. 将渲染盒子平移到以原点为中心的位置，即每个定点到投影平面的距离为 边长/2\n2. 将渲染盒子缩放为立方体$[-1, 1]^3$\n![](/images/graphics3/graphics3_orthographic_transform.png)\n这个过程可以用变换矩阵表示为：\n$$\nM_{ortho} = \n\\begin{bmatrix}\n\\frac{2}{r - l} & 0 & 0 & 0\\\\\n0 & \\frac{2}{t - b} & 0 & 0\\\\\n0 & 0 & \\frac{2}{n - f} & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n\\begin{bmatrix}\n1 & 0 & 0 & -\\frac{r+l}{2}\\\\\n0 & 1 & 0 & -\\frac{t+b}{2}\\\\\n0 & 0 & 1 & -\\frac{n+f}{2}\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n$$\n### 透视投影 Perspective Projection Transformation\n透视投影和正交投影最大的区别在于，透视投影的过程不是“平行的”，投影的线最终会相交。因为透视投影需要实现真实的透视关系，也就是相等大小的物体，处于场景近端他会显示得更大，处于场景远端它会显示得更小。对于任意一点的投影过程可以用下图来表示：\n\n![](/images/graphics3/graphic3_orthographic_point.png)\n\n对于任意点$[x, y, z]$, 经过透视投影变换后到投影平面上，形成$[x^{\\prime}, y^{\\prime}, z^{\\prime}]$。图中的$z = -n$为投影平面，也就是我们的$near$面，假定$[x, y, z]$所在的与$XY$平面平行的面为$far$面。根据相似三角形法则，对于$y^{\\prime}$可以得到：\n$$\ny^{\\prime} = \\frac{n}{z}y {\\space}{\\space}{\\space}{\\space}{\\space}x^{\\prime} = \\frac{n}{z}x \n$$\n\n为了推导投影矩阵，我们列出其原点和投影点的关系，当被投影点坐标全部乘以$z$的时候，被投影点坐标变化如下：\n$$\n \\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n \\begin{pmatrix}\n nx/z\\\\\n ny/z\\\\\n unknown\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix}\n$$\n\n因此我们想要求的投影矩阵是执行了如下变化：\n$$\nM_{persp{\\to}ortho}^{4\\times4}:\n{\\space}\n\\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix} \n$$\n根据上面的变换过程我们可以将变换矩阵的确定项先写出来：\n$$\nM_{persp{\\to}ortho}^{4\\times4}=\n \\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n ? & ? & ? & ?\\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix} \n$$\n接下来就是如何确定不确定的这行的值了，在透视投影的可视空间中，发生透视变换后有两个特性：\n1. 所有在$near$面上的点，经过透视投影变换后其坐标值是不变的。\n2. 所有在$far$面上的点，经过透视投影变换后其$z$值是不变的。\n\n对于特性1，我们可以假定在near平面上的点$(x,y,n,1)^T$，经过变换之后，其坐标仍然保持不变。将所有坐标乘以$n$，得到：\n$$\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n nx\\\\\n ny\\\\\n n^2\\\\\n n\n\\end{pmatrix}\n$$\n通过上面的变换，我们可以得出一个结论——未知行额前两项必定为0，因为经过变换后的$z$值与$x,y$无关。因此假定最后一行为$(0,0,A,B)$，再计算第三行的乘法：\n$$\n\\begin{pmatrix}\n 0 {\\space}\n 0 {\\space}\n A {\\space}\n B \n\\end{pmatrix}\n\\begin{pmatrix}\n x \\\\\n y \\\\\n n \\\\\n 1 \n\\end{pmatrix}\n=\nn^2\n\\Rightarrow \nAn + B = n^2\n$$\n同理，利用特性二所有在$far$平面上的点的$z$值不会发生变化：\n$$\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f^2\\\\\n f\n\\end{pmatrix}\n\n\\Rightarrow \nAf + B = f^2\n$$\n\n联立两个等式，得到：\n$$\nA = f + n\n$$\n$$\nB = -nf\n$$\n因此变换矩阵$M_{persp{\\to}ortho}^{4\\times4}$的值为：\n$$\nM_{persp{\\to}ortho}^{4\\times4} =   \n\\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n 0 & 0 & f+n & -nf \\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix}  \n$$\n实际上，完成透视变换之后，再进行一次正交投影变换就彻底完成了以上透视投影变换：\n$$\nM_{persp} = M_{ortho}M_{persp{\\to}ortho}\n$$","slug":"ComputerGraphics3","published":1,"updated":"2020-10-03T07:40:20.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1waa000bnwqcbk1538ha","content":"<p>视图变换（viewing transform）的主要职责是将3D物体的坐标（我们取标准坐标$(x, y, z)$映射到屏幕的一个个像素点上来。它的过程可以说是比较复杂的，因为在视图变换的过程中很多因素可以决定最后成像的效果。视图变换可以分为四个过程，模型变换（modal transform）、 视角变换（view transform）、投影变换（projection transform）以及视口变换（viewport transformation）。这个过程可以拿拍照片来类比：</p>\n<ol>\n<li>站好位置，摆好姿势（modal transform）</li>\n<li>找好角度，调整相机位置（view transform）</li>\n<li>拍摄照片，将3D场景拍摄到2D的照片（projection transform &amp;&amp; viewport transformation）</li>\n</ol>\n<p>在拍照片的过程中我们模拟了视图变换的过程。首先是模型变换，我们需要将模型从模型坐标变换到世界坐标中来，也就是在拍照过程中让人站好姿势、摆好位置。调整相机位置，也就是调整在世界坐标中从哪个方向去观测。这个过程我们需要确定两个方向，一个方向是观测的朝向，另一个方向就是与观测朝向“向上”的方向，比如说我们朝着$-Z$方向去看，那么“向上”方向就是$Y$方向。当以上过程都完成后，我们需要将3D场景转换到2D屏幕上，就需要通过投影的方式做像素映射。</p>\n<p><img src=\"/images/graphics3/graphics3_transformation.png\" alt=\"\"></p>\n<h2 id=\"相机变换-view-camera-transform\"><a href=\"#相机变换-view-camera-transform\" class=\"headerlink\" title=\"相机变换 view/camera transform\"></a>相机变换 view/camera transform</h2><p>结合在上一篇我们讨论的绕任意轴旋转的变换推导中，我们其实可以很容易使用类似的思路来进行推导相机变换。还记得为什么在相机变换的过程中，为什么除了看向方向（look-at direction）之外表示为$g$，还需要一个“向上”的方向（up direction）表示为$t$，有了着两个方向以及相机的位置$e$。<br>我们在根据坐标系法则就可以建立起一个三位坐标$u,v,w$。定义如下：</p>\n<script type=\"math/tex; mode=display\">\nw =  -\\frac{g}{\\left |\\left | g \\right |   \\right | }</script><script type=\"math/tex; mode=display\">\nu = \\frac{t \\times w }{ \\left |\\left | {t \\times w} \\right |   \\right |  }</script><script type=\"math/tex; mode=display\">\nv = w \\times u</script><p><img src=\"/images/graphics3/graphics3_camera.png\" alt=\"\"><br>摄像机变换就可以看作将$x,y,z$坐标系转换到$u,v,w$坐标系的过程。我们将变换矩阵写作$M_{view}$，令</p>\n<script type=\"math/tex; mode=display\">\nM_{view} = R_{view}T_{view}</script><p>其中$R$是改变相机朝向的的变换矩阵，它的作用是使得$-Z$旋转到看向方向$u$，$Y$旋转到“向上“的方向$v$。$T_{view}$是移动相机位置的矩阵，是一个平移矩阵，可以被表示为：</p>\n<script type=\"math/tex; mode=display\">\nT_{view} =\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}</script><p>旋转的过程在前面的章节有提过，如果需要使用$R$变换矩阵，因此$M$可以被表示为：</p>\n<script type=\"math/tex; mode=display\">\nM_{view} = \n\n\\begin{bmatrix}\nx_u & y_u & z_u & 0\\\\\nx_v & y_v & z_v & 0\\\\\nx_w & y_w & z_w & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}</script><h2 id=\"投影变换-pojection-transform\"><a href=\"#投影变换-pojection-transform\" class=\"headerlink\" title=\"投影变换 pojection transform\"></a>投影变换 pojection transform</h2><p>投影变换的过程主要是将3D的点投影到2D的屏幕上来，根据变换条件的不同，可以将投影区分为正交投影和透视投影。如下图所示展现了两种投影的变换方式和成像结果。<br><img src=\"/images/graphics3/graphics3_banner.png\" alt=\"\"></p>\n<h3 id=\"正交投影-Orthographic-Projection-Transformation\"><a href=\"#正交投影-Orthographic-Projection-Transformation\" class=\"headerlink\" title=\"正交投影 Orthographic Projection Transformation\"></a>正交投影 Orthographic Projection Transformation</h3><p>正交投影很好理解，在正交投影之后图形中所有点的的相对位置都不会发生改变，可以将其看作直接将图形“压扁”，然后放置在某一平面上。<br><img src=\"/images/graphics3/graphic3_orthographic.png\" alt=\"\"><br>在实际渲染过程中，我们总是希望在某个空间区域来渲染图形，而非根据整个视图区域来做渲染。假设渲染发生在一个沿着$Z$轴负方向，底面（bottom）与$XY$平面平行的一个立方体。这时候可以定义左右面（left, right）以及近远面（near, far），以及上下面（top, bottom）用以下代数表示：</p>\n<script type=\"math/tex; mode=display\">\nx = l = left{\\space}plane</script><script type=\"math/tex; mode=display\">\nx = r = right{\\space}plane</script><script type=\"math/tex; mode=display\">\ny = v = bottom{\\space}plane</script><script type=\"math/tex; mode=display\">\ny = t = left{\\space}plane</script><script type=\"math/tex; mode=display\">\nz = n = near{\\space}plane</script><script type=\"math/tex; mode=display\">\nz = f = far{\\space}plane</script><p>简单来说，正交投影的主要原理是将上述区域变换到一个”正则、规范、标准“的立方体$[-1, 1]^3$中来。这个变换过程可以分解为两个变换：</p>\n<ol>\n<li>将渲染盒子平移到以原点为中心的位置，即每个定点到投影平面的距离为 边长/2</li>\n<li>将渲染盒子缩放为立方体$[-1, 1]^3$<br><img src=\"/images/graphics3/graphics3_orthographic_transform.png\" alt=\"\"><br>这个过程可以用变换矩阵表示为：<script type=\"math/tex; mode=display\">\nM_{ortho} = \n\\begin{bmatrix}\n\\frac{2}{r - l} & 0 & 0 & 0\\\\\n0 & \\frac{2}{t - b} & 0 & 0\\\\\n0 & 0 & \\frac{2}{n - f} & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n\\begin{bmatrix}\n1 & 0 & 0 & -\\frac{r+l}{2}\\\\\n0 & 1 & 0 & -\\frac{t+b}{2}\\\\\n0 & 0 & 1 & -\\frac{n+f}{2}\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}</script><h3 id=\"透视投影-Perspective-Projection-Transformation\"><a href=\"#透视投影-Perspective-Projection-Transformation\" class=\"headerlink\" title=\"透视投影 Perspective Projection Transformation\"></a>透视投影 Perspective Projection Transformation</h3>透视投影和正交投影最大的区别在于，透视投影的过程不是“平行的”，投影的线最终会相交。因为透视投影需要实现真实的透视关系，也就是相等大小的物体，处于场景近端他会显示得更大，处于场景远端它会显示得更小。对于任意一点的投影过程可以用下图来表示：</li>\n</ol>\n<p><img src=\"/images/graphics3/graphic3_orthographic_point.png\" alt=\"\"></p>\n<p>对于任意点$[x, y, z]$, 经过透视投影变换后到投影平面上，形成$[x^{\\prime}, y^{\\prime}, z^{\\prime}]$。图中的$z = -n$为投影平面，也就是我们的$near$面，假定$[x, y, z]$所在的与$XY$平面平行的面为$far$面。根据相似三角形法则，对于$y^{\\prime}$可以得到：</p>\n<script type=\"math/tex; mode=display\">\ny^{\\prime} = \\frac{n}{z}y {\\space}{\\space}{\\space}{\\space}{\\space}x^{\\prime} = \\frac{n}{z}x</script><p>为了推导投影矩阵，我们列出其原点和投影点的关系，当被投影点坐标全部乘以$z$的时候，被投影点坐标变化如下：</p>\n<script type=\"math/tex; mode=display\">\n \\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n \\begin{pmatrix}\n nx/z\\\\\n ny/z\\\\\n unknown\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix}</script><p>因此我们想要求的投影矩阵是执行了如下变化：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}:\n{\\space}\n\\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix}</script><p>根据上面的变换过程我们可以将变换矩阵的确定项先写出来：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}=\n \\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n ? & ? & ? & ?\\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix}</script><p>接下来就是如何确定不确定的这行的值了，在透视投影的可视空间中，发生透视变换后有两个特性：</p>\n<ol>\n<li>所有在$near$面上的点，经过透视投影变换后其坐标值是不变的。</li>\n<li>所有在$far$面上的点，经过透视投影变换后其$z$值是不变的。</li>\n</ol>\n<p>对于特性1，我们可以假定在near平面上的点$(x,y,n,1)^T$，经过变换之后，其坐标仍然保持不变。将所有坐标乘以$n$，得到：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n nx\\\\\n ny\\\\\n n^2\\\\\n n\n\\end{pmatrix}</script><p>通过上面的变换，我们可以得出一个结论——未知行额前两项必定为0，因为经过变换后的$z$值与$x,y$无关。因此假定最后一行为$(0,0,A,B)$，再计算第三行的乘法：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{pmatrix}\n 0 {\\space}\n 0 {\\space}\n A {\\space}\n B \n\\end{pmatrix}\n\\begin{pmatrix}\n x \\\\\n y \\\\\n n \\\\\n 1 \n\\end{pmatrix}\n=\nn^2\n\\Rightarrow \nAn + B = n^2</script><p>同理，利用特性二所有在$far$平面上的点的$z$值不会发生变化：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f^2\\\\\n f\n\\end{pmatrix}\n\n\\Rightarrow \nAf + B = f^2</script><p>联立两个等式，得到：</p>\n<script type=\"math/tex; mode=display\">\nA = f + n</script><script type=\"math/tex; mode=display\">\nB = -nf</script><p>因此变换矩阵$M_{persp{\\to}ortho}^{4\\times4}$的值为：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4} =   \n\\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n 0 & 0 & f+n & -nf \\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix}</script><p>实际上，完成透视变换之后，再进行一次正交投影变换就彻底完成了以上透视投影变换：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp} = M_{ortho}M_{persp{\\to}ortho}</script>","site":{"data":{}},"excerpt":"","more":"<p>视图变换（viewing transform）的主要职责是将3D物体的坐标（我们取标准坐标$(x, y, z)$映射到屏幕的一个个像素点上来。它的过程可以说是比较复杂的，因为在视图变换的过程中很多因素可以决定最后成像的效果。视图变换可以分为四个过程，模型变换（modal transform）、 视角变换（view transform）、投影变换（projection transform）以及视口变换（viewport transformation）。这个过程可以拿拍照片来类比：</p>\n<ol>\n<li>站好位置，摆好姿势（modal transform）</li>\n<li>找好角度，调整相机位置（view transform）</li>\n<li>拍摄照片，将3D场景拍摄到2D的照片（projection transform &amp;&amp; viewport transformation）</li>\n</ol>\n<p>在拍照片的过程中我们模拟了视图变换的过程。首先是模型变换，我们需要将模型从模型坐标变换到世界坐标中来，也就是在拍照过程中让人站好姿势、摆好位置。调整相机位置，也就是调整在世界坐标中从哪个方向去观测。这个过程我们需要确定两个方向，一个方向是观测的朝向，另一个方向就是与观测朝向“向上”的方向，比如说我们朝着$-Z$方向去看，那么“向上”方向就是$Y$方向。当以上过程都完成后，我们需要将3D场景转换到2D屏幕上，就需要通过投影的方式做像素映射。</p>\n<p><img src=\"/images/graphics3/graphics3_transformation.png\" alt=\"\"></p>\n<h2 id=\"相机变换-view-camera-transform\"><a href=\"#相机变换-view-camera-transform\" class=\"headerlink\" title=\"相机变换 view/camera transform\"></a>相机变换 view/camera transform</h2><p>结合在上一篇我们讨论的绕任意轴旋转的变换推导中，我们其实可以很容易使用类似的思路来进行推导相机变换。还记得为什么在相机变换的过程中，为什么除了看向方向（look-at direction）之外表示为$g$，还需要一个“向上”的方向（up direction）表示为$t$，有了着两个方向以及相机的位置$e$。<br>我们在根据坐标系法则就可以建立起一个三位坐标$u,v,w$。定义如下：</p>\n<script type=\"math/tex; mode=display\">\nw =  -\\frac{g}{\\left |\\left | g \\right |   \\right | }</script><script type=\"math/tex; mode=display\">\nu = \\frac{t \\times w }{ \\left |\\left | {t \\times w} \\right |   \\right |  }</script><script type=\"math/tex; mode=display\">\nv = w \\times u</script><p><img src=\"/images/graphics3/graphics3_camera.png\" alt=\"\"><br>摄像机变换就可以看作将$x,y,z$坐标系转换到$u,v,w$坐标系的过程。我们将变换矩阵写作$M_{view}$，令</p>\n<script type=\"math/tex; mode=display\">\nM_{view} = R_{view}T_{view}</script><p>其中$R$是改变相机朝向的的变换矩阵，它的作用是使得$-Z$旋转到看向方向$u$，$Y$旋转到“向上“的方向$v$。$T_{view}$是移动相机位置的矩阵，是一个平移矩阵，可以被表示为：</p>\n<script type=\"math/tex; mode=display\">\nT_{view} =\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}</script><p>旋转的过程在前面的章节有提过，如果需要使用$R$变换矩阵，因此$M$可以被表示为：</p>\n<script type=\"math/tex; mode=display\">\nM_{view} = \n\n\\begin{bmatrix}\nx_u & y_u & z_u & 0\\\\\nx_v & y_v & z_v & 0\\\\\nx_w & y_w & z_w & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & -x_e\\\\\n0 & 1 & 0 & -y_e\\\\\n0 & 0 & 1 & -z_e\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}</script><h2 id=\"投影变换-pojection-transform\"><a href=\"#投影变换-pojection-transform\" class=\"headerlink\" title=\"投影变换 pojection transform\"></a>投影变换 pojection transform</h2><p>投影变换的过程主要是将3D的点投影到2D的屏幕上来，根据变换条件的不同，可以将投影区分为正交投影和透视投影。如下图所示展现了两种投影的变换方式和成像结果。<br><img src=\"/images/graphics3/graphics3_banner.png\" alt=\"\"></p>\n<h3 id=\"正交投影-Orthographic-Projection-Transformation\"><a href=\"#正交投影-Orthographic-Projection-Transformation\" class=\"headerlink\" title=\"正交投影 Orthographic Projection Transformation\"></a>正交投影 Orthographic Projection Transformation</h3><p>正交投影很好理解，在正交投影之后图形中所有点的的相对位置都不会发生改变，可以将其看作直接将图形“压扁”，然后放置在某一平面上。<br><img src=\"/images/graphics3/graphic3_orthographic.png\" alt=\"\"><br>在实际渲染过程中，我们总是希望在某个空间区域来渲染图形，而非根据整个视图区域来做渲染。假设渲染发生在一个沿着$Z$轴负方向，底面（bottom）与$XY$平面平行的一个立方体。这时候可以定义左右面（left, right）以及近远面（near, far），以及上下面（top, bottom）用以下代数表示：</p>\n<script type=\"math/tex; mode=display\">\nx = l = left{\\space}plane</script><script type=\"math/tex; mode=display\">\nx = r = right{\\space}plane</script><script type=\"math/tex; mode=display\">\ny = v = bottom{\\space}plane</script><script type=\"math/tex; mode=display\">\ny = t = left{\\space}plane</script><script type=\"math/tex; mode=display\">\nz = n = near{\\space}plane</script><script type=\"math/tex; mode=display\">\nz = f = far{\\space}plane</script><p>简单来说，正交投影的主要原理是将上述区域变换到一个”正则、规范、标准“的立方体$[-1, 1]^3$中来。这个变换过程可以分解为两个变换：</p>\n<ol>\n<li>将渲染盒子平移到以原点为中心的位置，即每个定点到投影平面的距离为 边长/2</li>\n<li>将渲染盒子缩放为立方体$[-1, 1]^3$<br><img src=\"/images/graphics3/graphics3_orthographic_transform.png\" alt=\"\"><br>这个过程可以用变换矩阵表示为：<script type=\"math/tex; mode=display\">\nM_{ortho} = \n\\begin{bmatrix}\n\\frac{2}{r - l} & 0 & 0 & 0\\\\\n0 & \\frac{2}{t - b} & 0 & 0\\\\\n0 & 0 & \\frac{2}{n - f} & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n\\begin{bmatrix}\n1 & 0 & 0 & -\\frac{r+l}{2}\\\\\n0 & 1 & 0 & -\\frac{t+b}{2}\\\\\n0 & 0 & 1 & -\\frac{n+f}{2}\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}</script><h3 id=\"透视投影-Perspective-Projection-Transformation\"><a href=\"#透视投影-Perspective-Projection-Transformation\" class=\"headerlink\" title=\"透视投影 Perspective Projection Transformation\"></a>透视投影 Perspective Projection Transformation</h3>透视投影和正交投影最大的区别在于，透视投影的过程不是“平行的”，投影的线最终会相交。因为透视投影需要实现真实的透视关系，也就是相等大小的物体，处于场景近端他会显示得更大，处于场景远端它会显示得更小。对于任意一点的投影过程可以用下图来表示：</li>\n</ol>\n<p><img src=\"/images/graphics3/graphic3_orthographic_point.png\" alt=\"\"></p>\n<p>对于任意点$[x, y, z]$, 经过透视投影变换后到投影平面上，形成$[x^{\\prime}, y^{\\prime}, z^{\\prime}]$。图中的$z = -n$为投影平面，也就是我们的$near$面，假定$[x, y, z]$所在的与$XY$平面平行的面为$far$面。根据相似三角形法则，对于$y^{\\prime}$可以得到：</p>\n<script type=\"math/tex; mode=display\">\ny^{\\prime} = \\frac{n}{z}y {\\space}{\\space}{\\space}{\\space}{\\space}x^{\\prime} = \\frac{n}{z}x</script><p>为了推导投影矩阵，我们列出其原点和投影点的关系，当被投影点坐标全部乘以$z$的时候，被投影点坐标变化如下：</p>\n<script type=\"math/tex; mode=display\">\n \\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n \\begin{pmatrix}\n nx/z\\\\\n ny/z\\\\\n unknown\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix}</script><p>因此我们想要求的投影矩阵是执行了如下变化：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}:\n{\\space}\n\\begin{pmatrix}\n x\\\\\n y\\\\\n z\\\\\n 1\n\\end{pmatrix}\n==\n\n \\begin{pmatrix}\n nx\\\\\n ny\\\\\n still{\\space}unknown\\\\\n z\n\\end{pmatrix}</script><p>根据上面的变换过程我们可以将变换矩阵的确定项先写出来：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}=\n \\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n ? & ? & ? & ?\\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix}</script><p>接下来就是如何确定不确定的这行的值了，在透视投影的可视空间中，发生透视变换后有两个特性：</p>\n<ol>\n<li>所有在$near$面上的点，经过透视投影变换后其坐标值是不变的。</li>\n<li>所有在$far$面上的点，经过透视投影变换后其$z$值是不变的。</li>\n</ol>\n<p>对于特性1，我们可以假定在near平面上的点$(x,y,n,1)^T$，经过变换之后，其坐标仍然保持不变。将所有坐标乘以$n$，得到：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n x\\\\\n y\\\\\n n\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n nx\\\\\n ny\\\\\n n^2\\\\\n n\n\\end{pmatrix}</script><p>通过上面的变换，我们可以得出一个结论——未知行额前两项必定为0，因为经过变换后的$z$值与$x,y$无关。因此假定最后一行为$(0,0,A,B)$，再计算第三行的乘法：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{pmatrix}\n 0 {\\space}\n 0 {\\space}\n A {\\space}\n B \n\\end{pmatrix}\n\\begin{pmatrix}\n x \\\\\n y \\\\\n n \\\\\n 1 \n\\end{pmatrix}\n=\nn^2\n\\Rightarrow \nAn + B = n^2</script><p>同理，利用特性二所有在$far$平面上的点的$z$值不会发生变化：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4}\n \\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n\\Rightarrow \n\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f\\\\\n 1\n\\end{pmatrix}\n==\n\\begin{pmatrix}\n 0\\\\\n 0\\\\\n f^2\\\\\n f\n\\end{pmatrix}\n\n\\Rightarrow \nAf + B = f^2</script><p>联立两个等式，得到：</p>\n<script type=\"math/tex; mode=display\">\nA = f + n</script><script type=\"math/tex; mode=display\">\nB = -nf</script><p>因此变换矩阵$M_{persp{\\to}ortho}^{4\\times4}$的值为：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp{\\to}ortho}^{4\\times4} =   \n\\begin{bmatrix}\n n & 0 & 0 & 0\\\\\n 0 & n & 0 & 0\\\\\n 0 & 0 & f+n & -nf \\\\\n 0 & 0 & 0 &1 \n\\end{bmatrix}</script><p>实际上，完成透视变换之后，再进行一次正交投影变换就彻底完成了以上透视投影变换：</p>\n<script type=\"math/tex; mode=display\">\nM_{persp} = M_{ortho}M_{persp{\\to}ortho}</script>"},{"title":"计算机图形学4 ——  光栅化","index_img":"/images/graphics4/graphics4_banner.png","date":"2020-09-01T13:09:11.000Z","math":true,"_content":"\n> 总体来说，栅格化这个术语可以用于任何将向量图形转换成位图的过程,在通常的应用中，这个术语用来表示在计算机上显示三维形状的流行渲染算法。\n\n> 栅格化目前是生成实时三维计算机图形最流行的算法。实时应用需要立即响应用户输入，并且通常需要至少每秒 24 帧的速率。辐射着色、光线跟踪等其它渲染技术不同，栅格化的速度非常快，但是由于它不是根据光传输的物理规律进行处理的，所以无法正确模拟许多复杂真实光照环境，只能达到足够欺骗人类眼睛的程度。\n\n以上是Wikipedia对于光栅化的解释，大致上来说，光栅化是顶点数据变换为屏幕像素数据的过程。在光栅化中，我们需要考虑如何将位置信息数据转化为像素信息数据，例如如何在屏幕上进行展示一条线、一个圆，一个三角形。如下图所示，在屏幕中实际显示的最小单位是一个像素点。如何在屏幕中绘制像素信息，或使用哪些像素值来表示图形，是光栅化需要考虑的问题。\n\n光栅化的基本过程可以用以下伪代码来表示：\n```\nfor (T in trangels):\n    for (P in pixels):\n        determine if P is inside T\n```\n## 像素（pixels）的表示\n我们使用一个整数坐标点代表一个像素，像素作为光栅化的最小单位，其尺寸是单位大小为1的正方形。其用其中心点$x, y$来表示其位置坐标。如下图所示：\n![](/images/graphics4/graphics4_pixels.png)\n## 直线光栅化表示\n和绘制一个点相比，绘制一条直线就需要我们关注如何通过直线中每个像素点的位置来表示这个像素点。在photoshop中绘制一条直线时，应用自动产生的像素点的位置。通过下图可以看出，在绘制一条水平或者垂直的直线的时候，只需要连续在对应方向进行绘制即可。但是当直线的斜率为$(0, \\infty)$时，表示一条直线就困难很多。此时无法利用像素点直接还原这条直线，只能通过类似表示的方式来表示这条直线。如何绘制直线，演进出很多算法，下面介绍两种直线绘制算法DDA和Bresenham。\n![](/images/graphics4/graphics4_lines.png)\n### DDA(Digital differience analyzer)\nDDA的绘制过程比较简单，绘制像素的位置都由直线的斜率来决定。指定直线的斜率$k$，每个像素点$X, Y$\n1. 如果斜率$\\left | k \\right |  < 1$，则$X = X + 1$, $Y = Y + k$\n2. 如果斜率$\\left | k \\right |  > 1$，则$X = X + 1/k$, $Y = Y + 1$\n以上所有结果都进行四舍五入进行取整表示，DDA的绘制过程可以通过以下代码来进行表示：\n\n``` cpp\n// calculate dx , dy\ndx = X1 - X0;\ndy = Y1 - Y0;\n\n// Depending upon absolute value of dx & dy\n// choose number of steps to put pixel as\nsteps = abs(dx) > abs(dy) ? abs(dx) : abs(dy);\n\n// calculate increment in x & y for each steps\nXinc = dx / (float) steps;\nYinc = dy / (float) steps;\n\n// Put pixel for each step\nX = X0;\nY = Y0;\nfor (int i = 0; i <= steps; i++)\n{\n    putpixel (X, Y, RED);\n    X += Xinc;\n    Y += Yinc;\n}\n```\n\n### Bresenham\nDDA算法按照直线的函数表达式来绘制，但是并不代表它的准确性和效率就高。实际上，在绘制过程中对值取四舍五入的方式不仅浪费性能，而且可能会造成绘制不准。Bresenham算法有效地解决了这些问题，它在绘制过程中，通过对两个备选绘制点的中值进行比较来决定绘制点的位置。\n\n如下图所示，在斜率 $\\left | k \\right |  < 1$ 的情况下，当我们绘制下一个点 $(x_k+1, unknown)$ 时，有两个备选点 $(x_k+1, y_k + 1)$ 以及 $(x_k+1, y_k)$ 。这时候我们只需要找出与直线与 $x = x_k + 1$ 相交的交点距离哪个备选点更近即可。\n![](/images/graphics4/graphics4_bresenham.png)\n观察实际$y$的增长值$y_d$，如果$y_d > 0.5$，则取上面的点，否则取下面的点。实际Bresenham过程也比较简单，但是这里比较涉及到了浮点数$0.5$的计算，性能会退化地和DDA一致。为了避免使用浮点数计算，使用了一种比较巧妙的计算方法。在以下两个条件下做讨论：\n1. 所有的直线的斜率$k\\in(0,1)$\n2. $x_1 < x_2$ 且 $y_1 < y_2$\n\n此时，每次绘制像素时：\n1. $X$方向都会向右移动一格\n2. 为了得到$Y$方向的增长值，先计算 $\\Delta{y} = (y_2 - y_1)$ $\\Delta{x} =(x_2 - x_1)$，根据斜率的性质，可以得出 $\\Delta{y} = k\\Delta{x}$ \n3. 当 $y$ 增长1个单位时，$x$ 需要增长$1/k$个单位\n4. 我们规定 $2\\Delta{y} - \\Delta{x}$ 为初始判定值$d$，每次绘制时$d += 2\\Delta{y}$\n5. 当 $d >= 0$的时候，说明$Y$轴方向的增长量超过了1，令$y + 1$，然后将$d - 2\\Delta{x}$。\n\n以下是代码表示:\n\n``` cpp\nvoid bresenham(int x1, int y1, int x2, int y2) { \n    int m_new = 2 * (y2 - y1); \n    int slope_error_new = m_new - (x2 - x1); \n    for (int x = x1, y = y1; x <= x2; x++) \n    { \n        cout << \"(\" << x << \",\" << y << \")\\n\"; \n\n        // Add slope to increment angle formed \n        slope_error_new += m_new; \n\n        // Slope error reached limit, time to \n        // increment y and update slope error. \n        if (slope_error_new >= 0) \n        { \n            y++; \n            slope_error_new  -= 2 * (x2 - x1); \n        } \n    } \n}\n```\n## 图形光栅化表示\n下面以三角形为例，介绍图形的光栅化过程。在图形光栅化的过程中，我们需要逐行扫描每个像素，判断像素是否处于图形之中，如果处于图形之中就将其采样。\n\n![](/images/graphics4/graphics4_sample.png)\n\n如何判断点$Q$是否在三角形内呢？对于三角形而言，确定三角形的形状和位置需要确定三角形的三个定点$P_1$、$P_2$、$P_3$。利用向量叉乘的特性，分别计算$\\overrightarrow{P_1P_2} \\times \\overrightarrow{P_1Q}$和$\\overrightarrow{P_2P_3} \\times \\overrightarrow{P_2Q}$以及$\\overrightarrow{P_3P_1} \\times \\overrightarrow{P_3Q}$的值是否是相同正负号的。如果是就说明点$Q$在三角形$P_1P_2P_3$内。\n![](/images/graphics4/graphics4_inside.png)\n\n逐行扫描对于光栅化过程来说有点过于耗费性能，因为很多情况下区域内只有很小的宇哥图形。如果逐行去扫描不需要着色的像素，会造成严重的性能浪费。因此可以使用一个盒子边界来包裹需要扫描的像素区域，只在这个区域内进行光栅化的过程，大幅提升光栅化的性能。这个特性实际上适用于很多图形学的场景，比如碰撞检测、抗锯齿。\n![](/images/graphics4/graphics4_bound_box.png)","source":"_posts/ComputerGraphics4.md","raw":"---\ntitle: 计算机图形学4 ——  光栅化\ntags: [计算机图形学, 光栅化, bresenham]\ncategories: [GAMES101]\nindex_img: /images/graphics4/graphics4_banner.png\ndate: 2020-09-01 21:09:11\nmath: true\n---\n\n> 总体来说，栅格化这个术语可以用于任何将向量图形转换成位图的过程,在通常的应用中，这个术语用来表示在计算机上显示三维形状的流行渲染算法。\n\n> 栅格化目前是生成实时三维计算机图形最流行的算法。实时应用需要立即响应用户输入，并且通常需要至少每秒 24 帧的速率。辐射着色、光线跟踪等其它渲染技术不同，栅格化的速度非常快，但是由于它不是根据光传输的物理规律进行处理的，所以无法正确模拟许多复杂真实光照环境，只能达到足够欺骗人类眼睛的程度。\n\n以上是Wikipedia对于光栅化的解释，大致上来说，光栅化是顶点数据变换为屏幕像素数据的过程。在光栅化中，我们需要考虑如何将位置信息数据转化为像素信息数据，例如如何在屏幕上进行展示一条线、一个圆，一个三角形。如下图所示，在屏幕中实际显示的最小单位是一个像素点。如何在屏幕中绘制像素信息，或使用哪些像素值来表示图形，是光栅化需要考虑的问题。\n\n光栅化的基本过程可以用以下伪代码来表示：\n```\nfor (T in trangels):\n    for (P in pixels):\n        determine if P is inside T\n```\n## 像素（pixels）的表示\n我们使用一个整数坐标点代表一个像素，像素作为光栅化的最小单位，其尺寸是单位大小为1的正方形。其用其中心点$x, y$来表示其位置坐标。如下图所示：\n![](/images/graphics4/graphics4_pixels.png)\n## 直线光栅化表示\n和绘制一个点相比，绘制一条直线就需要我们关注如何通过直线中每个像素点的位置来表示这个像素点。在photoshop中绘制一条直线时，应用自动产生的像素点的位置。通过下图可以看出，在绘制一条水平或者垂直的直线的时候，只需要连续在对应方向进行绘制即可。但是当直线的斜率为$(0, \\infty)$时，表示一条直线就困难很多。此时无法利用像素点直接还原这条直线，只能通过类似表示的方式来表示这条直线。如何绘制直线，演进出很多算法，下面介绍两种直线绘制算法DDA和Bresenham。\n![](/images/graphics4/graphics4_lines.png)\n### DDA(Digital differience analyzer)\nDDA的绘制过程比较简单，绘制像素的位置都由直线的斜率来决定。指定直线的斜率$k$，每个像素点$X, Y$\n1. 如果斜率$\\left | k \\right |  < 1$，则$X = X + 1$, $Y = Y + k$\n2. 如果斜率$\\left | k \\right |  > 1$，则$X = X + 1/k$, $Y = Y + 1$\n以上所有结果都进行四舍五入进行取整表示，DDA的绘制过程可以通过以下代码来进行表示：\n\n``` cpp\n// calculate dx , dy\ndx = X1 - X0;\ndy = Y1 - Y0;\n\n// Depending upon absolute value of dx & dy\n// choose number of steps to put pixel as\nsteps = abs(dx) > abs(dy) ? abs(dx) : abs(dy);\n\n// calculate increment in x & y for each steps\nXinc = dx / (float) steps;\nYinc = dy / (float) steps;\n\n// Put pixel for each step\nX = X0;\nY = Y0;\nfor (int i = 0; i <= steps; i++)\n{\n    putpixel (X, Y, RED);\n    X += Xinc;\n    Y += Yinc;\n}\n```\n\n### Bresenham\nDDA算法按照直线的函数表达式来绘制，但是并不代表它的准确性和效率就高。实际上，在绘制过程中对值取四舍五入的方式不仅浪费性能，而且可能会造成绘制不准。Bresenham算法有效地解决了这些问题，它在绘制过程中，通过对两个备选绘制点的中值进行比较来决定绘制点的位置。\n\n如下图所示，在斜率 $\\left | k \\right |  < 1$ 的情况下，当我们绘制下一个点 $(x_k+1, unknown)$ 时，有两个备选点 $(x_k+1, y_k + 1)$ 以及 $(x_k+1, y_k)$ 。这时候我们只需要找出与直线与 $x = x_k + 1$ 相交的交点距离哪个备选点更近即可。\n![](/images/graphics4/graphics4_bresenham.png)\n观察实际$y$的增长值$y_d$，如果$y_d > 0.5$，则取上面的点，否则取下面的点。实际Bresenham过程也比较简单，但是这里比较涉及到了浮点数$0.5$的计算，性能会退化地和DDA一致。为了避免使用浮点数计算，使用了一种比较巧妙的计算方法。在以下两个条件下做讨论：\n1. 所有的直线的斜率$k\\in(0,1)$\n2. $x_1 < x_2$ 且 $y_1 < y_2$\n\n此时，每次绘制像素时：\n1. $X$方向都会向右移动一格\n2. 为了得到$Y$方向的增长值，先计算 $\\Delta{y} = (y_2 - y_1)$ $\\Delta{x} =(x_2 - x_1)$，根据斜率的性质，可以得出 $\\Delta{y} = k\\Delta{x}$ \n3. 当 $y$ 增长1个单位时，$x$ 需要增长$1/k$个单位\n4. 我们规定 $2\\Delta{y} - \\Delta{x}$ 为初始判定值$d$，每次绘制时$d += 2\\Delta{y}$\n5. 当 $d >= 0$的时候，说明$Y$轴方向的增长量超过了1，令$y + 1$，然后将$d - 2\\Delta{x}$。\n\n以下是代码表示:\n\n``` cpp\nvoid bresenham(int x1, int y1, int x2, int y2) { \n    int m_new = 2 * (y2 - y1); \n    int slope_error_new = m_new - (x2 - x1); \n    for (int x = x1, y = y1; x <= x2; x++) \n    { \n        cout << \"(\" << x << \",\" << y << \")\\n\"; \n\n        // Add slope to increment angle formed \n        slope_error_new += m_new; \n\n        // Slope error reached limit, time to \n        // increment y and update slope error. \n        if (slope_error_new >= 0) \n        { \n            y++; \n            slope_error_new  -= 2 * (x2 - x1); \n        } \n    } \n}\n```\n## 图形光栅化表示\n下面以三角形为例，介绍图形的光栅化过程。在图形光栅化的过程中，我们需要逐行扫描每个像素，判断像素是否处于图形之中，如果处于图形之中就将其采样。\n\n![](/images/graphics4/graphics4_sample.png)\n\n如何判断点$Q$是否在三角形内呢？对于三角形而言，确定三角形的形状和位置需要确定三角形的三个定点$P_1$、$P_2$、$P_3$。利用向量叉乘的特性，分别计算$\\overrightarrow{P_1P_2} \\times \\overrightarrow{P_1Q}$和$\\overrightarrow{P_2P_3} \\times \\overrightarrow{P_2Q}$以及$\\overrightarrow{P_3P_1} \\times \\overrightarrow{P_3Q}$的值是否是相同正负号的。如果是就说明点$Q$在三角形$P_1P_2P_3$内。\n![](/images/graphics4/graphics4_inside.png)\n\n逐行扫描对于光栅化过程来说有点过于耗费性能，因为很多情况下区域内只有很小的宇哥图形。如果逐行去扫描不需要着色的像素，会造成严重的性能浪费。因此可以使用一个盒子边界来包裹需要扫描的像素区域，只在这个区域内进行光栅化的过程，大幅提升光栅化的性能。这个特性实际上适用于很多图形学的场景，比如碰撞检测、抗锯齿。\n![](/images/graphics4/graphics4_bound_box.png)","slug":"ComputerGraphics4","published":1,"updated":"2020-10-03T07:40:21.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wac000gnwqc30eg3ffi","content":"<blockquote>\n<p>总体来说，栅格化这个术语可以用于任何将向量图形转换成位图的过程,在通常的应用中，这个术语用来表示在计算机上显示三维形状的流行渲染算法。</p>\n<p>栅格化目前是生成实时三维计算机图形最流行的算法。实时应用需要立即响应用户输入，并且通常需要至少每秒 24 帧的速率。辐射着色、光线跟踪等其它渲染技术不同，栅格化的速度非常快，但是由于它不是根据光传输的物理规律进行处理的，所以无法正确模拟许多复杂真实光照环境，只能达到足够欺骗人类眼睛的程度。</p>\n</blockquote>\n<p>以上是Wikipedia对于光栅化的解释，大致上来说，光栅化是顶点数据变换为屏幕像素数据的过程。在光栅化中，我们需要考虑如何将位置信息数据转化为像素信息数据，例如如何在屏幕上进行展示一条线、一个圆，一个三角形。如下图所示，在屏幕中实际显示的最小单位是一个像素点。如何在屏幕中绘制像素信息，或使用哪些像素值来表示图形，是光栅化需要考虑的问题。</p>\n<p>光栅化的基本过程可以用以下伪代码来表示：<br><pre><code class=\"hljs properties\"><span class=\"hljs-attr\">for</span> <span class=\"hljs-string\">(T in trangels):</span>\n    <span class=\"hljs-attr\">for</span> <span class=\"hljs-string\">(P in pixels):</span>\n        <span class=\"hljs-attr\">determine</span> <span class=\"hljs-string\">if P is inside T</span></code></pre></p>\n<h2 id=\"像素（pixels）的表示\"><a href=\"#像素（pixels）的表示\" class=\"headerlink\" title=\"像素（pixels）的表示\"></a>像素（pixels）的表示</h2><p>我们使用一个整数坐标点代表一个像素，像素作为光栅化的最小单位，其尺寸是单位大小为1的正方形。其用其中心点$x, y$来表示其位置坐标。如下图所示：<br><img src=\"/images/graphics4/graphics4_pixels.png\" alt=\"\"></p>\n<h2 id=\"直线光栅化表示\"><a href=\"#直线光栅化表示\" class=\"headerlink\" title=\"直线光栅化表示\"></a>直线光栅化表示</h2><p>和绘制一个点相比，绘制一条直线就需要我们关注如何通过直线中每个像素点的位置来表示这个像素点。在photoshop中绘制一条直线时，应用自动产生的像素点的位置。通过下图可以看出，在绘制一条水平或者垂直的直线的时候，只需要连续在对应方向进行绘制即可。但是当直线的斜率为$(0, \\infty)$时，表示一条直线就困难很多。此时无法利用像素点直接还原这条直线，只能通过类似表示的方式来表示这条直线。如何绘制直线，演进出很多算法，下面介绍两种直线绘制算法DDA和Bresenham。<br><img src=\"/images/graphics4/graphics4_lines.png\" alt=\"\"></p>\n<h3 id=\"DDA-Digital-differience-analyzer\"><a href=\"#DDA-Digital-differience-analyzer\" class=\"headerlink\" title=\"DDA(Digital differience analyzer)\"></a>DDA(Digital differience analyzer)</h3><p>DDA的绘制过程比较简单，绘制像素的位置都由直线的斜率来决定。指定直线的斜率$k$，每个像素点$X, Y$</p>\n<ol>\n<li>如果斜率$\\left | k \\right |  &lt; 1$，则$X = X + 1$, $Y = Y + k$</li>\n<li>如果斜率$\\left | k \\right |  &gt; 1$，则$X = X + 1/k$, $Y = Y + 1$<br>以上所有结果都进行四舍五入进行取整表示，DDA的绘制过程可以通过以下代码来进行表示：</li>\n</ol>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// calculate dx , dy</span>\ndx = X1 - X0;\ndy = Y1 - Y0;\n\n<span class=\"hljs-comment\">// Depending upon absolute value of dx &amp; dy</span>\n<span class=\"hljs-comment\">// choose number of steps to put pixel as</span>\nsteps = <span class=\"hljs-built_in\">abs</span>(dx) &gt; <span class=\"hljs-built_in\">abs</span>(dy) ? <span class=\"hljs-built_in\">abs</span>(dx) : <span class=\"hljs-built_in\">abs</span>(dy);\n\n<span class=\"hljs-comment\">// calculate increment in x &amp; y for each steps</span>\nXinc = dx / (<span class=\"hljs-keyword\">float</span>) steps;\nYinc = dy / (<span class=\"hljs-keyword\">float</span>) steps;\n\n<span class=\"hljs-comment\">// Put pixel for each step</span>\nX = X0;\nY = Y0;\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= steps; i++)\n&#123;\n    putpixel (X, Y, RED);\n    X += Xinc;\n    Y += Yinc;\n&#125;</code></pre>\n<h3 id=\"Bresenham\"><a href=\"#Bresenham\" class=\"headerlink\" title=\"Bresenham\"></a>Bresenham</h3><p>DDA算法按照直线的函数表达式来绘制，但是并不代表它的准确性和效率就高。实际上，在绘制过程中对值取四舍五入的方式不仅浪费性能，而且可能会造成绘制不准。Bresenham算法有效地解决了这些问题，它在绘制过程中，通过对两个备选绘制点的中值进行比较来决定绘制点的位置。</p>\n<p>如下图所示，在斜率 $\\left | k \\right |  &lt; 1$ 的情况下，当我们绘制下一个点 $(x_k+1, unknown)$ 时，有两个备选点 $(x_k+1, y_k + 1)$ 以及 $(x_k+1, y_k)$ 。这时候我们只需要找出与直线与 $x = x_k + 1$ 相交的交点距离哪个备选点更近即可。<br><img src=\"/images/graphics4/graphics4_bresenham.png\" alt=\"\"><br>观察实际$y$的增长值$y_d$，如果$y_d &gt; 0.5$，则取上面的点，否则取下面的点。实际Bresenham过程也比较简单，但是这里比较涉及到了浮点数$0.5$的计算，性能会退化地和DDA一致。为了避免使用浮点数计算，使用了一种比较巧妙的计算方法。在以下两个条件下做讨论：</p>\n<ol>\n<li>所有的直线的斜率$k\\in(0,1)$</li>\n<li>$x_1 &lt; x_2$ 且 $y_1 &lt; y_2$</li>\n</ol>\n<p>此时，每次绘制像素时：</p>\n<ol>\n<li>$X$方向都会向右移动一格</li>\n<li>为了得到$Y$方向的增长值，先计算 $\\Delta{y} = (y_2 - y_1)$ $\\Delta{x} =(x_2 - x_1)$，根据斜率的性质，可以得出 $\\Delta{y} = k\\Delta{x}$ </li>\n<li>当 $y$ 增长1个单位时，$x$ 需要增长$1/k$个单位</li>\n<li>我们规定 $2\\Delta{y} - \\Delta{x}$ 为初始判定值$d$，每次绘制时$d += 2\\Delta{y}$</li>\n<li>当 $d &gt;= 0$的时候，说明$Y$轴方向的增长量超过了1，令$y + 1$，然后将$d - 2\\Delta{x}$。</li>\n</ol>\n<p>以下是代码表示:</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bresenham</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x1, <span class=\"hljs-keyword\">int</span> y1, <span class=\"hljs-keyword\">int</span> x2, <span class=\"hljs-keyword\">int</span> y2)</span> </span>&#123; \n    <span class=\"hljs-keyword\">int</span> m_new = <span class=\"hljs-number\">2</span> * (y2 - y1); \n    <span class=\"hljs-keyword\">int</span> slope_error_new = m_new - (x2 - x1); \n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> x = x1, y = y1; x &lt;= x2; x++) \n    &#123; \n        <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class=\"hljs-string\">&quot;)\\n&quot;</span>; \n\n        <span class=\"hljs-comment\">// Add slope to increment angle formed </span>\n        slope_error_new += m_new; \n\n        <span class=\"hljs-comment\">// Slope error reached limit, time to </span>\n        <span class=\"hljs-comment\">// increment y and update slope error. </span>\n        <span class=\"hljs-keyword\">if</span> (slope_error_new &gt;= <span class=\"hljs-number\">0</span>) \n        &#123; \n            y++; \n            slope_error_new  -= <span class=\"hljs-number\">2</span> * (x2 - x1); \n        &#125; \n    &#125; \n&#125;</code></pre>\n<h2 id=\"图形光栅化表示\"><a href=\"#图形光栅化表示\" class=\"headerlink\" title=\"图形光栅化表示\"></a>图形光栅化表示</h2><p>下面以三角形为例，介绍图形的光栅化过程。在图形光栅化的过程中，我们需要逐行扫描每个像素，判断像素是否处于图形之中，如果处于图形之中就将其采样。</p>\n<p><img src=\"/images/graphics4/graphics4_sample.png\" alt=\"\"></p>\n<p>如何判断点$Q$是否在三角形内呢？对于三角形而言，确定三角形的形状和位置需要确定三角形的三个定点$P_1$、$P_2$、$P_3$。利用向量叉乘的特性，分别计算$\\overrightarrow{P_1P_2} \\times \\overrightarrow{P_1Q}$和$\\overrightarrow{P_2P_3} \\times \\overrightarrow{P_2Q}$以及$\\overrightarrow{P_3P_1} \\times \\overrightarrow{P_3Q}$的值是否是相同正负号的。如果是就说明点$Q$在三角形$P_1P_2P_3$内。<br><img src=\"/images/graphics4/graphics4_inside.png\" alt=\"\"></p>\n<p>逐行扫描对于光栅化过程来说有点过于耗费性能，因为很多情况下区域内只有很小的宇哥图形。如果逐行去扫描不需要着色的像素，会造成严重的性能浪费。因此可以使用一个盒子边界来包裹需要扫描的像素区域，只在这个区域内进行光栅化的过程，大幅提升光栅化的性能。这个特性实际上适用于很多图形学的场景，比如碰撞检测、抗锯齿。<br><img src=\"/images/graphics4/graphics4_bound_box.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>总体来说，栅格化这个术语可以用于任何将向量图形转换成位图的过程,在通常的应用中，这个术语用来表示在计算机上显示三维形状的流行渲染算法。</p>\n<p>栅格化目前是生成实时三维计算机图形最流行的算法。实时应用需要立即响应用户输入，并且通常需要至少每秒 24 帧的速率。辐射着色、光线跟踪等其它渲染技术不同，栅格化的速度非常快，但是由于它不是根据光传输的物理规律进行处理的，所以无法正确模拟许多复杂真实光照环境，只能达到足够欺骗人类眼睛的程度。</p>\n</blockquote>\n<p>以上是Wikipedia对于光栅化的解释，大致上来说，光栅化是顶点数据变换为屏幕像素数据的过程。在光栅化中，我们需要考虑如何将位置信息数据转化为像素信息数据，例如如何在屏幕上进行展示一条线、一个圆，一个三角形。如下图所示，在屏幕中实际显示的最小单位是一个像素点。如何在屏幕中绘制像素信息，或使用哪些像素值来表示图形，是光栅化需要考虑的问题。</p>\n<p>光栅化的基本过程可以用以下伪代码来表示：<br><pre><code class=\"hljs properties\"><span class=\"hljs-attr\">for</span> <span class=\"hljs-string\">(T in trangels):</span>\n    <span class=\"hljs-attr\">for</span> <span class=\"hljs-string\">(P in pixels):</span>\n        <span class=\"hljs-attr\">determine</span> <span class=\"hljs-string\">if P is inside T</span></code></pre></p>\n<h2 id=\"像素（pixels）的表示\"><a href=\"#像素（pixels）的表示\" class=\"headerlink\" title=\"像素（pixels）的表示\"></a>像素（pixels）的表示</h2><p>我们使用一个整数坐标点代表一个像素，像素作为光栅化的最小单位，其尺寸是单位大小为1的正方形。其用其中心点$x, y$来表示其位置坐标。如下图所示：<br><img src=\"/images/graphics4/graphics4_pixels.png\" alt=\"\"></p>\n<h2 id=\"直线光栅化表示\"><a href=\"#直线光栅化表示\" class=\"headerlink\" title=\"直线光栅化表示\"></a>直线光栅化表示</h2><p>和绘制一个点相比，绘制一条直线就需要我们关注如何通过直线中每个像素点的位置来表示这个像素点。在photoshop中绘制一条直线时，应用自动产生的像素点的位置。通过下图可以看出，在绘制一条水平或者垂直的直线的时候，只需要连续在对应方向进行绘制即可。但是当直线的斜率为$(0, \\infty)$时，表示一条直线就困难很多。此时无法利用像素点直接还原这条直线，只能通过类似表示的方式来表示这条直线。如何绘制直线，演进出很多算法，下面介绍两种直线绘制算法DDA和Bresenham。<br><img src=\"/images/graphics4/graphics4_lines.png\" alt=\"\"></p>\n<h3 id=\"DDA-Digital-differience-analyzer\"><a href=\"#DDA-Digital-differience-analyzer\" class=\"headerlink\" title=\"DDA(Digital differience analyzer)\"></a>DDA(Digital differience analyzer)</h3><p>DDA的绘制过程比较简单，绘制像素的位置都由直线的斜率来决定。指定直线的斜率$k$，每个像素点$X, Y$</p>\n<ol>\n<li>如果斜率$\\left | k \\right |  &lt; 1$，则$X = X + 1$, $Y = Y + k$</li>\n<li>如果斜率$\\left | k \\right |  &gt; 1$，则$X = X + 1/k$, $Y = Y + 1$<br>以上所有结果都进行四舍五入进行取整表示，DDA的绘制过程可以通过以下代码来进行表示：</li>\n</ol>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// calculate dx , dy</span>\ndx = X1 - X0;\ndy = Y1 - Y0;\n\n<span class=\"hljs-comment\">// Depending upon absolute value of dx &amp; dy</span>\n<span class=\"hljs-comment\">// choose number of steps to put pixel as</span>\nsteps = <span class=\"hljs-built_in\">abs</span>(dx) &gt; <span class=\"hljs-built_in\">abs</span>(dy) ? <span class=\"hljs-built_in\">abs</span>(dx) : <span class=\"hljs-built_in\">abs</span>(dy);\n\n<span class=\"hljs-comment\">// calculate increment in x &amp; y for each steps</span>\nXinc = dx / (<span class=\"hljs-keyword\">float</span>) steps;\nYinc = dy / (<span class=\"hljs-keyword\">float</span>) steps;\n\n<span class=\"hljs-comment\">// Put pixel for each step</span>\nX = X0;\nY = Y0;\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= steps; i++)\n&#123;\n    putpixel (X, Y, RED);\n    X += Xinc;\n    Y += Yinc;\n&#125;</code></pre>\n<h3 id=\"Bresenham\"><a href=\"#Bresenham\" class=\"headerlink\" title=\"Bresenham\"></a>Bresenham</h3><p>DDA算法按照直线的函数表达式来绘制，但是并不代表它的准确性和效率就高。实际上，在绘制过程中对值取四舍五入的方式不仅浪费性能，而且可能会造成绘制不准。Bresenham算法有效地解决了这些问题，它在绘制过程中，通过对两个备选绘制点的中值进行比较来决定绘制点的位置。</p>\n<p>如下图所示，在斜率 $\\left | k \\right |  &lt; 1$ 的情况下，当我们绘制下一个点 $(x_k+1, unknown)$ 时，有两个备选点 $(x_k+1, y_k + 1)$ 以及 $(x_k+1, y_k)$ 。这时候我们只需要找出与直线与 $x = x_k + 1$ 相交的交点距离哪个备选点更近即可。<br><img src=\"/images/graphics4/graphics4_bresenham.png\" alt=\"\"><br>观察实际$y$的增长值$y_d$，如果$y_d &gt; 0.5$，则取上面的点，否则取下面的点。实际Bresenham过程也比较简单，但是这里比较涉及到了浮点数$0.5$的计算，性能会退化地和DDA一致。为了避免使用浮点数计算，使用了一种比较巧妙的计算方法。在以下两个条件下做讨论：</p>\n<ol>\n<li>所有的直线的斜率$k\\in(0,1)$</li>\n<li>$x_1 &lt; x_2$ 且 $y_1 &lt; y_2$</li>\n</ol>\n<p>此时，每次绘制像素时：</p>\n<ol>\n<li>$X$方向都会向右移动一格</li>\n<li>为了得到$Y$方向的增长值，先计算 $\\Delta{y} = (y_2 - y_1)$ $\\Delta{x} =(x_2 - x_1)$，根据斜率的性质，可以得出 $\\Delta{y} = k\\Delta{x}$ </li>\n<li>当 $y$ 增长1个单位时，$x$ 需要增长$1/k$个单位</li>\n<li>我们规定 $2\\Delta{y} - \\Delta{x}$ 为初始判定值$d$，每次绘制时$d += 2\\Delta{y}$</li>\n<li>当 $d &gt;= 0$的时候，说明$Y$轴方向的增长量超过了1，令$y + 1$，然后将$d - 2\\Delta{x}$。</li>\n</ol>\n<p>以下是代码表示:</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bresenham</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x1, <span class=\"hljs-keyword\">int</span> y1, <span class=\"hljs-keyword\">int</span> x2, <span class=\"hljs-keyword\">int</span> y2)</span> </span>&#123; \n    <span class=\"hljs-keyword\">int</span> m_new = <span class=\"hljs-number\">2</span> * (y2 - y1); \n    <span class=\"hljs-keyword\">int</span> slope_error_new = m_new - (x2 - x1); \n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> x = x1, y = y1; x &lt;= x2; x++) \n    &#123; \n        <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-string\">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class=\"hljs-string\">&quot;)\\n&quot;</span>; \n\n        <span class=\"hljs-comment\">// Add slope to increment angle formed </span>\n        slope_error_new += m_new; \n\n        <span class=\"hljs-comment\">// Slope error reached limit, time to </span>\n        <span class=\"hljs-comment\">// increment y and update slope error. </span>\n        <span class=\"hljs-keyword\">if</span> (slope_error_new &gt;= <span class=\"hljs-number\">0</span>) \n        &#123; \n            y++; \n            slope_error_new  -= <span class=\"hljs-number\">2</span> * (x2 - x1); \n        &#125; \n    &#125; \n&#125;</code></pre>\n<h2 id=\"图形光栅化表示\"><a href=\"#图形光栅化表示\" class=\"headerlink\" title=\"图形光栅化表示\"></a>图形光栅化表示</h2><p>下面以三角形为例，介绍图形的光栅化过程。在图形光栅化的过程中，我们需要逐行扫描每个像素，判断像素是否处于图形之中，如果处于图形之中就将其采样。</p>\n<p><img src=\"/images/graphics4/graphics4_sample.png\" alt=\"\"></p>\n<p>如何判断点$Q$是否在三角形内呢？对于三角形而言，确定三角形的形状和位置需要确定三角形的三个定点$P_1$、$P_2$、$P_3$。利用向量叉乘的特性，分别计算$\\overrightarrow{P_1P_2} \\times \\overrightarrow{P_1Q}$和$\\overrightarrow{P_2P_3} \\times \\overrightarrow{P_2Q}$以及$\\overrightarrow{P_3P_1} \\times \\overrightarrow{P_3Q}$的值是否是相同正负号的。如果是就说明点$Q$在三角形$P_1P_2P_3$内。<br><img src=\"/images/graphics4/graphics4_inside.png\" alt=\"\"></p>\n<p>逐行扫描对于光栅化过程来说有点过于耗费性能，因为很多情况下区域内只有很小的宇哥图形。如果逐行去扫描不需要着色的像素，会造成严重的性能浪费。因此可以使用一个盒子边界来包裹需要扫描的像素区域，只在这个区域内进行光栅化的过程，大幅提升光栅化的性能。这个特性实际上适用于很多图形学的场景，比如碰撞检测、抗锯齿。<br><img src=\"/images/graphics4/graphics4_bound_box.png\" alt=\"\"></p>\n"},{"title":"计算机图形学5 —— 反走样","index_img":"/images/graphics5/graphics5_banner.jpg","date":"2020-09-13T09:09:11.000Z","math":true,"_content":"\n## 走样\n上一节介绍图形的光栅化的过程，经过图形光栅化过程后，可以得到一个像素集合，它将表示我们想要光栅化的图形，这些点被称为采样信号（Sampled Signal）\n![](/images/graphics5/graphics5_sample.png)\n上图表示了三角形光栅化的过程，可以看到最后形成的采样信号与原信号差距还是比较大的，这种现象就是我们所说的走样(Aliasing)。它对于实际的图形成像的影响非常大，出现走样现象的图形，会在边界处出现各种情况的锯齿，这些锯齿很影响实际的成像体验。\n\n走样现象实际上是无法完全避免的，即使分辨率更高的分辨率，更精细的模型，更高的渲染渲染性能也于事无补。因为产生走样现象的本质是由于像素本身是离散型的，我们需要有限的像素点来表示无限精细的线，走样是数字化的必然产物。比如在下图中，相当精细的画面实际上在放大之后观察像素也存在着走样的现象。我们能够做的，仅仅是利用各种技术去减轻这种现象。\n![](/images/graphics5/graphics5_aliasing.png)\n\n## 走样在信号上的解释\n图形的光栅化过程，实际上是可以通过信号采样和重建过程来表示的。场景中的几何物体投射到屏幕上的过程，实际就是对虚拟场景的采样和重建的过程，所以也可以把图像当作信号来分析。由于存储空间和显示设备分辨率的限制，图像的采样过程也是有损的。\n![](/images/graphics5/graphics5_reconstructed.png)\n\n从频域的角度来看，实际上成样过程实际上也是通过离散的采样点来模拟原信号的变换过程。对于低频信号而言，不需要太多的采样点就可以很容易模拟出原信号的形态，因为原信号变化波动很慢。但是对于高频信号而言，很容易出现采样点无法还原原信号的情况，一旦采样点越过了多次频率变化，就很难还原原有的信号。频率越高，通过采样点能还原原信号的概率就越低。比如下图，蓝色部分是原信号，由于采样点不足，通过采样点还原信号时还原的信号频率远低于原信号。\n\n![](/images/graphics5/graphics5_frequency.png)\n\n因此走样的根因和采样过程有关系，最常见的问题就在于采样不足。信号变换太快（高频信号），但是采样的速度跟不上。从时域的角度去看，当采样不足时，就会出现模拟出的信号与信号源有一定的差距，就造成了走样现象。\n\n### Jaggies（锯齿）\n锯齿是在空间中采样的走样现象，造成这种现象的根本原因是因为在空间采样中过程，信号频率变化太快导致的。在图形的边缘型号有带有颜色信息的信号变为无颜色信息的型号，这个过程变化过于剧烈。在采样的过程中如果采样不足，就会造成边缘部分出现无法还原图形的真实形状，就出现了锯齿。比如下图在边缘部分出现严重的锯齿现象。\n![](/images/graphics5/graphics5_jaggies.png)\n### Moiré Patterns\nMoiré Patterns 也是因为采样不足导致的，在采样过程中由于采样频率过低，从而导致信号在某些区域内出现缺失。比如说在采样的过程中，跳过了奇数行像素或者偶数行像素的信号。就会出现严重的 Moiré Patterns 现象。\n![](/images/graphics5/graphics5_Moiré.jpg)\n\n## 反走样及其原理\n\n### SSAA\n反走样的最直接也最有效的的原理就是增大采样频率，使用尽量多的采样点来还原原始的信号形态。这就是SSAA（Super Sampling Anti-aliasing）的原理。它的原理正如字面意思，将一个像素点分解为多个模拟的像素点，通过这种细分来进行着色（shading）计算，最后在对模拟像素点取平均值，最终的到实际物理像素点的颜色。\n\n以每个像素点分解为4个模拟像素点为例，对原始的像素点作出分解。正如上面的介绍所说，如果模拟像素点位于三角形内，否则不进行着色，所有模拟像素点着色完成之后，则将其计算颜色的平均值。\n![](/images/graphics5/graphics5_SSAA.jpg)\n\n最后通过SSAA得到的像素点如右图所示，看起来依旧是存在锯齿的，但是在实际成像过程中，边缘的部分颜色会浅一些，这样锯齿的效果也不会特别明显，能够更还原几何形体的真实形态。\n\n### MSAA\nMSAA（Multi-Sampling Anti-aliasing）是对SSAA的一个改进。SSAA虽然非常直接有效，但是其消耗的性能也是极大的。拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。\n\nMSAA（Multi-Sampling AA）则很聪明的只是在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次。例如下图是4xMSAA，三角形只覆盖了4个coverage sample中的2个。所以这个三角形需要生成一个fragment在pixel shader里着色，只不过生成的fragment还是在像素中央（位置，法线等信息插值到像素中央）然后只运行一次pixel shader，最后得到的结果在resolve阶段会乘以0.5，因为这个三角形只cover了一半的sample。现代所有GPU都在硬件上实现了这个算法，而且在shading的运算量远大于光栅化的今天，这个方法远比SSAA快很多。\n","source":"_posts/ComputerGraphics5.md","raw":"---\ntitle: 计算机图形学5 —— 反走样\ntags: [计算机图形学, 光栅化, 反走样]\ncategories: [GAMES101]\nindex_img: /images/graphics5/graphics5_banner.jpg\ndate: 2020-09-13 17:09:11\nmath: true\n---\n\n## 走样\n上一节介绍图形的光栅化的过程，经过图形光栅化过程后，可以得到一个像素集合，它将表示我们想要光栅化的图形，这些点被称为采样信号（Sampled Signal）\n![](/images/graphics5/graphics5_sample.png)\n上图表示了三角形光栅化的过程，可以看到最后形成的采样信号与原信号差距还是比较大的，这种现象就是我们所说的走样(Aliasing)。它对于实际的图形成像的影响非常大，出现走样现象的图形，会在边界处出现各种情况的锯齿，这些锯齿很影响实际的成像体验。\n\n走样现象实际上是无法完全避免的，即使分辨率更高的分辨率，更精细的模型，更高的渲染渲染性能也于事无补。因为产生走样现象的本质是由于像素本身是离散型的，我们需要有限的像素点来表示无限精细的线，走样是数字化的必然产物。比如在下图中，相当精细的画面实际上在放大之后观察像素也存在着走样的现象。我们能够做的，仅仅是利用各种技术去减轻这种现象。\n![](/images/graphics5/graphics5_aliasing.png)\n\n## 走样在信号上的解释\n图形的光栅化过程，实际上是可以通过信号采样和重建过程来表示的。场景中的几何物体投射到屏幕上的过程，实际就是对虚拟场景的采样和重建的过程，所以也可以把图像当作信号来分析。由于存储空间和显示设备分辨率的限制，图像的采样过程也是有损的。\n![](/images/graphics5/graphics5_reconstructed.png)\n\n从频域的角度来看，实际上成样过程实际上也是通过离散的采样点来模拟原信号的变换过程。对于低频信号而言，不需要太多的采样点就可以很容易模拟出原信号的形态，因为原信号变化波动很慢。但是对于高频信号而言，很容易出现采样点无法还原原信号的情况，一旦采样点越过了多次频率变化，就很难还原原有的信号。频率越高，通过采样点能还原原信号的概率就越低。比如下图，蓝色部分是原信号，由于采样点不足，通过采样点还原信号时还原的信号频率远低于原信号。\n\n![](/images/graphics5/graphics5_frequency.png)\n\n因此走样的根因和采样过程有关系，最常见的问题就在于采样不足。信号变换太快（高频信号），但是采样的速度跟不上。从时域的角度去看，当采样不足时，就会出现模拟出的信号与信号源有一定的差距，就造成了走样现象。\n\n### Jaggies（锯齿）\n锯齿是在空间中采样的走样现象，造成这种现象的根本原因是因为在空间采样中过程，信号频率变化太快导致的。在图形的边缘型号有带有颜色信息的信号变为无颜色信息的型号，这个过程变化过于剧烈。在采样的过程中如果采样不足，就会造成边缘部分出现无法还原图形的真实形状，就出现了锯齿。比如下图在边缘部分出现严重的锯齿现象。\n![](/images/graphics5/graphics5_jaggies.png)\n### Moiré Patterns\nMoiré Patterns 也是因为采样不足导致的，在采样过程中由于采样频率过低，从而导致信号在某些区域内出现缺失。比如说在采样的过程中，跳过了奇数行像素或者偶数行像素的信号。就会出现严重的 Moiré Patterns 现象。\n![](/images/graphics5/graphics5_Moiré.jpg)\n\n## 反走样及其原理\n\n### SSAA\n反走样的最直接也最有效的的原理就是增大采样频率，使用尽量多的采样点来还原原始的信号形态。这就是SSAA（Super Sampling Anti-aliasing）的原理。它的原理正如字面意思，将一个像素点分解为多个模拟的像素点，通过这种细分来进行着色（shading）计算，最后在对模拟像素点取平均值，最终的到实际物理像素点的颜色。\n\n以每个像素点分解为4个模拟像素点为例，对原始的像素点作出分解。正如上面的介绍所说，如果模拟像素点位于三角形内，否则不进行着色，所有模拟像素点着色完成之后，则将其计算颜色的平均值。\n![](/images/graphics5/graphics5_SSAA.jpg)\n\n最后通过SSAA得到的像素点如右图所示，看起来依旧是存在锯齿的，但是在实际成像过程中，边缘的部分颜色会浅一些，这样锯齿的效果也不会特别明显，能够更还原几何形体的真实形态。\n\n### MSAA\nMSAA（Multi-Sampling Anti-aliasing）是对SSAA的一个改进。SSAA虽然非常直接有效，但是其消耗的性能也是极大的。拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。\n\nMSAA（Multi-Sampling AA）则很聪明的只是在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次。例如下图是4xMSAA，三角形只覆盖了4个coverage sample中的2个。所以这个三角形需要生成一个fragment在pixel shader里着色，只不过生成的fragment还是在像素中央（位置，法线等信息插值到像素中央）然后只运行一次pixel shader，最后得到的结果在resolve阶段会乘以0.5，因为这个三角形只cover了一半的sample。现代所有GPU都在硬件上实现了这个算法，而且在shading的运算量远大于光栅化的今天，这个方法远比SSAA快很多。\n","slug":"ComputerGraphics5","published":1,"updated":"2020-10-03T09:11:36.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wad000jnwqc7ve3fuxb","content":"<h2 id=\"走样\"><a href=\"#走样\" class=\"headerlink\" title=\"走样\"></a>走样</h2><p>上一节介绍图形的光栅化的过程，经过图形光栅化过程后，可以得到一个像素集合，它将表示我们想要光栅化的图形，这些点被称为采样信号（Sampled Signal）<br><img src=\"/images/graphics5/graphics5_sample.png\" alt=\"\"><br>上图表示了三角形光栅化的过程，可以看到最后形成的采样信号与原信号差距还是比较大的，这种现象就是我们所说的走样(Aliasing)。它对于实际的图形成像的影响非常大，出现走样现象的图形，会在边界处出现各种情况的锯齿，这些锯齿很影响实际的成像体验。</p>\n<p>走样现象实际上是无法完全避免的，即使分辨率更高的分辨率，更精细的模型，更高的渲染渲染性能也于事无补。因为产生走样现象的本质是由于像素本身是离散型的，我们需要有限的像素点来表示无限精细的线，走样是数字化的必然产物。比如在下图中，相当精细的画面实际上在放大之后观察像素也存在着走样的现象。我们能够做的，仅仅是利用各种技术去减轻这种现象。<br><img src=\"/images/graphics5/graphics5_aliasing.png\" alt=\"\"></p>\n<h2 id=\"走样在信号上的解释\"><a href=\"#走样在信号上的解释\" class=\"headerlink\" title=\"走样在信号上的解释\"></a>走样在信号上的解释</h2><p>图形的光栅化过程，实际上是可以通过信号采样和重建过程来表示的。场景中的几何物体投射到屏幕上的过程，实际就是对虚拟场景的采样和重建的过程，所以也可以把图像当作信号来分析。由于存储空间和显示设备分辨率的限制，图像的采样过程也是有损的。<br><img src=\"/images/graphics5/graphics5_reconstructed.png\" alt=\"\"></p>\n<p>从频域的角度来看，实际上成样过程实际上也是通过离散的采样点来模拟原信号的变换过程。对于低频信号而言，不需要太多的采样点就可以很容易模拟出原信号的形态，因为原信号变化波动很慢。但是对于高频信号而言，很容易出现采样点无法还原原信号的情况，一旦采样点越过了多次频率变化，就很难还原原有的信号。频率越高，通过采样点能还原原信号的概率就越低。比如下图，蓝色部分是原信号，由于采样点不足，通过采样点还原信号时还原的信号频率远低于原信号。</p>\n<p><img src=\"/images/graphics5/graphics5_frequency.png\" alt=\"\"></p>\n<p>因此走样的根因和采样过程有关系，最常见的问题就在于采样不足。信号变换太快（高频信号），但是采样的速度跟不上。从时域的角度去看，当采样不足时，就会出现模拟出的信号与信号源有一定的差距，就造成了走样现象。</p>\n<h3 id=\"Jaggies（锯齿）\"><a href=\"#Jaggies（锯齿）\" class=\"headerlink\" title=\"Jaggies（锯齿）\"></a>Jaggies（锯齿）</h3><p>锯齿是在空间中采样的走样现象，造成这种现象的根本原因是因为在空间采样中过程，信号频率变化太快导致的。在图形的边缘型号有带有颜色信息的信号变为无颜色信息的型号，这个过程变化过于剧烈。在采样的过程中如果采样不足，就会造成边缘部分出现无法还原图形的真实形状，就出现了锯齿。比如下图在边缘部分出现严重的锯齿现象。<br><img src=\"/images/graphics5/graphics5_jaggies.png\" alt=\"\"></p>\n<h3 id=\"Moire-Patterns\"><a href=\"#Moire-Patterns\" class=\"headerlink\" title=\"Moiré Patterns\"></a>Moiré Patterns</h3><p>Moiré Patterns 也是因为采样不足导致的，在采样过程中由于采样频率过低，从而导致信号在某些区域内出现缺失。比如说在采样的过程中，跳过了奇数行像素或者偶数行像素的信号。就会出现严重的 Moiré Patterns 现象。<br><img src=\"/images/graphics5/graphics5_Moiré.jpg\" alt=\"\"></p>\n<h2 id=\"反走样及其原理\"><a href=\"#反走样及其原理\" class=\"headerlink\" title=\"反走样及其原理\"></a>反走样及其原理</h2><h3 id=\"SSAA\"><a href=\"#SSAA\" class=\"headerlink\" title=\"SSAA\"></a>SSAA</h3><p>反走样的最直接也最有效的的原理就是增大采样频率，使用尽量多的采样点来还原原始的信号形态。这就是SSAA（Super Sampling Anti-aliasing）的原理。它的原理正如字面意思，将一个像素点分解为多个模拟的像素点，通过这种细分来进行着色（shading）计算，最后在对模拟像素点取平均值，最终的到实际物理像素点的颜色。</p>\n<p>以每个像素点分解为4个模拟像素点为例，对原始的像素点作出分解。正如上面的介绍所说，如果模拟像素点位于三角形内，否则不进行着色，所有模拟像素点着色完成之后，则将其计算颜色的平均值。<br><img src=\"/images/graphics5/graphics5_SSAA.jpg\" alt=\"\"></p>\n<p>最后通过SSAA得到的像素点如右图所示，看起来依旧是存在锯齿的，但是在实际成像过程中，边缘的部分颜色会浅一些，这样锯齿的效果也不会特别明显，能够更还原几何形体的真实形态。</p>\n<h3 id=\"MSAA\"><a href=\"#MSAA\" class=\"headerlink\" title=\"MSAA\"></a>MSAA</h3><p>MSAA（Multi-Sampling Anti-aliasing）是对SSAA的一个改进。SSAA虽然非常直接有效，但是其消耗的性能也是极大的。拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。</p>\n<p>MSAA（Multi-Sampling AA）则很聪明的只是在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次。例如下图是4xMSAA，三角形只覆盖了4个coverage sample中的2个。所以这个三角形需要生成一个fragment在pixel shader里着色，只不过生成的fragment还是在像素中央（位置，法线等信息插值到像素中央）然后只运行一次pixel shader，最后得到的结果在resolve阶段会乘以0.5，因为这个三角形只cover了一半的sample。现代所有GPU都在硬件上实现了这个算法，而且在shading的运算量远大于光栅化的今天，这个方法远比SSAA快很多。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"走样\"><a href=\"#走样\" class=\"headerlink\" title=\"走样\"></a>走样</h2><p>上一节介绍图形的光栅化的过程，经过图形光栅化过程后，可以得到一个像素集合，它将表示我们想要光栅化的图形，这些点被称为采样信号（Sampled Signal）<br><img src=\"/images/graphics5/graphics5_sample.png\" alt=\"\"><br>上图表示了三角形光栅化的过程，可以看到最后形成的采样信号与原信号差距还是比较大的，这种现象就是我们所说的走样(Aliasing)。它对于实际的图形成像的影响非常大，出现走样现象的图形，会在边界处出现各种情况的锯齿，这些锯齿很影响实际的成像体验。</p>\n<p>走样现象实际上是无法完全避免的，即使分辨率更高的分辨率，更精细的模型，更高的渲染渲染性能也于事无补。因为产生走样现象的本质是由于像素本身是离散型的，我们需要有限的像素点来表示无限精细的线，走样是数字化的必然产物。比如在下图中，相当精细的画面实际上在放大之后观察像素也存在着走样的现象。我们能够做的，仅仅是利用各种技术去减轻这种现象。<br><img src=\"/images/graphics5/graphics5_aliasing.png\" alt=\"\"></p>\n<h2 id=\"走样在信号上的解释\"><a href=\"#走样在信号上的解释\" class=\"headerlink\" title=\"走样在信号上的解释\"></a>走样在信号上的解释</h2><p>图形的光栅化过程，实际上是可以通过信号采样和重建过程来表示的。场景中的几何物体投射到屏幕上的过程，实际就是对虚拟场景的采样和重建的过程，所以也可以把图像当作信号来分析。由于存储空间和显示设备分辨率的限制，图像的采样过程也是有损的。<br><img src=\"/images/graphics5/graphics5_reconstructed.png\" alt=\"\"></p>\n<p>从频域的角度来看，实际上成样过程实际上也是通过离散的采样点来模拟原信号的变换过程。对于低频信号而言，不需要太多的采样点就可以很容易模拟出原信号的形态，因为原信号变化波动很慢。但是对于高频信号而言，很容易出现采样点无法还原原信号的情况，一旦采样点越过了多次频率变化，就很难还原原有的信号。频率越高，通过采样点能还原原信号的概率就越低。比如下图，蓝色部分是原信号，由于采样点不足，通过采样点还原信号时还原的信号频率远低于原信号。</p>\n<p><img src=\"/images/graphics5/graphics5_frequency.png\" alt=\"\"></p>\n<p>因此走样的根因和采样过程有关系，最常见的问题就在于采样不足。信号变换太快（高频信号），但是采样的速度跟不上。从时域的角度去看，当采样不足时，就会出现模拟出的信号与信号源有一定的差距，就造成了走样现象。</p>\n<h3 id=\"Jaggies（锯齿）\"><a href=\"#Jaggies（锯齿）\" class=\"headerlink\" title=\"Jaggies（锯齿）\"></a>Jaggies（锯齿）</h3><p>锯齿是在空间中采样的走样现象，造成这种现象的根本原因是因为在空间采样中过程，信号频率变化太快导致的。在图形的边缘型号有带有颜色信息的信号变为无颜色信息的型号，这个过程变化过于剧烈。在采样的过程中如果采样不足，就会造成边缘部分出现无法还原图形的真实形状，就出现了锯齿。比如下图在边缘部分出现严重的锯齿现象。<br><img src=\"/images/graphics5/graphics5_jaggies.png\" alt=\"\"></p>\n<h3 id=\"Moire-Patterns\"><a href=\"#Moire-Patterns\" class=\"headerlink\" title=\"Moiré Patterns\"></a>Moiré Patterns</h3><p>Moiré Patterns 也是因为采样不足导致的，在采样过程中由于采样频率过低，从而导致信号在某些区域内出现缺失。比如说在采样的过程中，跳过了奇数行像素或者偶数行像素的信号。就会出现严重的 Moiré Patterns 现象。<br><img src=\"/images/graphics5/graphics5_Moiré.jpg\" alt=\"\"></p>\n<h2 id=\"反走样及其原理\"><a href=\"#反走样及其原理\" class=\"headerlink\" title=\"反走样及其原理\"></a>反走样及其原理</h2><h3 id=\"SSAA\"><a href=\"#SSAA\" class=\"headerlink\" title=\"SSAA\"></a>SSAA</h3><p>反走样的最直接也最有效的的原理就是增大采样频率，使用尽量多的采样点来还原原始的信号形态。这就是SSAA（Super Sampling Anti-aliasing）的原理。它的原理正如字面意思，将一个像素点分解为多个模拟的像素点，通过这种细分来进行着色（shading）计算，最后在对模拟像素点取平均值，最终的到实际物理像素点的颜色。</p>\n<p>以每个像素点分解为4个模拟像素点为例，对原始的像素点作出分解。正如上面的介绍所说，如果模拟像素点位于三角形内，否则不进行着色，所有模拟像素点着色完成之后，则将其计算颜色的平均值。<br><img src=\"/images/graphics5/graphics5_SSAA.jpg\" alt=\"\"></p>\n<p>最后通过SSAA得到的像素点如右图所示，看起来依旧是存在锯齿的，但是在实际成像过程中，边缘的部分颜色会浅一些，这样锯齿的效果也不会特别明显，能够更还原几何形体的真实形态。</p>\n<h3 id=\"MSAA\"><a href=\"#MSAA\" class=\"headerlink\" title=\"MSAA\"></a>MSAA</h3><p>MSAA（Multi-Sampling Anti-aliasing）是对SSAA的一个改进。SSAA虽然非常直接有效，但是其消耗的性能也是极大的。拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。</p>\n<p>MSAA（Multi-Sampling AA）则很聪明的只是在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次。例如下图是4xMSAA，三角形只覆盖了4个coverage sample中的2个。所以这个三角形需要生成一个fragment在pixel shader里着色，只不过生成的fragment还是在像素中央（位置，法线等信息插值到像素中央）然后只运行一次pixel shader，最后得到的结果在resolve阶段会乘以0.5，因为这个三角形只cover了一半的sample。现代所有GPU都在硬件上实现了这个算法，而且在shading的运算量远大于光栅化的今天，这个方法远比SSAA快很多。</p>\n"},{"title":"计算机图形学6 —— 着色","index_img":"/images/graphics6/graphics6_banner.jpg","date":"2020-10-01T09:09:11.000Z","math":true,"_content":"## 可见性和Z-buffer\n对于在一个场景中进行绘制时，将3D模型投影到2D屏幕上的时候，总会出现遮盖的情景。那么那些部分可见，那些部分不可见是需要考虑的。最直接的方式就是一层一层，从远及近将这张图给画出来，这样前景的物体就会遮挡住背景的物体。这种绘制方式叫做画家算法（painter's algorithm）\n但是这种简单的做法在很多场景是很难解决的，因为远近先后顺序这个很难做判断。比如说下面这个场景三角形$P、R、Q$相互的前后关系很难确定，实际要表现的效果是互有遮挡。因此单纯使用画家算法来一层层进行绘制，是很难达到显示效果的。\n![](/images/graphics6/graphics6_painter.png)\n\nZ-buffer算法解决了这个问题，因为对于三角形来说确定遮挡关系很难，但是对于像素来说，是可以有明确的遮挡关系的。对于2D场景中任意一个点$(x, y)$，存储其深度（depth）信息$z$，每次绘制像素点$(x, y)$时，比较其与zbuffer(x, y)的值进行比较，如果小的话则将深度其存储在zbuffer中，并将其颜色信息存储在framebuffer中。当场景计算完毕之后，再通过framebuffer进行绘制。伪代码如下：\n```\nfor (each triangle T)\n    for (each sample (x,y,z) in T)\n        if (z < zbuffer[x,y]) \n            framebuffer[x,y] = rgb; // 存储颜色信息\n            zbuffer[x,y] = z; // 存储z信息\n        else\n            ... // do nothing\n```\n## 光照和着色\n着色（shading）过程是渲染过程非常关键的一步，简单来说就是光栅化过程中计算每个采样点的颜色色值。在词典中着色的解释如下：\n\n```\nshad·ing, [ˈʃeɪdɪŋ], noun\nThe darkening or coloring of an illustration or diagram with parallel lines or a block of color.\n```\n正如解释所说，shading过程实际上就是引入明暗不同以及颜色的变化，在图形学课程中，往往shading指对不同的物体，应用不同的材质。\n\n对于一个物体而言，我们之所以能看见他，是因为光线在其表面发生了反射和吸收，之后传达到了人眼中。物体将特定频率的光线进行反射，也形成了其颜色。在相同材质的物体上，却有不同的颜色和明暗变化。这是因为光源以及光的反射方式的不同。如下图所示是一个光线的反射场景：\n![](/images/graphics6/graphics6_shading.png)\n对于光线反射而言，一共有三种反射类型：\n1. 镜面反射\n2. 漫反射\n3. 环境光\n\n### 镜面反射\n镜面反射模型比较简单，以光线与反射面接触点（shading point）的法线方向为中界限，入射角等于出射角。影响镜面反射模型的着色因素主要有入射角度、相机角度、法线方向以及表面材质（影响折射率）。\n![](/images/graphics6/graphics6_Specula.png)\n\n### 漫反射\n漫反射模型也相对比较简单。理论上在漫反射模型中，无论光源的位置在任何地方，在反射面都会形成所有方向的反射光。而且在漫反射模型中，反射光的强度在任何方向上都是一致的，无论入射光的角度在任意的方向。\n\n但是漫反射能反射多少能量强度的光源与入射角有很直接的关系。假设光源的强度一定时，我们抽象出单位宽度的平行光源，假定在任意角度下，表面材质对漫反射的折射率一定。当入射角度为90度时，理论上反射面能接收被反射所有的光线。但是当反射面与入射光线有一定的夹脚时，反射面就只能接收部分反射光线。此时的光照强度，应该乘于夹角系数$cos\\theta = l \\cdot n$，其中$l$为入射角的方向，$n$为法线方向。\n![](/images/graphics6/graphics6_lambertian.png)\n\n另外，对于光线传播来说，传递的光线总是会随着传播的距离能量会随之衰减。以点光源向四面扩散为例，光源发射出来的能量其实是一定的，那么在任意两个圈上接受到的能量之和一定相等。而离圆心越远，圆的面积越大，单位面积所接受能量也就越弱。其到达某个点的光照强度应为：$I/r^2$，其中$I$为光源光照强度，$r$为距离。\n![](/images/graphics6/graphics6_energy.png)\n\n结合光照强度参数和漫反射的入射角度强度计算，可以得到一个计算漫反射光照强度的公式：\n![](/images/graphics6/graphics6_diffuse_function.png)\n其中：\n* $k_d$ 为漫反射系数，可能会受到材质等影响\n* $I$ 为入射光照强度，$r$ 为shading point距离光源的距离\n* $n, l$ 分别如图中所示为法线向量和入射方向\n\n### 高光\n高光项与漫反射的计算项类似，但是不同的是，漫反射的效果只和入射角度有关，与观察角度的是没有关系的。但是高光与相机的观察角度也是有关系的，在接近出射角的位置，高光最明显，在于远离出射角的位置高光几乎不可见：\n![](/images/graphics6/graphics6_Specular.png)\n因此对于高光项来说，镜头视角与出射光的夹角对于着色效果影响很大。直接计算这个夹角值相对来说比较困难，因为需要确定出射角的方向。这里Blinn-Phong很巧妙地简化了这一计算，直接计算入射方向 $l$ 和相机视角方向 $v$ 的半程向量 $h$。使用法线 $n$ 与半程向量 $h$的夹角来作为计算参数。\n\n高光的大小和强度理论上也需要在反射模型中通过公式来体现，对$n \\cdot h$增加求幂计算，对整体通过乘于参数$K_s$，就可以控制其大小和强度，其因素变化如下图：\n![](/images/graphics6/graphics6_spe_param.png)\n\n将上述所有的因素组合起来，得到高光项的计算公式：\n$$\nL_s = K_s (I/r^2)max(0, \\cos{\\alpha})^p = K_s(I/r^2)max(0, {h \\cdot n})^p\n$$\n### 环境光\n环境光的着色过程，不依赖于任何的系数的。它只负责绘制绘制物体的轮廓形态，通常只会填充一些固定的颜色，不会考虑物体的光照效果，只是一个估计值。\n![](/images/graphics6/graphics6_Ambient.png)\n\n### Blinn-Phong反射模型\nBlinn-Phong反射模型就是结合了环境光、漫反射、高光三项的计算模型。\n![](/images/graphics6/graphics6_combine.png)\n\n结合公式来看：\n$$\nL = L_a + L_d + L_s = K_aI_a + K_d(I/r^2)max(0, n \\cdot l) + K_s(I/r^2)max(0, n \\cdot h)^p\n$$\n\n## 着色频率\n当我们计算出着色信息之后，需要将颜色信息绘制到图形上。在着色过程中，图形上每个像素点的位置和颜色信息都不尽相同。。如果我们单纯地对每个像素点进行计算着色，那么对于那些形状/颜色变化过大地物体就会有非常大地计算量，因此业界有三种着色方式来优化着色过程。\n\n### Flat Shading(平面着色)\n像素着色对于着色的性能消耗较高，因为我们需要对每个像素点进行单独的计算。在实际情况中，往往不需要这么高的精度，因为对于某些图形来说，局部的颜色几乎是相同的。这时候可以通过将图形划分为多个三角形面，单独地对每个三角形进行一次着色，这种方式叫平面着色（Flat Shaing)。但是平面着色有个显著的问题，当三角形划分较大的时候，着色效果很差，因为整块三角形都使用同样的色值，无法做颜色边界区分。\n\n### Gourand Shading（顶点着色）\n定点着色的思路和平面着色思路类似，但是它使用了差值的方式来优化平面着色的效果。大体思路是先通过对三角形的顶点的法线方向的颜色计算值进行着色，当其颜色值确定后，三角形内的颜色可以通过插值的方式来计算得出。其明暗处理只在多边形顶点处采用Phong局部反射模型计算光强，而在多边形内的其他点采用双向线性插值，这样做的优点是高效，但是无法很好的处理镜面高光问题，依赖于其所在多面形的相对位置；\n\n### Phong Shading（像素着色）\n它对三角形的每个片元进行着色计算。这个方法有时也称为逐片元着色（per-pixel shading）。由于颜色是按片元着色的，因此得到的结果比Gouraud着色好，尤其是用于光亮表面。","source":"_posts/ComputerGraphics6.md","raw":"---\ntitle: 计算机图形学6 —— 着色 \ntags: [计算机图形学, 光照, 着色, 渲染模型]\ncategories: [GAMES101]\nindex_img: /images/graphics6/graphics6_banner.jpg\ndate: 2020-10-1 17:09:11\nmath: true\n---\n## 可见性和Z-buffer\n对于在一个场景中进行绘制时，将3D模型投影到2D屏幕上的时候，总会出现遮盖的情景。那么那些部分可见，那些部分不可见是需要考虑的。最直接的方式就是一层一层，从远及近将这张图给画出来，这样前景的物体就会遮挡住背景的物体。这种绘制方式叫做画家算法（painter's algorithm）\n但是这种简单的做法在很多场景是很难解决的，因为远近先后顺序这个很难做判断。比如说下面这个场景三角形$P、R、Q$相互的前后关系很难确定，实际要表现的效果是互有遮挡。因此单纯使用画家算法来一层层进行绘制，是很难达到显示效果的。\n![](/images/graphics6/graphics6_painter.png)\n\nZ-buffer算法解决了这个问题，因为对于三角形来说确定遮挡关系很难，但是对于像素来说，是可以有明确的遮挡关系的。对于2D场景中任意一个点$(x, y)$，存储其深度（depth）信息$z$，每次绘制像素点$(x, y)$时，比较其与zbuffer(x, y)的值进行比较，如果小的话则将深度其存储在zbuffer中，并将其颜色信息存储在framebuffer中。当场景计算完毕之后，再通过framebuffer进行绘制。伪代码如下：\n```\nfor (each triangle T)\n    for (each sample (x,y,z) in T)\n        if (z < zbuffer[x,y]) \n            framebuffer[x,y] = rgb; // 存储颜色信息\n            zbuffer[x,y] = z; // 存储z信息\n        else\n            ... // do nothing\n```\n## 光照和着色\n着色（shading）过程是渲染过程非常关键的一步，简单来说就是光栅化过程中计算每个采样点的颜色色值。在词典中着色的解释如下：\n\n```\nshad·ing, [ˈʃeɪdɪŋ], noun\nThe darkening or coloring of an illustration or diagram with parallel lines or a block of color.\n```\n正如解释所说，shading过程实际上就是引入明暗不同以及颜色的变化，在图形学课程中，往往shading指对不同的物体，应用不同的材质。\n\n对于一个物体而言，我们之所以能看见他，是因为光线在其表面发生了反射和吸收，之后传达到了人眼中。物体将特定频率的光线进行反射，也形成了其颜色。在相同材质的物体上，却有不同的颜色和明暗变化。这是因为光源以及光的反射方式的不同。如下图所示是一个光线的反射场景：\n![](/images/graphics6/graphics6_shading.png)\n对于光线反射而言，一共有三种反射类型：\n1. 镜面反射\n2. 漫反射\n3. 环境光\n\n### 镜面反射\n镜面反射模型比较简单，以光线与反射面接触点（shading point）的法线方向为中界限，入射角等于出射角。影响镜面反射模型的着色因素主要有入射角度、相机角度、法线方向以及表面材质（影响折射率）。\n![](/images/graphics6/graphics6_Specula.png)\n\n### 漫反射\n漫反射模型也相对比较简单。理论上在漫反射模型中，无论光源的位置在任何地方，在反射面都会形成所有方向的反射光。而且在漫反射模型中，反射光的强度在任何方向上都是一致的，无论入射光的角度在任意的方向。\n\n但是漫反射能反射多少能量强度的光源与入射角有很直接的关系。假设光源的强度一定时，我们抽象出单位宽度的平行光源，假定在任意角度下，表面材质对漫反射的折射率一定。当入射角度为90度时，理论上反射面能接收被反射所有的光线。但是当反射面与入射光线有一定的夹脚时，反射面就只能接收部分反射光线。此时的光照强度，应该乘于夹角系数$cos\\theta = l \\cdot n$，其中$l$为入射角的方向，$n$为法线方向。\n![](/images/graphics6/graphics6_lambertian.png)\n\n另外，对于光线传播来说，传递的光线总是会随着传播的距离能量会随之衰减。以点光源向四面扩散为例，光源发射出来的能量其实是一定的，那么在任意两个圈上接受到的能量之和一定相等。而离圆心越远，圆的面积越大，单位面积所接受能量也就越弱。其到达某个点的光照强度应为：$I/r^2$，其中$I$为光源光照强度，$r$为距离。\n![](/images/graphics6/graphics6_energy.png)\n\n结合光照强度参数和漫反射的入射角度强度计算，可以得到一个计算漫反射光照强度的公式：\n![](/images/graphics6/graphics6_diffuse_function.png)\n其中：\n* $k_d$ 为漫反射系数，可能会受到材质等影响\n* $I$ 为入射光照强度，$r$ 为shading point距离光源的距离\n* $n, l$ 分别如图中所示为法线向量和入射方向\n\n### 高光\n高光项与漫反射的计算项类似，但是不同的是，漫反射的效果只和入射角度有关，与观察角度的是没有关系的。但是高光与相机的观察角度也是有关系的，在接近出射角的位置，高光最明显，在于远离出射角的位置高光几乎不可见：\n![](/images/graphics6/graphics6_Specular.png)\n因此对于高光项来说，镜头视角与出射光的夹角对于着色效果影响很大。直接计算这个夹角值相对来说比较困难，因为需要确定出射角的方向。这里Blinn-Phong很巧妙地简化了这一计算，直接计算入射方向 $l$ 和相机视角方向 $v$ 的半程向量 $h$。使用法线 $n$ 与半程向量 $h$的夹角来作为计算参数。\n\n高光的大小和强度理论上也需要在反射模型中通过公式来体现，对$n \\cdot h$增加求幂计算，对整体通过乘于参数$K_s$，就可以控制其大小和强度，其因素变化如下图：\n![](/images/graphics6/graphics6_spe_param.png)\n\n将上述所有的因素组合起来，得到高光项的计算公式：\n$$\nL_s = K_s (I/r^2)max(0, \\cos{\\alpha})^p = K_s(I/r^2)max(0, {h \\cdot n})^p\n$$\n### 环境光\n环境光的着色过程，不依赖于任何的系数的。它只负责绘制绘制物体的轮廓形态，通常只会填充一些固定的颜色，不会考虑物体的光照效果，只是一个估计值。\n![](/images/graphics6/graphics6_Ambient.png)\n\n### Blinn-Phong反射模型\nBlinn-Phong反射模型就是结合了环境光、漫反射、高光三项的计算模型。\n![](/images/graphics6/graphics6_combine.png)\n\n结合公式来看：\n$$\nL = L_a + L_d + L_s = K_aI_a + K_d(I/r^2)max(0, n \\cdot l) + K_s(I/r^2)max(0, n \\cdot h)^p\n$$\n\n## 着色频率\n当我们计算出着色信息之后，需要将颜色信息绘制到图形上。在着色过程中，图形上每个像素点的位置和颜色信息都不尽相同。。如果我们单纯地对每个像素点进行计算着色，那么对于那些形状/颜色变化过大地物体就会有非常大地计算量，因此业界有三种着色方式来优化着色过程。\n\n### Flat Shading(平面着色)\n像素着色对于着色的性能消耗较高，因为我们需要对每个像素点进行单独的计算。在实际情况中，往往不需要这么高的精度，因为对于某些图形来说，局部的颜色几乎是相同的。这时候可以通过将图形划分为多个三角形面，单独地对每个三角形进行一次着色，这种方式叫平面着色（Flat Shaing)。但是平面着色有个显著的问题，当三角形划分较大的时候，着色效果很差，因为整块三角形都使用同样的色值，无法做颜色边界区分。\n\n### Gourand Shading（顶点着色）\n定点着色的思路和平面着色思路类似，但是它使用了差值的方式来优化平面着色的效果。大体思路是先通过对三角形的顶点的法线方向的颜色计算值进行着色，当其颜色值确定后，三角形内的颜色可以通过插值的方式来计算得出。其明暗处理只在多边形顶点处采用Phong局部反射模型计算光强，而在多边形内的其他点采用双向线性插值，这样做的优点是高效，但是无法很好的处理镜面高光问题，依赖于其所在多面形的相对位置；\n\n### Phong Shading（像素着色）\n它对三角形的每个片元进行着色计算。这个方法有时也称为逐片元着色（per-pixel shading）。由于颜色是按片元着色的，因此得到的结果比Gouraud着色好，尤其是用于光亮表面。","slug":"ComputerGraphics6","published":1,"updated":"2020-10-16T09:20:23.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wag000nnwqc4gce5bda","content":"<h2 id=\"可见性和Z-buffer\"><a href=\"#可见性和Z-buffer\" class=\"headerlink\" title=\"可见性和Z-buffer\"></a>可见性和Z-buffer</h2><p>对于在一个场景中进行绘制时，将3D模型投影到2D屏幕上的时候，总会出现遮盖的情景。那么那些部分可见，那些部分不可见是需要考虑的。最直接的方式就是一层一层，从远及近将这张图给画出来，这样前景的物体就会遮挡住背景的物体。这种绘制方式叫做画家算法（painter’s algorithm）<br>但是这种简单的做法在很多场景是很难解决的，因为远近先后顺序这个很难做判断。比如说下面这个场景三角形$P、R、Q$相互的前后关系很难确定，实际要表现的效果是互有遮挡。因此单纯使用画家算法来一层层进行绘制，是很难达到显示效果的。<br><img src=\"/images/graphics6/graphics6_painter.png\" alt=\"\"></p>\n<p>Z-buffer算法解决了这个问题，因为对于三角形来说确定遮挡关系很难，但是对于像素来说，是可以有明确的遮挡关系的。对于2D场景中任意一个点$(x, y)$，存储其深度（depth）信息$z$，每次绘制像素点$(x, y)$时，比较其与zbuffer(x, y)的值进行比较，如果小的话则将深度其存储在zbuffer中，并将其颜色信息存储在framebuffer中。当场景计算完毕之后，再通过framebuffer进行绘制。伪代码如下：<br><pre><code class=\"hljs gml\"><span class=\"hljs-keyword\">for</span> (each triangle T)\n    <span class=\"hljs-keyword\">for</span> (each sample (<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>,z) in T)\n        <span class=\"hljs-keyword\">if</span> (z &lt; zbuffer[<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>]) \n            framebuffer[<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>] = rgb; <span class=\"hljs-comment\">// 存储颜色信息</span>\n            zbuffer[<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>] = z; <span class=\"hljs-comment\">// 存储z信息</span>\n        <span class=\"hljs-keyword\">else</span>\n            ... <span class=\"hljs-comment\">// do nothing</span></code></pre></p>\n<h2 id=\"光照和着色\"><a href=\"#光照和着色\" class=\"headerlink\" title=\"光照和着色\"></a>光照和着色</h2><p>着色（shading）过程是渲染过程非常关键的一步，简单来说就是光栅化过程中计算每个采样点的颜色色值。在词典中着色的解释如下：</p>\n<pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">shad·ing, </span>[ˈʃeɪdɪŋ], noun\nThe darkening <span class=\"hljs-keyword\">or </span>coloring of an illustration <span class=\"hljs-keyword\">or </span><span class=\"hljs-keyword\">diagram </span>with parallel lines <span class=\"hljs-keyword\">or </span>a <span class=\"hljs-keyword\">block </span>of color.</code></pre>\n<p>正如解释所说，shading过程实际上就是引入明暗不同以及颜色的变化，在图形学课程中，往往shading指对不同的物体，应用不同的材质。</p>\n<p>对于一个物体而言，我们之所以能看见他，是因为光线在其表面发生了反射和吸收，之后传达到了人眼中。物体将特定频率的光线进行反射，也形成了其颜色。在相同材质的物体上，却有不同的颜色和明暗变化。这是因为光源以及光的反射方式的不同。如下图所示是一个光线的反射场景：<br><img src=\"/images/graphics6/graphics6_shading.png\" alt=\"\"><br>对于光线反射而言，一共有三种反射类型：</p>\n<ol>\n<li>镜面反射</li>\n<li>漫反射</li>\n<li>环境光</li>\n</ol>\n<h3 id=\"镜面反射\"><a href=\"#镜面反射\" class=\"headerlink\" title=\"镜面反射\"></a>镜面反射</h3><p>镜面反射模型比较简单，以光线与反射面接触点（shading point）的法线方向为中界限，入射角等于出射角。影响镜面反射模型的着色因素主要有入射角度、相机角度、法线方向以及表面材质（影响折射率）。<br><img src=\"/images/graphics6/graphics6_Specula.png\" alt=\"\"></p>\n<h3 id=\"漫反射\"><a href=\"#漫反射\" class=\"headerlink\" title=\"漫反射\"></a>漫反射</h3><p>漫反射模型也相对比较简单。理论上在漫反射模型中，无论光源的位置在任何地方，在反射面都会形成所有方向的反射光。而且在漫反射模型中，反射光的强度在任何方向上都是一致的，无论入射光的角度在任意的方向。</p>\n<p>但是漫反射能反射多少能量强度的光源与入射角有很直接的关系。假设光源的强度一定时，我们抽象出单位宽度的平行光源，假定在任意角度下，表面材质对漫反射的折射率一定。当入射角度为90度时，理论上反射面能接收被反射所有的光线。但是当反射面与入射光线有一定的夹脚时，反射面就只能接收部分反射光线。此时的光照强度，应该乘于夹角系数$cos\\theta = l \\cdot n$，其中$l$为入射角的方向，$n$为法线方向。<br><img src=\"/images/graphics6/graphics6_lambertian.png\" alt=\"\"></p>\n<p>另外，对于光线传播来说，传递的光线总是会随着传播的距离能量会随之衰减。以点光源向四面扩散为例，光源发射出来的能量其实是一定的，那么在任意两个圈上接受到的能量之和一定相等。而离圆心越远，圆的面积越大，单位面积所接受能量也就越弱。其到达某个点的光照强度应为：$I/r^2$，其中$I$为光源光照强度，$r$为距离。<br><img src=\"/images/graphics6/graphics6_energy.png\" alt=\"\"></p>\n<p>结合光照强度参数和漫反射的入射角度强度计算，可以得到一个计算漫反射光照强度的公式：<br><img src=\"/images/graphics6/graphics6_diffuse_function.png\" alt=\"\"><br>其中：</p>\n<ul>\n<li>$k_d$ 为漫反射系数，可能会受到材质等影响</li>\n<li>$I$ 为入射光照强度，$r$ 为shading point距离光源的距离</li>\n<li>$n, l$ 分别如图中所示为法线向量和入射方向</li>\n</ul>\n<h3 id=\"高光\"><a href=\"#高光\" class=\"headerlink\" title=\"高光\"></a>高光</h3><p>高光项与漫反射的计算项类似，但是不同的是，漫反射的效果只和入射角度有关，与观察角度的是没有关系的。但是高光与相机的观察角度也是有关系的，在接近出射角的位置，高光最明显，在于远离出射角的位置高光几乎不可见：<br><img src=\"/images/graphics6/graphics6_Specular.png\" alt=\"\"><br>因此对于高光项来说，镜头视角与出射光的夹角对于着色效果影响很大。直接计算这个夹角值相对来说比较困难，因为需要确定出射角的方向。这里Blinn-Phong很巧妙地简化了这一计算，直接计算入射方向 $l$ 和相机视角方向 $v$ 的半程向量 $h$。使用法线 $n$ 与半程向量 $h$的夹角来作为计算参数。</p>\n<p>高光的大小和强度理论上也需要在反射模型中通过公式来体现，对$n \\cdot h$增加求幂计算，对整体通过乘于参数$K_s$，就可以控制其大小和强度，其因素变化如下图：<br><img src=\"/images/graphics6/graphics6_spe_param.png\" alt=\"\"></p>\n<p>将上述所有的因素组合起来，得到高光项的计算公式：</p>\n<script type=\"math/tex; mode=display\">\nL_s = K_s (I/r^2)max(0, \\cos{\\alpha})^p = K_s(I/r^2)max(0, {h \\cdot n})^p</script><h3 id=\"环境光\"><a href=\"#环境光\" class=\"headerlink\" title=\"环境光\"></a>环境光</h3><p>环境光的着色过程，不依赖于任何的系数的。它只负责绘制绘制物体的轮廓形态，通常只会填充一些固定的颜色，不会考虑物体的光照效果，只是一个估计值。<br><img src=\"/images/graphics6/graphics6_Ambient.png\" alt=\"\"></p>\n<h3 id=\"Blinn-Phong反射模型\"><a href=\"#Blinn-Phong反射模型\" class=\"headerlink\" title=\"Blinn-Phong反射模型\"></a>Blinn-Phong反射模型</h3><p>Blinn-Phong反射模型就是结合了环境光、漫反射、高光三项的计算模型。<br><img src=\"/images/graphics6/graphics6_combine.png\" alt=\"\"></p>\n<p>结合公式来看：</p>\n<script type=\"math/tex; mode=display\">\nL = L_a + L_d + L_s = K_aI_a + K_d(I/r^2)max(0, n \\cdot l) + K_s(I/r^2)max(0, n \\cdot h)^p</script><h2 id=\"着色频率\"><a href=\"#着色频率\" class=\"headerlink\" title=\"着色频率\"></a>着色频率</h2><p>当我们计算出着色信息之后，需要将颜色信息绘制到图形上。在着色过程中，图形上每个像素点的位置和颜色信息都不尽相同。。如果我们单纯地对每个像素点进行计算着色，那么对于那些形状/颜色变化过大地物体就会有非常大地计算量，因此业界有三种着色方式来优化着色过程。</p>\n<h3 id=\"Flat-Shading-平面着色\"><a href=\"#Flat-Shading-平面着色\" class=\"headerlink\" title=\"Flat Shading(平面着色)\"></a>Flat Shading(平面着色)</h3><p>像素着色对于着色的性能消耗较高，因为我们需要对每个像素点进行单独的计算。在实际情况中，往往不需要这么高的精度，因为对于某些图形来说，局部的颜色几乎是相同的。这时候可以通过将图形划分为多个三角形面，单独地对每个三角形进行一次着色，这种方式叫平面着色（Flat Shaing)。但是平面着色有个显著的问题，当三角形划分较大的时候，着色效果很差，因为整块三角形都使用同样的色值，无法做颜色边界区分。</p>\n<h3 id=\"Gourand-Shading（顶点着色）\"><a href=\"#Gourand-Shading（顶点着色）\" class=\"headerlink\" title=\"Gourand Shading（顶点着色）\"></a>Gourand Shading（顶点着色）</h3><p>定点着色的思路和平面着色思路类似，但是它使用了差值的方式来优化平面着色的效果。大体思路是先通过对三角形的顶点的法线方向的颜色计算值进行着色，当其颜色值确定后，三角形内的颜色可以通过插值的方式来计算得出。其明暗处理只在多边形顶点处采用Phong局部反射模型计算光强，而在多边形内的其他点采用双向线性插值，这样做的优点是高效，但是无法很好的处理镜面高光问题，依赖于其所在多面形的相对位置；</p>\n<h3 id=\"Phong-Shading（像素着色）\"><a href=\"#Phong-Shading（像素着色）\" class=\"headerlink\" title=\"Phong Shading（像素着色）\"></a>Phong Shading（像素着色）</h3><p>它对三角形的每个片元进行着色计算。这个方法有时也称为逐片元着色（per-pixel shading）。由于颜色是按片元着色的，因此得到的结果比Gouraud着色好，尤其是用于光亮表面。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"可见性和Z-buffer\"><a href=\"#可见性和Z-buffer\" class=\"headerlink\" title=\"可见性和Z-buffer\"></a>可见性和Z-buffer</h2><p>对于在一个场景中进行绘制时，将3D模型投影到2D屏幕上的时候，总会出现遮盖的情景。那么那些部分可见，那些部分不可见是需要考虑的。最直接的方式就是一层一层，从远及近将这张图给画出来，这样前景的物体就会遮挡住背景的物体。这种绘制方式叫做画家算法（painter’s algorithm）<br>但是这种简单的做法在很多场景是很难解决的，因为远近先后顺序这个很难做判断。比如说下面这个场景三角形$P、R、Q$相互的前后关系很难确定，实际要表现的效果是互有遮挡。因此单纯使用画家算法来一层层进行绘制，是很难达到显示效果的。<br><img src=\"/images/graphics6/graphics6_painter.png\" alt=\"\"></p>\n<p>Z-buffer算法解决了这个问题，因为对于三角形来说确定遮挡关系很难，但是对于像素来说，是可以有明确的遮挡关系的。对于2D场景中任意一个点$(x, y)$，存储其深度（depth）信息$z$，每次绘制像素点$(x, y)$时，比较其与zbuffer(x, y)的值进行比较，如果小的话则将深度其存储在zbuffer中，并将其颜色信息存储在framebuffer中。当场景计算完毕之后，再通过framebuffer进行绘制。伪代码如下：<br><pre><code class=\"hljs gml\"><span class=\"hljs-keyword\">for</span> (each triangle T)\n    <span class=\"hljs-keyword\">for</span> (each sample (<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>,z) in T)\n        <span class=\"hljs-keyword\">if</span> (z &lt; zbuffer[<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>]) \n            framebuffer[<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>] = rgb; <span class=\"hljs-comment\">// 存储颜色信息</span>\n            zbuffer[<span class=\"hljs-symbol\">x</span>,<span class=\"hljs-symbol\">y</span>] = z; <span class=\"hljs-comment\">// 存储z信息</span>\n        <span class=\"hljs-keyword\">else</span>\n            ... <span class=\"hljs-comment\">// do nothing</span></code></pre></p>\n<h2 id=\"光照和着色\"><a href=\"#光照和着色\" class=\"headerlink\" title=\"光照和着色\"></a>光照和着色</h2><p>着色（shading）过程是渲染过程非常关键的一步，简单来说就是光栅化过程中计算每个采样点的颜色色值。在词典中着色的解释如下：</p>\n<pre><code class=\"hljs mipsasm\"><span class=\"hljs-keyword\">shad·ing, </span>[ˈʃeɪdɪŋ], noun\nThe darkening <span class=\"hljs-keyword\">or </span>coloring of an illustration <span class=\"hljs-keyword\">or </span><span class=\"hljs-keyword\">diagram </span>with parallel lines <span class=\"hljs-keyword\">or </span>a <span class=\"hljs-keyword\">block </span>of color.</code></pre>\n<p>正如解释所说，shading过程实际上就是引入明暗不同以及颜色的变化，在图形学课程中，往往shading指对不同的物体，应用不同的材质。</p>\n<p>对于一个物体而言，我们之所以能看见他，是因为光线在其表面发生了反射和吸收，之后传达到了人眼中。物体将特定频率的光线进行反射，也形成了其颜色。在相同材质的物体上，却有不同的颜色和明暗变化。这是因为光源以及光的反射方式的不同。如下图所示是一个光线的反射场景：<br><img src=\"/images/graphics6/graphics6_shading.png\" alt=\"\"><br>对于光线反射而言，一共有三种反射类型：</p>\n<ol>\n<li>镜面反射</li>\n<li>漫反射</li>\n<li>环境光</li>\n</ol>\n<h3 id=\"镜面反射\"><a href=\"#镜面反射\" class=\"headerlink\" title=\"镜面反射\"></a>镜面反射</h3><p>镜面反射模型比较简单，以光线与反射面接触点（shading point）的法线方向为中界限，入射角等于出射角。影响镜面反射模型的着色因素主要有入射角度、相机角度、法线方向以及表面材质（影响折射率）。<br><img src=\"/images/graphics6/graphics6_Specula.png\" alt=\"\"></p>\n<h3 id=\"漫反射\"><a href=\"#漫反射\" class=\"headerlink\" title=\"漫反射\"></a>漫反射</h3><p>漫反射模型也相对比较简单。理论上在漫反射模型中，无论光源的位置在任何地方，在反射面都会形成所有方向的反射光。而且在漫反射模型中，反射光的强度在任何方向上都是一致的，无论入射光的角度在任意的方向。</p>\n<p>但是漫反射能反射多少能量强度的光源与入射角有很直接的关系。假设光源的强度一定时，我们抽象出单位宽度的平行光源，假定在任意角度下，表面材质对漫反射的折射率一定。当入射角度为90度时，理论上反射面能接收被反射所有的光线。但是当反射面与入射光线有一定的夹脚时，反射面就只能接收部分反射光线。此时的光照强度，应该乘于夹角系数$cos\\theta = l \\cdot n$，其中$l$为入射角的方向，$n$为法线方向。<br><img src=\"/images/graphics6/graphics6_lambertian.png\" alt=\"\"></p>\n<p>另外，对于光线传播来说，传递的光线总是会随着传播的距离能量会随之衰减。以点光源向四面扩散为例，光源发射出来的能量其实是一定的，那么在任意两个圈上接受到的能量之和一定相等。而离圆心越远，圆的面积越大，单位面积所接受能量也就越弱。其到达某个点的光照强度应为：$I/r^2$，其中$I$为光源光照强度，$r$为距离。<br><img src=\"/images/graphics6/graphics6_energy.png\" alt=\"\"></p>\n<p>结合光照强度参数和漫反射的入射角度强度计算，可以得到一个计算漫反射光照强度的公式：<br><img src=\"/images/graphics6/graphics6_diffuse_function.png\" alt=\"\"><br>其中：</p>\n<ul>\n<li>$k_d$ 为漫反射系数，可能会受到材质等影响</li>\n<li>$I$ 为入射光照强度，$r$ 为shading point距离光源的距离</li>\n<li>$n, l$ 分别如图中所示为法线向量和入射方向</li>\n</ul>\n<h3 id=\"高光\"><a href=\"#高光\" class=\"headerlink\" title=\"高光\"></a>高光</h3><p>高光项与漫反射的计算项类似，但是不同的是，漫反射的效果只和入射角度有关，与观察角度的是没有关系的。但是高光与相机的观察角度也是有关系的，在接近出射角的位置，高光最明显，在于远离出射角的位置高光几乎不可见：<br><img src=\"/images/graphics6/graphics6_Specular.png\" alt=\"\"><br>因此对于高光项来说，镜头视角与出射光的夹角对于着色效果影响很大。直接计算这个夹角值相对来说比较困难，因为需要确定出射角的方向。这里Blinn-Phong很巧妙地简化了这一计算，直接计算入射方向 $l$ 和相机视角方向 $v$ 的半程向量 $h$。使用法线 $n$ 与半程向量 $h$的夹角来作为计算参数。</p>\n<p>高光的大小和强度理论上也需要在反射模型中通过公式来体现，对$n \\cdot h$增加求幂计算，对整体通过乘于参数$K_s$，就可以控制其大小和强度，其因素变化如下图：<br><img src=\"/images/graphics6/graphics6_spe_param.png\" alt=\"\"></p>\n<p>将上述所有的因素组合起来，得到高光项的计算公式：</p>\n<script type=\"math/tex; mode=display\">\nL_s = K_s (I/r^2)max(0, \\cos{\\alpha})^p = K_s(I/r^2)max(0, {h \\cdot n})^p</script><h3 id=\"环境光\"><a href=\"#环境光\" class=\"headerlink\" title=\"环境光\"></a>环境光</h3><p>环境光的着色过程，不依赖于任何的系数的。它只负责绘制绘制物体的轮廓形态，通常只会填充一些固定的颜色，不会考虑物体的光照效果，只是一个估计值。<br><img src=\"/images/graphics6/graphics6_Ambient.png\" alt=\"\"></p>\n<h3 id=\"Blinn-Phong反射模型\"><a href=\"#Blinn-Phong反射模型\" class=\"headerlink\" title=\"Blinn-Phong反射模型\"></a>Blinn-Phong反射模型</h3><p>Blinn-Phong反射模型就是结合了环境光、漫反射、高光三项的计算模型。<br><img src=\"/images/graphics6/graphics6_combine.png\" alt=\"\"></p>\n<p>结合公式来看：</p>\n<script type=\"math/tex; mode=display\">\nL = L_a + L_d + L_s = K_aI_a + K_d(I/r^2)max(0, n \\cdot l) + K_s(I/r^2)max(0, n \\cdot h)^p</script><h2 id=\"着色频率\"><a href=\"#着色频率\" class=\"headerlink\" title=\"着色频率\"></a>着色频率</h2><p>当我们计算出着色信息之后，需要将颜色信息绘制到图形上。在着色过程中，图形上每个像素点的位置和颜色信息都不尽相同。。如果我们单纯地对每个像素点进行计算着色，那么对于那些形状/颜色变化过大地物体就会有非常大地计算量，因此业界有三种着色方式来优化着色过程。</p>\n<h3 id=\"Flat-Shading-平面着色\"><a href=\"#Flat-Shading-平面着色\" class=\"headerlink\" title=\"Flat Shading(平面着色)\"></a>Flat Shading(平面着色)</h3><p>像素着色对于着色的性能消耗较高，因为我们需要对每个像素点进行单独的计算。在实际情况中，往往不需要这么高的精度，因为对于某些图形来说，局部的颜色几乎是相同的。这时候可以通过将图形划分为多个三角形面，单独地对每个三角形进行一次着色，这种方式叫平面着色（Flat Shaing)。但是平面着色有个显著的问题，当三角形划分较大的时候，着色效果很差，因为整块三角形都使用同样的色值，无法做颜色边界区分。</p>\n<h3 id=\"Gourand-Shading（顶点着色）\"><a href=\"#Gourand-Shading（顶点着色）\" class=\"headerlink\" title=\"Gourand Shading（顶点着色）\"></a>Gourand Shading（顶点着色）</h3><p>定点着色的思路和平面着色思路类似，但是它使用了差值的方式来优化平面着色的效果。大体思路是先通过对三角形的顶点的法线方向的颜色计算值进行着色，当其颜色值确定后，三角形内的颜色可以通过插值的方式来计算得出。其明暗处理只在多边形顶点处采用Phong局部反射模型计算光强，而在多边形内的其他点采用双向线性插值，这样做的优点是高效，但是无法很好的处理镜面高光问题，依赖于其所在多面形的相对位置；</p>\n<h3 id=\"Phong-Shading（像素着色）\"><a href=\"#Phong-Shading（像素着色）\" class=\"headerlink\" title=\"Phong Shading（像素着色）\"></a>Phong Shading（像素着色）</h3><p>它对三角形的每个片元进行着色计算。这个方法有时也称为逐片元着色（per-pixel shading）。由于颜色是按片元着色的，因此得到的结果比Gouraud着色好，尤其是用于光亮表面。</p>\n"},{"title":"计算机图形学7.5 —— 重心坐标和线性插值","index_img":"/images/graphics7.5/graphics7.5_banner.png","date":"2020-10-03T09:09:11.000Z","math":true,"_content":"\n## 重心坐标的定义\n重心坐标是由三角形顶点定义出的一个特征坐标，它满足以下特征：\n1. 令$\\alpha$、$\\beta$、$\\gamma$为数字常量，且 $\\alpha + \\beta + \\gamma = 1$。\n2. 重心坐标则为三个顶点分别乘以三个系数的坐标值，即 $(x, y) = \\alpha A + \\beta B + \\gamma C$\n*注意：* 重心坐标不是重心，它是一种笛卡尔坐标的线性变化，不能将其混淆。\n![](/images/graphics7.5/barycentric_coordinates.png)\n\n\n此外在三角形中，重心坐标又被称为面积坐标。因为P点关于三角形ABC的重心坐标和三角形PBC, PCA及PAB的（有向）面积成比例。证明如下：（如下图所示）\n\n我们用黑体小写字母表示对应点的向量，比如三角形ABC顶点为 $a$、$b$、$c$，P点为$p$。设三角形PBC、PCA以及PAB的比例为 $\\lambda_1 : \\lambda_2 : \\lambda_3$，且$\\lambda_1 + \\lambda_2 + \\lambda_3 = 1$，设射线AP与BC交于D。\n\n![](/images/graphics7.5/Areal_coordinates.png)\n\n\n$$\n由相似三角形的特性可以得出：\nBD : DC = \\lambda_3 : \\lambda_2\n$$\n\n$$\n则d的坐标为：\n d = \\frac{\\lambda_2 b  + \\lambda_3 c}{\\lambda_2 + \\lambda_3} \n$$\n\n$$\n同理：\nAP : PC = (\\lambda_3 + \\lambda_2) : \\lambda_1\n$$\n\n$$\n则 p 的坐标为：\np = \\frac{(\\lambda_3 + \\lambda_2) d  + \\lambda1 a}{\\lambda_1 + \\lambda_2 + \\lambda_3}\n$$\n\n$$\n综上化简后，p为：\np = \\lambda_1 a + \\lambda_2 b + \\lambda_3 c\n$$\n\n## 重心坐标的表示法\n给定三角形平面一点P，我们将这一点的面积坐标$\\lambda_1 $ 、 $\\lambda_2 $ 和 $\\lambda_3$，用笛卡尔坐标表示出来。利用笛卡尔坐标中的三角形面积公式：\n$$\nS(ABC) = \\frac{1}{2}{\\begin{vmatrix} 1 & x_a & y_a \\\\ 1 & x_b & y_b  \\\\ 1 & x_c & y_c  \\end{vmatrix}}\n$$\n可以得到：\n$$\n\\lambda_1 = S(PAC) / S(ABC) = {\\begin{vmatrix} 1 & x_p & y_p \\\\ 1 & x_a & y_a  \\\\ 1 & x_c & y_c  \\end{vmatrix}} / {\\begin{vmatrix} 1 & x_a & y_a \\\\ 1 & x_b & y_b  \\\\ 1 & x_c & y_c  \\end{vmatrix}}\n$$\n\n根据重心坐标的定义，重心坐标可以表示为：\n$$\n\\left\\{\\begin{matrix} \\lambda_1+\\lambda_2+\\lambda_3=1 \\\\  p_x=\\lambda_1*x_{a}+\\lambda_2*x_{b}+\\lambda_3*x_{c}  \\\\ p_y=\\lambda_1*y_{a}+\\lambda_2*y_{b}+\\lambda_3*y_{c}  \\end{matrix}\\right.\n$$\n\n\n由此可以看出重心坐标实际上是笛卡尔坐标的一种线性变换，从而它们在边和三角形区域之间的变化是线性的。如果点在三角形内部，那么所有重心坐标属于开区间$(0, 1)$；如果一点在三角形的边上，至少有一个面积坐标$\\lambda_{1...3}$为0，其余分量位于闭区间$(0, 1)$。如果有某个坐标小于0，则位于三角形外部。\n\n\n## 重心坐标的应用——线性插值\n除了前面利用重心坐标来判断点是否在三角形内的方法外，它在图形学中最重要的功能在于线性插值。线性插值的过程如下：\n\n假设我们已知坐标 $(x0, y0)$ 与 $(x1, y1)$，要得到 $[x0, x1]$ 区间内某一位置 $x $在直线上的值。根据图中所示，我们得到\n$$\n\\frac{y - y_0}{x - x_0} = \\frac{y_1 - y_0}{x_1 - x_0}\n$$\n\n由于 x 值已知，所以可以从公式得到 y 的值\n$$\ny = y_0 + (x - x_0) \\frac{y_1 - y_0}{x_1 - x_0}\n$$\n已知 $y$ 求 $x$ 的过程与以上过程相同，只是 $x$ 与 $y$ 要进行交换。\n\n在图形学中常常会使用线性插值来解决很多值变化的问题，比如openGL中的 `varying variables` 就是一种使用线性插值对顶点或者片元进行着色的方式。\n\n利用重心坐标可以很好的将顶点的值（位置、纹理坐标、颜色、法线、深度、材质等）快速平滑地过渡到三角形的每个点上。\n\n","source":"_posts/ComputerGraphics7.5.md","raw":"---\ntitle: 计算机图形学7.5 —— 重心坐标和线性插值\ntags: [计算机图形学, 重心坐标, 线性插值]\ncategories: [GAMES101]\nindex_img: /images/graphics7.5/graphics7.5_banner.png\ndate: 2020-10-03 17:09:11\nmath: true\n---\n\n## 重心坐标的定义\n重心坐标是由三角形顶点定义出的一个特征坐标，它满足以下特征：\n1. 令$\\alpha$、$\\beta$、$\\gamma$为数字常量，且 $\\alpha + \\beta + \\gamma = 1$。\n2. 重心坐标则为三个顶点分别乘以三个系数的坐标值，即 $(x, y) = \\alpha A + \\beta B + \\gamma C$\n*注意：* 重心坐标不是重心，它是一种笛卡尔坐标的线性变化，不能将其混淆。\n![](/images/graphics7.5/barycentric_coordinates.png)\n\n\n此外在三角形中，重心坐标又被称为面积坐标。因为P点关于三角形ABC的重心坐标和三角形PBC, PCA及PAB的（有向）面积成比例。证明如下：（如下图所示）\n\n我们用黑体小写字母表示对应点的向量，比如三角形ABC顶点为 $a$、$b$、$c$，P点为$p$。设三角形PBC、PCA以及PAB的比例为 $\\lambda_1 : \\lambda_2 : \\lambda_3$，且$\\lambda_1 + \\lambda_2 + \\lambda_3 = 1$，设射线AP与BC交于D。\n\n![](/images/graphics7.5/Areal_coordinates.png)\n\n\n$$\n由相似三角形的特性可以得出：\nBD : DC = \\lambda_3 : \\lambda_2\n$$\n\n$$\n则d的坐标为：\n d = \\frac{\\lambda_2 b  + \\lambda_3 c}{\\lambda_2 + \\lambda_3} \n$$\n\n$$\n同理：\nAP : PC = (\\lambda_3 + \\lambda_2) : \\lambda_1\n$$\n\n$$\n则 p 的坐标为：\np = \\frac{(\\lambda_3 + \\lambda_2) d  + \\lambda1 a}{\\lambda_1 + \\lambda_2 + \\lambda_3}\n$$\n\n$$\n综上化简后，p为：\np = \\lambda_1 a + \\lambda_2 b + \\lambda_3 c\n$$\n\n## 重心坐标的表示法\n给定三角形平面一点P，我们将这一点的面积坐标$\\lambda_1 $ 、 $\\lambda_2 $ 和 $\\lambda_3$，用笛卡尔坐标表示出来。利用笛卡尔坐标中的三角形面积公式：\n$$\nS(ABC) = \\frac{1}{2}{\\begin{vmatrix} 1 & x_a & y_a \\\\ 1 & x_b & y_b  \\\\ 1 & x_c & y_c  \\end{vmatrix}}\n$$\n可以得到：\n$$\n\\lambda_1 = S(PAC) / S(ABC) = {\\begin{vmatrix} 1 & x_p & y_p \\\\ 1 & x_a & y_a  \\\\ 1 & x_c & y_c  \\end{vmatrix}} / {\\begin{vmatrix} 1 & x_a & y_a \\\\ 1 & x_b & y_b  \\\\ 1 & x_c & y_c  \\end{vmatrix}}\n$$\n\n根据重心坐标的定义，重心坐标可以表示为：\n$$\n\\left\\{\\begin{matrix} \\lambda_1+\\lambda_2+\\lambda_3=1 \\\\  p_x=\\lambda_1*x_{a}+\\lambda_2*x_{b}+\\lambda_3*x_{c}  \\\\ p_y=\\lambda_1*y_{a}+\\lambda_2*y_{b}+\\lambda_3*y_{c}  \\end{matrix}\\right.\n$$\n\n\n由此可以看出重心坐标实际上是笛卡尔坐标的一种线性变换，从而它们在边和三角形区域之间的变化是线性的。如果点在三角形内部，那么所有重心坐标属于开区间$(0, 1)$；如果一点在三角形的边上，至少有一个面积坐标$\\lambda_{1...3}$为0，其余分量位于闭区间$(0, 1)$。如果有某个坐标小于0，则位于三角形外部。\n\n\n## 重心坐标的应用——线性插值\n除了前面利用重心坐标来判断点是否在三角形内的方法外，它在图形学中最重要的功能在于线性插值。线性插值的过程如下：\n\n假设我们已知坐标 $(x0, y0)$ 与 $(x1, y1)$，要得到 $[x0, x1]$ 区间内某一位置 $x $在直线上的值。根据图中所示，我们得到\n$$\n\\frac{y - y_0}{x - x_0} = \\frac{y_1 - y_0}{x_1 - x_0}\n$$\n\n由于 x 值已知，所以可以从公式得到 y 的值\n$$\ny = y_0 + (x - x_0) \\frac{y_1 - y_0}{x_1 - x_0}\n$$\n已知 $y$ 求 $x$ 的过程与以上过程相同，只是 $x$ 与 $y$ 要进行交换。\n\n在图形学中常常会使用线性插值来解决很多值变化的问题，比如openGL中的 `varying variables` 就是一种使用线性插值对顶点或者片元进行着色的方式。\n\n利用重心坐标可以很好的将顶点的值（位置、纹理坐标、颜色、法线、深度、材质等）快速平滑地过渡到三角形的每个点上。\n\n","slug":"ComputerGraphics7.5","published":1,"updated":"2021-03-19T11:15:07.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wah000qnwqc7uaq1ntv","content":"<h2 id=\"重心坐标的定义\"><a href=\"#重心坐标的定义\" class=\"headerlink\" title=\"重心坐标的定义\"></a>重心坐标的定义</h2><p>重心坐标是由三角形顶点定义出的一个特征坐标，它满足以下特征：</p>\n<ol>\n<li>令$\\alpha$、$\\beta$、$\\gamma$为数字常量，且 $\\alpha + \\beta + \\gamma = 1$。</li>\n<li>重心坐标则为三个顶点分别乘以三个系数的坐标值，即 $(x, y) = \\alpha A + \\beta B + \\gamma C$<br><em>注意：</em> 重心坐标不是重心，它是一种笛卡尔坐标的线性变化，不能将其混淆。<br><img src=\"/images/graphics7.5/barycentric_coordinates.png\" alt=\"\"></li>\n</ol>\n<p>此外在三角形中，重心坐标又被称为面积坐标。因为P点关于三角形ABC的重心坐标和三角形PBC, PCA及PAB的（有向）面积成比例。证明如下：（如下图所示）</p>\n<p>我们用黑体小写字母表示对应点的向量，比如三角形ABC顶点为 $a$、$b$、$c$，P点为$p$。设三角形PBC、PCA以及PAB的比例为 $\\lambda_1 : \\lambda_2 : \\lambda_3$，且$\\lambda_1 + \\lambda_2 + \\lambda_3 = 1$，设射线AP与BC交于D。</p>\n<p><img src=\"/images/graphics7.5/Areal_coordinates.png\" alt=\"\"></p>\n<script type=\"math/tex; mode=display\">\n由相似三角形的特性可以得出：\nBD : DC = \\lambda_3 : \\lambda_2</script><script type=\"math/tex; mode=display\">\n则d的坐标为：\n d = \\frac{\\lambda_2 b  + \\lambda_3 c}{\\lambda_2 + \\lambda_3}</script><script type=\"math/tex; mode=display\">\n同理：\nAP : PC = (\\lambda_3 + \\lambda_2) : \\lambda_1</script><script type=\"math/tex; mode=display\">\n则 p 的坐标为：\np = \\frac{(\\lambda_3 + \\lambda_2) d  + \\lambda1 a}{\\lambda_1 + \\lambda_2 + \\lambda_3}</script><script type=\"math/tex; mode=display\">\n综上化简后，p为：\np = \\lambda_1 a + \\lambda_2 b + \\lambda_3 c</script><h2 id=\"重心坐标的表示法\"><a href=\"#重心坐标的表示法\" class=\"headerlink\" title=\"重心坐标的表示法\"></a>重心坐标的表示法</h2><p>给定三角形平面一点P，我们将这一点的面积坐标$\\lambda_1 $ 、 $\\lambda_2 $ 和 $\\lambda_3$，用笛卡尔坐标表示出来。利用笛卡尔坐标中的三角形面积公式：</p>\n<script type=\"math/tex; mode=display\">\nS(ABC) = \\frac{1}{2}{\\begin{vmatrix} 1 & x_a & y_a \\\\ 1 & x_b & y_b  \\\\ 1 & x_c & y_c  \\end{vmatrix}}</script><p>可以得到：</p>\n<script type=\"math/tex; mode=display\">\n\\lambda_1 = S(PAC) / S(ABC) = {\\begin{vmatrix} 1 & x_p & y_p \\\\ 1 & x_a & y_a  \\\\ 1 & x_c & y_c  \\end{vmatrix}} / {\\begin{vmatrix} 1 & x_a & y_a \\\\ 1 & x_b & y_b  \\\\ 1 & x_c & y_c  \\end{vmatrix}}</script><p>根据重心坐标的定义，重心坐标可以表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\left\\{\\begin{matrix} \\lambda_1+\\lambda_2+\\lambda_3=1 \\\\  p_x=\\lambda_1*x_{a}+\\lambda_2*x_{b}+\\lambda_3*x_{c}  \\\\ p_y=\\lambda_1*y_{a}+\\lambda_2*y_{b}+\\lambda_3*y_{c}  \\end{matrix}\\right.</script><p>由此可以看出重心坐标实际上是笛卡尔坐标的一种线性变换，从而它们在边和三角形区域之间的变化是线性的。如果点在三角形内部，那么所有重心坐标属于开区间$(0, 1)$；如果一点在三角形的边上，至少有一个面积坐标$\\lambda_{1…3}$为0，其余分量位于闭区间$(0, 1)$。如果有某个坐标小于0，则位于三角形外部。</p>\n<h2 id=\"重心坐标的应用——线性插值\"><a href=\"#重心坐标的应用——线性插值\" class=\"headerlink\" title=\"重心坐标的应用——线性插值\"></a>重心坐标的应用——线性插值</h2><p>除了前面利用重心坐标来判断点是否在三角形内的方法外，它在图形学中最重要的功能在于线性插值。线性插值的过程如下：</p>\n<p>假设我们已知坐标 $(x0, y0)$ 与 $(x1, y1)$，要得到 $[x0, x1]$ 区间内某一位置 $x $在直线上的值。根据图中所示，我们得到</p>\n<script type=\"math/tex; mode=display\">\n\\frac{y - y_0}{x - x_0} = \\frac{y_1 - y_0}{x_1 - x_0}</script><p>由于 x 值已知，所以可以从公式得到 y 的值</p>\n<script type=\"math/tex; mode=display\">\ny = y_0 + (x - x_0) \\frac{y_1 - y_0}{x_1 - x_0}</script><p>已知 $y$ 求 $x$ 的过程与以上过程相同，只是 $x$ 与 $y$ 要进行交换。</p>\n<p>在图形学中常常会使用线性插值来解决很多值变化的问题，比如openGL中的 <code>varying variables</code> 就是一种使用线性插值对顶点或者片元进行着色的方式。</p>\n<p>利用重心坐标可以很好的将顶点的值（位置、纹理坐标、颜色、法线、深度、材质等）快速平滑地过渡到三角形的每个点上。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"重心坐标的定义\"><a href=\"#重心坐标的定义\" class=\"headerlink\" title=\"重心坐标的定义\"></a>重心坐标的定义</h2><p>重心坐标是由三角形顶点定义出的一个特征坐标，它满足以下特征：</p>\n<ol>\n<li>令$\\alpha$、$\\beta$、$\\gamma$为数字常量，且 $\\alpha + \\beta + \\gamma = 1$。</li>\n<li>重心坐标则为三个顶点分别乘以三个系数的坐标值，即 $(x, y) = \\alpha A + \\beta B + \\gamma C$<br><em>注意：</em> 重心坐标不是重心，它是一种笛卡尔坐标的线性变化，不能将其混淆。<br><img src=\"/images/graphics7.5/barycentric_coordinates.png\" alt=\"\"></li>\n</ol>\n<p>此外在三角形中，重心坐标又被称为面积坐标。因为P点关于三角形ABC的重心坐标和三角形PBC, PCA及PAB的（有向）面积成比例。证明如下：（如下图所示）</p>\n<p>我们用黑体小写字母表示对应点的向量，比如三角形ABC顶点为 $a$、$b$、$c$，P点为$p$。设三角形PBC、PCA以及PAB的比例为 $\\lambda_1 : \\lambda_2 : \\lambda_3$，且$\\lambda_1 + \\lambda_2 + \\lambda_3 = 1$，设射线AP与BC交于D。</p>\n<p><img src=\"/images/graphics7.5/Areal_coordinates.png\" alt=\"\"></p>\n<script type=\"math/tex; mode=display\">\n由相似三角形的特性可以得出：\nBD : DC = \\lambda_3 : \\lambda_2</script><script type=\"math/tex; mode=display\">\n则d的坐标为：\n d = \\frac{\\lambda_2 b  + \\lambda_3 c}{\\lambda_2 + \\lambda_3}</script><script type=\"math/tex; mode=display\">\n同理：\nAP : PC = (\\lambda_3 + \\lambda_2) : \\lambda_1</script><script type=\"math/tex; mode=display\">\n则 p 的坐标为：\np = \\frac{(\\lambda_3 + \\lambda_2) d  + \\lambda1 a}{\\lambda_1 + \\lambda_2 + \\lambda_3}</script><script type=\"math/tex; mode=display\">\n综上化简后，p为：\np = \\lambda_1 a + \\lambda_2 b + \\lambda_3 c</script><h2 id=\"重心坐标的表示法\"><a href=\"#重心坐标的表示法\" class=\"headerlink\" title=\"重心坐标的表示法\"></a>重心坐标的表示法</h2><p>给定三角形平面一点P，我们将这一点的面积坐标$\\lambda_1 $ 、 $\\lambda_2 $ 和 $\\lambda_3$，用笛卡尔坐标表示出来。利用笛卡尔坐标中的三角形面积公式：</p>\n<script type=\"math/tex; mode=display\">\nS(ABC) = \\frac{1}{2}{\\begin{vmatrix} 1 & x_a & y_a \\\\ 1 & x_b & y_b  \\\\ 1 & x_c & y_c  \\end{vmatrix}}</script><p>可以得到：</p>\n<script type=\"math/tex; mode=display\">\n\\lambda_1 = S(PAC) / S(ABC) = {\\begin{vmatrix} 1 & x_p & y_p \\\\ 1 & x_a & y_a  \\\\ 1 & x_c & y_c  \\end{vmatrix}} / {\\begin{vmatrix} 1 & x_a & y_a \\\\ 1 & x_b & y_b  \\\\ 1 & x_c & y_c  \\end{vmatrix}}</script><p>根据重心坐标的定义，重心坐标可以表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\left\\{\\begin{matrix} \\lambda_1+\\lambda_2+\\lambda_3=1 \\\\  p_x=\\lambda_1*x_{a}+\\lambda_2*x_{b}+\\lambda_3*x_{c}  \\\\ p_y=\\lambda_1*y_{a}+\\lambda_2*y_{b}+\\lambda_3*y_{c}  \\end{matrix}\\right.</script><p>由此可以看出重心坐标实际上是笛卡尔坐标的一种线性变换，从而它们在边和三角形区域之间的变化是线性的。如果点在三角形内部，那么所有重心坐标属于开区间$(0, 1)$；如果一点在三角形的边上，至少有一个面积坐标$\\lambda_{1…3}$为0，其余分量位于闭区间$(0, 1)$。如果有某个坐标小于0，则位于三角形外部。</p>\n<h2 id=\"重心坐标的应用——线性插值\"><a href=\"#重心坐标的应用——线性插值\" class=\"headerlink\" title=\"重心坐标的应用——线性插值\"></a>重心坐标的应用——线性插值</h2><p>除了前面利用重心坐标来判断点是否在三角形内的方法外，它在图形学中最重要的功能在于线性插值。线性插值的过程如下：</p>\n<p>假设我们已知坐标 $(x0, y0)$ 与 $(x1, y1)$，要得到 $[x0, x1]$ 区间内某一位置 $x $在直线上的值。根据图中所示，我们得到</p>\n<script type=\"math/tex; mode=display\">\n\\frac{y - y_0}{x - x_0} = \\frac{y_1 - y_0}{x_1 - x_0}</script><p>由于 x 值已知，所以可以从公式得到 y 的值</p>\n<script type=\"math/tex; mode=display\">\ny = y_0 + (x - x_0) \\frac{y_1 - y_0}{x_1 - x_0}</script><p>已知 $y$ 求 $x$ 的过程与以上过程相同，只是 $x$ 与 $y$ 要进行交换。</p>\n<p>在图形学中常常会使用线性插值来解决很多值变化的问题，比如openGL中的 <code>varying variables</code> 就是一种使用线性插值对顶点或者片元进行着色的方式。</p>\n<p>利用重心坐标可以很好的将顶点的值（位置、纹理坐标、颜色、法线、深度、材质等）快速平滑地过渡到三角形的每个点上。</p>\n"},{"title":"计算机图形学7 —— 渲染管线","index_img":"/images/graphics7/graphics7_banner.png","date":"2020-10-03T09:09:11.000Z","math":true,"_content":"\n## 渲染管线\n渲染管线是实时渲染的重要工具，实时渲染离不开渲染管线。图形渲染管线主要包括两个功能：一是将物体3D坐标转变为屏幕空间2D坐标，二是为屏幕每个像素点进行着色。渲染管线的一般流程如下图所示。分别是：顶点数据的输入、顶点着色器、曲面细分过程、几何着色器、图元组装、裁剪剔除、光栅化、片段着色器以及混合测试。渲染管线流程实际上就是对前文中介绍的各项技术的一个总结。其大致流程如下图：\n![](/images/graphics7/graphics7_banner.png)\n\n* 顶点处理，即将在3D场景的顶点数据转换为2D屏幕的坐标数据（MVP过程）。\n* 三角形处理，即将顶点分割为屏幕中的渲染三角形。\n* 光栅化，也就是采样过程，确定三角形覆盖的像素。\n* 着色，主要通过着色器对像素进行颜色的绘制。\n* 帧缓冲，输出着色后的图形。\n\n### 顶点处理 && 三角形处理\n![](/images/graphics7/graphics7_vertex.jpg)\n顶点处理过程实际上就是对所有顶点进行Modal、view、projection的转换，将3D的顶点信息投影到2D的屏幕上来。这一部分在本系列笔记的第2、3 部分有着较为详细的讨论。另外，顶点处理还有一个比较重要的作用就是确定像素深度，为后续着色过程中ZBuffer提供深度z值。\n\n三角形处理相对就简单很多，只需要将处理好的顶点数据分割为三角形。对于三角形而言，是几何中最简单的多边形，因此分割为三角形而非其他多边形能有效地提高分割以及渲染的性能。（当然存在一些渲染引擎以四边形作为基础的渲染多边形，以简化建模过程。）\n\n### 光栅化\n当分割为合适的三角形之后，就需要用到我们在本系列笔记的第4部分中提到的光栅化过程。逐个对每个三角形中的每个像素进行采样，判断像素是否在三角形内。而且在光栅化这一步同时涉及到我们在系列笔记第5部分提到的走样的原理以及反走样原理和抗锯齿的过程。\n![](/images/graphics7/graphics7_rasterization.jpg)\n\n### 着色\n渲染管线流程中的着色，是通过着色器（shader）实现的。shader其实就是专门用来渲染图形的一种技术，通过shader，我们可以自定义GPU渲染画面的算法，使画面达到我们想要的效果。一般来说shader分为两类：\n1. 顶点着色器（vertext shader），它的作用主要是处理顶点数据，生成裁剪空间坐标值。\n2. 片段着色曲(fragment shader)，它的作用是主要用来处理三角形内每个像素的颜色值。\n\n![](/images/graphics7/graphics7_shading.jpg)\n当着色器接收到完成光栅化后的片段时，需要对其进行着色处理。在系列笔记的第6部分我们提到了着色的过程，这一过程涉及到渲染管线中的顶点处理和片段处理。顶点着色器运行在顶点处理中。在顶点处理时就可以直接对顶点的值进行计算，比如说Gouraud Shading和phong shading，它们都会涉及到顶点颜色的处理。而片段着色器主要是用来处理图元或者说片段信息，也就是被拆分后的一个个三角形面中的像素。比如说plat shading会直接对一个片段使用同一种颜色进行着色。或者是Gouraud中通过差值的方式，对片段进行着色。\n\n![](/images/graphics7/graphics7_zbuffer.jpg)\n当然，着色的过程始终是在2D平面中进行的，像素也就存在着遮挡问题。这个时候通过ZBuffer缓存，对像素深度信息进行缓存，从而确定，哪些像素点应该显示在屏幕上，哪些点被遮挡了不应该显示。\n\n\n## 总结\n本章主要是对于可编程渲染管线的每个步骤的总结，其内容在前面笔记中都有详细的描述。可编程渲染管线是过去20年中图形学工业腾飞的基石，程序员可以有效的控制渲染过程，编程来代替原来固定的顶点处理和片元处理从而达到各种各样令人惊叹的效果。","source":"_posts/ComputerGraphics7.md","raw":"---\ntitle: 计算机图形学7 —— 渲染管线\ntags: [计算机图形学, 渲染管线]\ncategories: [GAMES101]\nindex_img: /images/graphics7/graphics7_banner.png\ndate: 2020-10-03 17:09:11\nmath: true\n---\n\n## 渲染管线\n渲染管线是实时渲染的重要工具，实时渲染离不开渲染管线。图形渲染管线主要包括两个功能：一是将物体3D坐标转变为屏幕空间2D坐标，二是为屏幕每个像素点进行着色。渲染管线的一般流程如下图所示。分别是：顶点数据的输入、顶点着色器、曲面细分过程、几何着色器、图元组装、裁剪剔除、光栅化、片段着色器以及混合测试。渲染管线流程实际上就是对前文中介绍的各项技术的一个总结。其大致流程如下图：\n![](/images/graphics7/graphics7_banner.png)\n\n* 顶点处理，即将在3D场景的顶点数据转换为2D屏幕的坐标数据（MVP过程）。\n* 三角形处理，即将顶点分割为屏幕中的渲染三角形。\n* 光栅化，也就是采样过程，确定三角形覆盖的像素。\n* 着色，主要通过着色器对像素进行颜色的绘制。\n* 帧缓冲，输出着色后的图形。\n\n### 顶点处理 && 三角形处理\n![](/images/graphics7/graphics7_vertex.jpg)\n顶点处理过程实际上就是对所有顶点进行Modal、view、projection的转换，将3D的顶点信息投影到2D的屏幕上来。这一部分在本系列笔记的第2、3 部分有着较为详细的讨论。另外，顶点处理还有一个比较重要的作用就是确定像素深度，为后续着色过程中ZBuffer提供深度z值。\n\n三角形处理相对就简单很多，只需要将处理好的顶点数据分割为三角形。对于三角形而言，是几何中最简单的多边形，因此分割为三角形而非其他多边形能有效地提高分割以及渲染的性能。（当然存在一些渲染引擎以四边形作为基础的渲染多边形，以简化建模过程。）\n\n### 光栅化\n当分割为合适的三角形之后，就需要用到我们在本系列笔记的第4部分中提到的光栅化过程。逐个对每个三角形中的每个像素进行采样，判断像素是否在三角形内。而且在光栅化这一步同时涉及到我们在系列笔记第5部分提到的走样的原理以及反走样原理和抗锯齿的过程。\n![](/images/graphics7/graphics7_rasterization.jpg)\n\n### 着色\n渲染管线流程中的着色，是通过着色器（shader）实现的。shader其实就是专门用来渲染图形的一种技术，通过shader，我们可以自定义GPU渲染画面的算法，使画面达到我们想要的效果。一般来说shader分为两类：\n1. 顶点着色器（vertext shader），它的作用主要是处理顶点数据，生成裁剪空间坐标值。\n2. 片段着色曲(fragment shader)，它的作用是主要用来处理三角形内每个像素的颜色值。\n\n![](/images/graphics7/graphics7_shading.jpg)\n当着色器接收到完成光栅化后的片段时，需要对其进行着色处理。在系列笔记的第6部分我们提到了着色的过程，这一过程涉及到渲染管线中的顶点处理和片段处理。顶点着色器运行在顶点处理中。在顶点处理时就可以直接对顶点的值进行计算，比如说Gouraud Shading和phong shading，它们都会涉及到顶点颜色的处理。而片段着色器主要是用来处理图元或者说片段信息，也就是被拆分后的一个个三角形面中的像素。比如说plat shading会直接对一个片段使用同一种颜色进行着色。或者是Gouraud中通过差值的方式，对片段进行着色。\n\n![](/images/graphics7/graphics7_zbuffer.jpg)\n当然，着色的过程始终是在2D平面中进行的，像素也就存在着遮挡问题。这个时候通过ZBuffer缓存，对像素深度信息进行缓存，从而确定，哪些像素点应该显示在屏幕上，哪些点被遮挡了不应该显示。\n\n\n## 总结\n本章主要是对于可编程渲染管线的每个步骤的总结，其内容在前面笔记中都有详细的描述。可编程渲染管线是过去20年中图形学工业腾飞的基石，程序员可以有效的控制渲染过程，编程来代替原来固定的顶点处理和片元处理从而达到各种各样令人惊叹的效果。","slug":"ComputerGraphics7","published":1,"updated":"2021-03-19T06:21:43.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wai000tnwqc8w9bbepd","content":"<h2 id=\"渲染管线\"><a href=\"#渲染管线\" class=\"headerlink\" title=\"渲染管线\"></a>渲染管线</h2><p>渲染管线是实时渲染的重要工具，实时渲染离不开渲染管线。图形渲染管线主要包括两个功能：一是将物体3D坐标转变为屏幕空间2D坐标，二是为屏幕每个像素点进行着色。渲染管线的一般流程如下图所示。分别是：顶点数据的输入、顶点着色器、曲面细分过程、几何着色器、图元组装、裁剪剔除、光栅化、片段着色器以及混合测试。渲染管线流程实际上就是对前文中介绍的各项技术的一个总结。其大致流程如下图：<br><img src=\"/images/graphics7/graphics7_banner.png\" alt=\"\"></p>\n<ul>\n<li>顶点处理，即将在3D场景的顶点数据转换为2D屏幕的坐标数据（MVP过程）。</li>\n<li>三角形处理，即将顶点分割为屏幕中的渲染三角形。</li>\n<li>光栅化，也就是采样过程，确定三角形覆盖的像素。</li>\n<li>着色，主要通过着色器对像素进行颜色的绘制。</li>\n<li>帧缓冲，输出着色后的图形。</li>\n</ul>\n<h3 id=\"顶点处理-amp-amp-三角形处理\"><a href=\"#顶点处理-amp-amp-三角形处理\" class=\"headerlink\" title=\"顶点处理 &amp;&amp; 三角形处理\"></a>顶点处理 &amp;&amp; 三角形处理</h3><p><img src=\"/images/graphics7/graphics7_vertex.jpg\" alt=\"\"><br>顶点处理过程实际上就是对所有顶点进行Modal、view、projection的转换，将3D的顶点信息投影到2D的屏幕上来。这一部分在本系列笔记的第2、3 部分有着较为详细的讨论。另外，顶点处理还有一个比较重要的作用就是确定像素深度，为后续着色过程中ZBuffer提供深度z值。</p>\n<p>三角形处理相对就简单很多，只需要将处理好的顶点数据分割为三角形。对于三角形而言，是几何中最简单的多边形，因此分割为三角形而非其他多边形能有效地提高分割以及渲染的性能。（当然存在一些渲染引擎以四边形作为基础的渲染多边形，以简化建模过程。）</p>\n<h3 id=\"光栅化\"><a href=\"#光栅化\" class=\"headerlink\" title=\"光栅化\"></a>光栅化</h3><p>当分割为合适的三角形之后，就需要用到我们在本系列笔记的第4部分中提到的光栅化过程。逐个对每个三角形中的每个像素进行采样，判断像素是否在三角形内。而且在光栅化这一步同时涉及到我们在系列笔记第5部分提到的走样的原理以及反走样原理和抗锯齿的过程。<br><img src=\"/images/graphics7/graphics7_rasterization.jpg\" alt=\"\"></p>\n<h3 id=\"着色\"><a href=\"#着色\" class=\"headerlink\" title=\"着色\"></a>着色</h3><p>渲染管线流程中的着色，是通过着色器（shader）实现的。shader其实就是专门用来渲染图形的一种技术，通过shader，我们可以自定义GPU渲染画面的算法，使画面达到我们想要的效果。一般来说shader分为两类：</p>\n<ol>\n<li>顶点着色器（vertext shader），它的作用主要是处理顶点数据，生成裁剪空间坐标值。</li>\n<li>片段着色曲(fragment shader)，它的作用是主要用来处理三角形内每个像素的颜色值。</li>\n</ol>\n<p><img src=\"/images/graphics7/graphics7_shading.jpg\" alt=\"\"><br>当着色器接收到完成光栅化后的片段时，需要对其进行着色处理。在系列笔记的第6部分我们提到了着色的过程，这一过程涉及到渲染管线中的顶点处理和片段处理。顶点着色器运行在顶点处理中。在顶点处理时就可以直接对顶点的值进行计算，比如说Gouraud Shading和phong shading，它们都会涉及到顶点颜色的处理。而片段着色器主要是用来处理图元或者说片段信息，也就是被拆分后的一个个三角形面中的像素。比如说plat shading会直接对一个片段使用同一种颜色进行着色。或者是Gouraud中通过差值的方式，对片段进行着色。</p>\n<p><img src=\"/images/graphics7/graphics7_zbuffer.jpg\" alt=\"\"><br>当然，着色的过程始终是在2D平面中进行的，像素也就存在着遮挡问题。这个时候通过ZBuffer缓存，对像素深度信息进行缓存，从而确定，哪些像素点应该显示在屏幕上，哪些点被遮挡了不应该显示。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本章主要是对于可编程渲染管线的每个步骤的总结，其内容在前面笔记中都有详细的描述。可编程渲染管线是过去20年中图形学工业腾飞的基石，程序员可以有效的控制渲染过程，编程来代替原来固定的顶点处理和片元处理从而达到各种各样令人惊叹的效果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"渲染管线\"><a href=\"#渲染管线\" class=\"headerlink\" title=\"渲染管线\"></a>渲染管线</h2><p>渲染管线是实时渲染的重要工具，实时渲染离不开渲染管线。图形渲染管线主要包括两个功能：一是将物体3D坐标转变为屏幕空间2D坐标，二是为屏幕每个像素点进行着色。渲染管线的一般流程如下图所示。分别是：顶点数据的输入、顶点着色器、曲面细分过程、几何着色器、图元组装、裁剪剔除、光栅化、片段着色器以及混合测试。渲染管线流程实际上就是对前文中介绍的各项技术的一个总结。其大致流程如下图：<br><img src=\"/images/graphics7/graphics7_banner.png\" alt=\"\"></p>\n<ul>\n<li>顶点处理，即将在3D场景的顶点数据转换为2D屏幕的坐标数据（MVP过程）。</li>\n<li>三角形处理，即将顶点分割为屏幕中的渲染三角形。</li>\n<li>光栅化，也就是采样过程，确定三角形覆盖的像素。</li>\n<li>着色，主要通过着色器对像素进行颜色的绘制。</li>\n<li>帧缓冲，输出着色后的图形。</li>\n</ul>\n<h3 id=\"顶点处理-amp-amp-三角形处理\"><a href=\"#顶点处理-amp-amp-三角形处理\" class=\"headerlink\" title=\"顶点处理 &amp;&amp; 三角形处理\"></a>顶点处理 &amp;&amp; 三角形处理</h3><p><img src=\"/images/graphics7/graphics7_vertex.jpg\" alt=\"\"><br>顶点处理过程实际上就是对所有顶点进行Modal、view、projection的转换，将3D的顶点信息投影到2D的屏幕上来。这一部分在本系列笔记的第2、3 部分有着较为详细的讨论。另外，顶点处理还有一个比较重要的作用就是确定像素深度，为后续着色过程中ZBuffer提供深度z值。</p>\n<p>三角形处理相对就简单很多，只需要将处理好的顶点数据分割为三角形。对于三角形而言，是几何中最简单的多边形，因此分割为三角形而非其他多边形能有效地提高分割以及渲染的性能。（当然存在一些渲染引擎以四边形作为基础的渲染多边形，以简化建模过程。）</p>\n<h3 id=\"光栅化\"><a href=\"#光栅化\" class=\"headerlink\" title=\"光栅化\"></a>光栅化</h3><p>当分割为合适的三角形之后，就需要用到我们在本系列笔记的第4部分中提到的光栅化过程。逐个对每个三角形中的每个像素进行采样，判断像素是否在三角形内。而且在光栅化这一步同时涉及到我们在系列笔记第5部分提到的走样的原理以及反走样原理和抗锯齿的过程。<br><img src=\"/images/graphics7/graphics7_rasterization.jpg\" alt=\"\"></p>\n<h3 id=\"着色\"><a href=\"#着色\" class=\"headerlink\" title=\"着色\"></a>着色</h3><p>渲染管线流程中的着色，是通过着色器（shader）实现的。shader其实就是专门用来渲染图形的一种技术，通过shader，我们可以自定义GPU渲染画面的算法，使画面达到我们想要的效果。一般来说shader分为两类：</p>\n<ol>\n<li>顶点着色器（vertext shader），它的作用主要是处理顶点数据，生成裁剪空间坐标值。</li>\n<li>片段着色曲(fragment shader)，它的作用是主要用来处理三角形内每个像素的颜色值。</li>\n</ol>\n<p><img src=\"/images/graphics7/graphics7_shading.jpg\" alt=\"\"><br>当着色器接收到完成光栅化后的片段时，需要对其进行着色处理。在系列笔记的第6部分我们提到了着色的过程，这一过程涉及到渲染管线中的顶点处理和片段处理。顶点着色器运行在顶点处理中。在顶点处理时就可以直接对顶点的值进行计算，比如说Gouraud Shading和phong shading，它们都会涉及到顶点颜色的处理。而片段着色器主要是用来处理图元或者说片段信息，也就是被拆分后的一个个三角形面中的像素。比如说plat shading会直接对一个片段使用同一种颜色进行着色。或者是Gouraud中通过差值的方式，对片段进行着色。</p>\n<p><img src=\"/images/graphics7/graphics7_zbuffer.jpg\" alt=\"\"><br>当然，着色的过程始终是在2D平面中进行的，像素也就存在着遮挡问题。这个时候通过ZBuffer缓存，对像素深度信息进行缓存，从而确定，哪些像素点应该显示在屏幕上，哪些点被遮挡了不应该显示。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本章主要是对于可编程渲染管线的每个步骤的总结，其内容在前面笔记中都有详细的描述。可编程渲染管线是过去20年中图形学工业腾飞的基石，程序员可以有效的控制渲染过程，编程来代替原来固定的顶点处理和片元处理从而达到各种各样令人惊叹的效果。</p>\n"},{"title":"计算机图形学9 - 几何介绍","index_img":"/images/graphics7/graphics7_banner.png","date":"2020-10-03T09:09:11.000Z","math":true,"_content":" ","source":"_posts/ComputerGraphics9.md","raw":"---\ntitle: 计算机图形学9 - 几何介绍\ntags: [计算机图形学, 几何, 隐式曲面, 显式曲面]\ncategories: [GAMES101]\nindex_img: /images/graphics7/graphics7_banner.png\ndate: 2020-10-03 17:09:11\nmath: true\n---\n ","slug":"ComputerGraphics9","published":1,"updated":"2020-10-24T08:11:03.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1waj000vnwqc5a65f014","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"计算机图形学8 ——  纹理映射和Mipmap","index_img":"/images/graphics8/graphics8_banner.jpeg","date":"2020-10-03T09:09:11.000Z","math":true,"_content":"## 纹理映射\n\n### 基础概念\n\n    纹理映射（Texture Mapping），又称纹理贴图，是将纹理空间中的纹理像素映射到屏幕空间中的像素的过程。\n    简单来说，就是把一幅图像贴到三维物体的表面上来增强真实感，可以和光照计算、图像混合等技术结合起来形成许多非常漂亮的效果。\n    via 100°C百科\n\n首先我们观察下皮克斯的顽皮跳跳灯这个场景：\n![](/images/graphics8/texture_mapping_lamp.png)\n灯下玩具球的图案和桌子上木板纹路图案都是完全不同的。除此之外，球表面由于灯的照射效果呈现出了高光的样式，在部分区域反射了灯的光线。而在桌子上的木板却呈现着均匀的光线效果，没有很强的高光样式。在之前讲解 Blinn-Phong 反射模型的时候曾提到，一个点的颜色是由其漫反射系数决定的，反射什么颜色的光，人眼就能看见什么颜色。**纹理映射**的作用就是定义一组具有相同反射特性且颜色已经定义好的颜色图案，将其应用在已经构建好的模型之上。\n\n### 如何实现纹理映射\n那么纹理映射要怎么做呢？我们先看看，如何将三维的物体映射到二维的平面上。\n![](/images/graphics8/earth_mapping.png)\n上图的例子是一个地球仪，地球仪的模型是一个球，表面纹理即为世界地图的平面展开的图像。倘若拥有从3维 world space 到2维 Texture space 的一个映射关系，那么只需要将每个点的颜色信息即漫反射系数存储在2维的 Texture 之上，每次利用光照模型进行计算的时候根据映射关系就能查到这个点的漫反射系数是多少，所有点计算完之后，结果就像最左边的 screen space 之中，整个 Texture 被贴在了模型之上。\n\n纹理映射让造型技术变得简单很多，对于模型表面很多细节都可以通过纹理映射的方式让其映射到 Texture 上来。比如下面这个例子：\n![](/images/graphics8/monster.png)\n对于模型上的每个三角形可以映射到纹理中的每个三角形上，形成一一对应的关系，然后纹理上作出修改即可影响模型最终的渲染的颜色值。这个过程只需要在空间坐标中存储纹理坐标的值即可实现对应关系。即空间坐标$（x, y, z）$会存储纹理坐标$（u, v）$的值，从而实现纹理映射。如下图:\n![](/images/graphics8/monster_uv.png)\n\n这一过程可以用伪代码进行表示：\n![](/images/graphics8/texture_code.png)\n即纹理映射过程有以下三个步骤：\n1. 对每个光栅化的像素坐标（往往是像素中心点）进行采样\n2. 利用重心坐标的方式对这个点进行插值计算计算出其uv坐标\n3. 然后使用uv坐标上定义的值作为漫反射系数 $K_d$ 使用 Blinn-Phong 反射模型进行颜色取值。\n\n### 纹理过小的情况\n纹理过小的问题相对容易理解，想想我们把一张100x100的纹理贴图应用在一500x500的屏幕之上必然会导致走样失真，因为屏幕空间的几个像素点对应在纹理贴图的坐标上都是集中在一个像素大小之内。那么如果仅仅是使用对应(u,v)坐标在texture贴图下最近的那个像素点，往往会造成严重的走样。\n![](/images/graphics8/tiny_texture.png)\n如上图所示，红色点为uv坐标对应的空间坐标点，黑色的为实际的空间坐标点。一个uv坐标点无法与模型的空间坐标点进行对应，如果简单的进行坐标取整将其映射到最近的一个坐标上会导致出现严重的走样效果。这里可以用双线性插值的方法来解决这个问题。\n\n### 双线性插值\n进行双线性插值的前提条件是已知uv坐标对应的空间点的位置坐标 $（x, y）$，利用临近四个点的坐标值可以求出其对应相邻像素的偏移量$s、t$，如下图所示：\n![](/images/graphics8/bilinear1.png)\n\n利用偏移量和临近点的坐标，通过线性插值的思路可以快速求出其在竖直方向的值$u_0、u_1$，如下图所示\n![](/images/graphics8/bilinear2.png)\n\n同理再次利用竖直方向的线性插值法可以求出对应点的颜色值。\n\n双线性插值的方法对于纹理过小的情况处理速度和处理效果都非常好，下图是处理后的对比效果：\n![](/images/graphics8/bilinear3.png)\n\n注：图中 Bicubic 方法是一种双三次插值的方法，函数 f 在点 (x, y) 的值可以通过矩形网格中最近的十六个采样点的加权平均得到，在这里需要使用两个多项式插值三次函数，每个方向使用一个。这种方法的效果要好于双线性插值，但是计算过程比较复杂。\n\n\n### 纹理过大的情况（较难处理）\n按照常理考虑，纹理应该是越大越好，因为纹理越大对应的到每个像素的细节就会越多，图像应该是更清晰的。但是实际结果却**并非如此**，将过大的纹理映射到一个较小的模型上的效果如下图所示：\n![](/images/graphics8/huge_texture.png)\n\n实际效果却是近处锯齿，远处摩尔纹，很反直觉地出现了严重的走样效果。经过前面反走样部分的内容可以知道，出现这样现象的愿意在于欠采样。结合这个例子我们可以这样理解：\n1. 假定一种纹理过大的情况，在极限情况纹理非常大，然后屏幕像素非常少（只有几个）。\n2. 我们需要用仅有的几个像素表示这么多的纹理信息。\n3. 则屏幕坐标映射到纹理坐标上的时候，一个屏幕坐标对应了若干个纹理坐标。\n4. 在这种情况下无法正确地进行采样确定屏幕坐标的颜色，所以造成了走样的现象。\n![](/images/graphics8/footprint.png)\n\n这种现象被形象的成为屏幕像素在texture空间的footprint。如上图所示一个屏幕空间的蓝色像素点离相机越远，对应在texture空间的范围也就越大。其实也就是越来越欠采样，那么一种直观的解决方法就是Supersampling，如果一个像素点不足以代表一个区域的颜色信息，那么便把一个像素细分为更多个小的采样点不就可以解决这个问题了吗？对，确实是这样，可以看看如下图512x超采样的结果:\n![](/images/graphics8/ssaa.png)\n\n但是如此效果的代价也是非常大的，计算量太大了，一个像素点被分为了512x512个采样点，计算量为原来的25万倍之多。而且这也不能从根本上解决问题，因为理论上计算量会随着纹理超过实际屏幕像素的大小而发生变化。\n## Mipmap\n\n### 基础定义\n既然纹理尺寸过大，那么我们缩小纹理尺寸理论上就可以解决这个问题。正如上文所提，一个采样点的颜色信息不足以代表  footprint 里一个区域的颜色信息，如果可以求出这样一个区域里面所有颜色的均值。\n但是纹理尺寸缩小多少也是一个很难解决的问题，因为在实际使用中模型和屏幕尺寸的大小都不确定。此外在一般的三维场景中由于透视关系的存在，纹理的footprint可能会随着物体距离相机的距离而发生变化。\n\n![](/images/graphics8/projection.png)\n如上图所示，近处的采样的footprint显然会比远处的小很多。因此纹理应该支持多个级别的查询。Mipmap就是这种优化纹理使用的技术，它可以一定程度上解决纹理尺寸过大的问题。\n\n![](/images/graphics8/mipmap.png)\n\n如上图所示level 0代表的是原始texture，也是精度最高的原始纹理，随着level的提升，每提升一级将4个相邻像素点求均值合为一个像素点，因此越高的level也就代表了更大的footprint的区域查询。接下来要做的就是根据屏幕像素的footprint大小选定不同level的texture，再进行点查询即可，而这其实就相当于在原始texture上进行了区域查询。\n\n### level的取值问题\n得到了 mipmap 之后如何选取代表精度 level 的 D 值呢？ 这里可以利用屏幕像素点来估算footprint的大小再确定D值，如下图：\n![](/images/graphics8/levelD.png)\n在屏幕空间中取当前像素点的右方和上方的两个相邻像素点(4个全取也可以)，分别查询得到这3个点对应在Texture space的坐标，计算出当前像素点与右方像素点和上方像素点在 Texture space 的距离，二者取最大值，计算公式如图中所示，那么level D 就是这个距离的 log2 值 (D = log2L) ! 这不难理解，读者可以具体取几个例子比如 L = 1，L = 2，L = 4，看看是否符合这样的计算即可。\n\n但是这里D值算出来是一个连续值，并不是一个整数，有两种对应的方法：\n\n1 四舍五入取得最近的那个 level D\n\n2 利用 D 值在向下和向上取整的两个不同level进行三线性插值\n\n![](/images/graphics8/integerD.png)\n\n上图是四舍五入求得的D的分布值，可以看到过度效果不好，很多区域过度效果很硬，实际展示效果也不佳。\n\n三线性插值是一个很好的解决上述问题的方法：\n![](/images/graphics8/trilinear.png)\n\n如上图所示，主要思路就是基于计算出的 D 的下取整值，在level D平面和 level D+1 平面上分别进行一次双线性插值计算出采样点的值，然后再基于两个平面的比例进行一次线性插值，从而完成一次三线性插值。\n![](/images/graphics8/trilinearD.png)\n\n上图是三线性插值后的D的分布情况，相较于四舍五入要好非常多，过度效果很平滑。\n\n### 问题\nmipmap虽然能有效地解决颜色查询的问题，但是应用在我们这个例子上却出现了以下结果：\n![](/images/graphics8/mipmap_limitations.png)\n在近处展示尚可，但是在远处几乎糊成一片了，这里可以使用各向异性过滤来解决这个问题\n### 各向异性过滤mipmap\n为什么在上面的例子中，使用mipmap来处理纹理会出现这样的问题呢？其根本原因就是在mipmap中所采用的不同level的Mipmap默认的都是正方形区域的Range Query，然而真实情况并不是如此，见下图:\n![](/images/graphics8/screen_to_texture.png)\n可以清楚地看到 screen space 的像素点所对应的footprint是不同的，有长方形，甚至是不规则图形。这是因为实际场景中的透视投影的效果造成的，在实际场景渲染中会经常出现这种问题。那么针对这种情况，有的所需要的是仅仅是水平方向的高level，有的需要的仅仅是竖直方向上的高level，因此这也就启发了各向异性的过滤:\n![](/images/graphics8/anisotropic.png)\n各向异性过滤是让纹理分别在水平和竖直方向上做不同级别的像素融合，可以让不同形状的footprint映射到准确的纹理形状上。使用各向异性的效果如下，相较于简单的mipmap好了非常多！\n![](/images/graphics8/filter_better.png)","source":"_posts/ComputerGraphics8.md","raw":"---\ntitle: 计算机图形学8 ——  纹理映射和Mipmap\ntags: [计算机图形学, 纹理映射, Mipmap]\ncategories: [GAMES101]\nindex_img: /images/graphics8/graphics8_banner.jpeg\ndate: 2020-10-03 17:09:11\nmath: true\n---\n## 纹理映射\n\n### 基础概念\n\n    纹理映射（Texture Mapping），又称纹理贴图，是将纹理空间中的纹理像素映射到屏幕空间中的像素的过程。\n    简单来说，就是把一幅图像贴到三维物体的表面上来增强真实感，可以和光照计算、图像混合等技术结合起来形成许多非常漂亮的效果。\n    via 100°C百科\n\n首先我们观察下皮克斯的顽皮跳跳灯这个场景：\n![](/images/graphics8/texture_mapping_lamp.png)\n灯下玩具球的图案和桌子上木板纹路图案都是完全不同的。除此之外，球表面由于灯的照射效果呈现出了高光的样式，在部分区域反射了灯的光线。而在桌子上的木板却呈现着均匀的光线效果，没有很强的高光样式。在之前讲解 Blinn-Phong 反射模型的时候曾提到，一个点的颜色是由其漫反射系数决定的，反射什么颜色的光，人眼就能看见什么颜色。**纹理映射**的作用就是定义一组具有相同反射特性且颜色已经定义好的颜色图案，将其应用在已经构建好的模型之上。\n\n### 如何实现纹理映射\n那么纹理映射要怎么做呢？我们先看看，如何将三维的物体映射到二维的平面上。\n![](/images/graphics8/earth_mapping.png)\n上图的例子是一个地球仪，地球仪的模型是一个球，表面纹理即为世界地图的平面展开的图像。倘若拥有从3维 world space 到2维 Texture space 的一个映射关系，那么只需要将每个点的颜色信息即漫反射系数存储在2维的 Texture 之上，每次利用光照模型进行计算的时候根据映射关系就能查到这个点的漫反射系数是多少，所有点计算完之后，结果就像最左边的 screen space 之中，整个 Texture 被贴在了模型之上。\n\n纹理映射让造型技术变得简单很多，对于模型表面很多细节都可以通过纹理映射的方式让其映射到 Texture 上来。比如下面这个例子：\n![](/images/graphics8/monster.png)\n对于模型上的每个三角形可以映射到纹理中的每个三角形上，形成一一对应的关系，然后纹理上作出修改即可影响模型最终的渲染的颜色值。这个过程只需要在空间坐标中存储纹理坐标的值即可实现对应关系。即空间坐标$（x, y, z）$会存储纹理坐标$（u, v）$的值，从而实现纹理映射。如下图:\n![](/images/graphics8/monster_uv.png)\n\n这一过程可以用伪代码进行表示：\n![](/images/graphics8/texture_code.png)\n即纹理映射过程有以下三个步骤：\n1. 对每个光栅化的像素坐标（往往是像素中心点）进行采样\n2. 利用重心坐标的方式对这个点进行插值计算计算出其uv坐标\n3. 然后使用uv坐标上定义的值作为漫反射系数 $K_d$ 使用 Blinn-Phong 反射模型进行颜色取值。\n\n### 纹理过小的情况\n纹理过小的问题相对容易理解，想想我们把一张100x100的纹理贴图应用在一500x500的屏幕之上必然会导致走样失真，因为屏幕空间的几个像素点对应在纹理贴图的坐标上都是集中在一个像素大小之内。那么如果仅仅是使用对应(u,v)坐标在texture贴图下最近的那个像素点，往往会造成严重的走样。\n![](/images/graphics8/tiny_texture.png)\n如上图所示，红色点为uv坐标对应的空间坐标点，黑色的为实际的空间坐标点。一个uv坐标点无法与模型的空间坐标点进行对应，如果简单的进行坐标取整将其映射到最近的一个坐标上会导致出现严重的走样效果。这里可以用双线性插值的方法来解决这个问题。\n\n### 双线性插值\n进行双线性插值的前提条件是已知uv坐标对应的空间点的位置坐标 $（x, y）$，利用临近四个点的坐标值可以求出其对应相邻像素的偏移量$s、t$，如下图所示：\n![](/images/graphics8/bilinear1.png)\n\n利用偏移量和临近点的坐标，通过线性插值的思路可以快速求出其在竖直方向的值$u_0、u_1$，如下图所示\n![](/images/graphics8/bilinear2.png)\n\n同理再次利用竖直方向的线性插值法可以求出对应点的颜色值。\n\n双线性插值的方法对于纹理过小的情况处理速度和处理效果都非常好，下图是处理后的对比效果：\n![](/images/graphics8/bilinear3.png)\n\n注：图中 Bicubic 方法是一种双三次插值的方法，函数 f 在点 (x, y) 的值可以通过矩形网格中最近的十六个采样点的加权平均得到，在这里需要使用两个多项式插值三次函数，每个方向使用一个。这种方法的效果要好于双线性插值，但是计算过程比较复杂。\n\n\n### 纹理过大的情况（较难处理）\n按照常理考虑，纹理应该是越大越好，因为纹理越大对应的到每个像素的细节就会越多，图像应该是更清晰的。但是实际结果却**并非如此**，将过大的纹理映射到一个较小的模型上的效果如下图所示：\n![](/images/graphics8/huge_texture.png)\n\n实际效果却是近处锯齿，远处摩尔纹，很反直觉地出现了严重的走样效果。经过前面反走样部分的内容可以知道，出现这样现象的愿意在于欠采样。结合这个例子我们可以这样理解：\n1. 假定一种纹理过大的情况，在极限情况纹理非常大，然后屏幕像素非常少（只有几个）。\n2. 我们需要用仅有的几个像素表示这么多的纹理信息。\n3. 则屏幕坐标映射到纹理坐标上的时候，一个屏幕坐标对应了若干个纹理坐标。\n4. 在这种情况下无法正确地进行采样确定屏幕坐标的颜色，所以造成了走样的现象。\n![](/images/graphics8/footprint.png)\n\n这种现象被形象的成为屏幕像素在texture空间的footprint。如上图所示一个屏幕空间的蓝色像素点离相机越远，对应在texture空间的范围也就越大。其实也就是越来越欠采样，那么一种直观的解决方法就是Supersampling，如果一个像素点不足以代表一个区域的颜色信息，那么便把一个像素细分为更多个小的采样点不就可以解决这个问题了吗？对，确实是这样，可以看看如下图512x超采样的结果:\n![](/images/graphics8/ssaa.png)\n\n但是如此效果的代价也是非常大的，计算量太大了，一个像素点被分为了512x512个采样点，计算量为原来的25万倍之多。而且这也不能从根本上解决问题，因为理论上计算量会随着纹理超过实际屏幕像素的大小而发生变化。\n## Mipmap\n\n### 基础定义\n既然纹理尺寸过大，那么我们缩小纹理尺寸理论上就可以解决这个问题。正如上文所提，一个采样点的颜色信息不足以代表  footprint 里一个区域的颜色信息，如果可以求出这样一个区域里面所有颜色的均值。\n但是纹理尺寸缩小多少也是一个很难解决的问题，因为在实际使用中模型和屏幕尺寸的大小都不确定。此外在一般的三维场景中由于透视关系的存在，纹理的footprint可能会随着物体距离相机的距离而发生变化。\n\n![](/images/graphics8/projection.png)\n如上图所示，近处的采样的footprint显然会比远处的小很多。因此纹理应该支持多个级别的查询。Mipmap就是这种优化纹理使用的技术，它可以一定程度上解决纹理尺寸过大的问题。\n\n![](/images/graphics8/mipmap.png)\n\n如上图所示level 0代表的是原始texture，也是精度最高的原始纹理，随着level的提升，每提升一级将4个相邻像素点求均值合为一个像素点，因此越高的level也就代表了更大的footprint的区域查询。接下来要做的就是根据屏幕像素的footprint大小选定不同level的texture，再进行点查询即可，而这其实就相当于在原始texture上进行了区域查询。\n\n### level的取值问题\n得到了 mipmap 之后如何选取代表精度 level 的 D 值呢？ 这里可以利用屏幕像素点来估算footprint的大小再确定D值，如下图：\n![](/images/graphics8/levelD.png)\n在屏幕空间中取当前像素点的右方和上方的两个相邻像素点(4个全取也可以)，分别查询得到这3个点对应在Texture space的坐标，计算出当前像素点与右方像素点和上方像素点在 Texture space 的距离，二者取最大值，计算公式如图中所示，那么level D 就是这个距离的 log2 值 (D = log2L) ! 这不难理解，读者可以具体取几个例子比如 L = 1，L = 2，L = 4，看看是否符合这样的计算即可。\n\n但是这里D值算出来是一个连续值，并不是一个整数，有两种对应的方法：\n\n1 四舍五入取得最近的那个 level D\n\n2 利用 D 值在向下和向上取整的两个不同level进行三线性插值\n\n![](/images/graphics8/integerD.png)\n\n上图是四舍五入求得的D的分布值，可以看到过度效果不好，很多区域过度效果很硬，实际展示效果也不佳。\n\n三线性插值是一个很好的解决上述问题的方法：\n![](/images/graphics8/trilinear.png)\n\n如上图所示，主要思路就是基于计算出的 D 的下取整值，在level D平面和 level D+1 平面上分别进行一次双线性插值计算出采样点的值，然后再基于两个平面的比例进行一次线性插值，从而完成一次三线性插值。\n![](/images/graphics8/trilinearD.png)\n\n上图是三线性插值后的D的分布情况，相较于四舍五入要好非常多，过度效果很平滑。\n\n### 问题\nmipmap虽然能有效地解决颜色查询的问题，但是应用在我们这个例子上却出现了以下结果：\n![](/images/graphics8/mipmap_limitations.png)\n在近处展示尚可，但是在远处几乎糊成一片了，这里可以使用各向异性过滤来解决这个问题\n### 各向异性过滤mipmap\n为什么在上面的例子中，使用mipmap来处理纹理会出现这样的问题呢？其根本原因就是在mipmap中所采用的不同level的Mipmap默认的都是正方形区域的Range Query，然而真实情况并不是如此，见下图:\n![](/images/graphics8/screen_to_texture.png)\n可以清楚地看到 screen space 的像素点所对应的footprint是不同的，有长方形，甚至是不规则图形。这是因为实际场景中的透视投影的效果造成的，在实际场景渲染中会经常出现这种问题。那么针对这种情况，有的所需要的是仅仅是水平方向的高level，有的需要的仅仅是竖直方向上的高level，因此这也就启发了各向异性的过滤:\n![](/images/graphics8/anisotropic.png)\n各向异性过滤是让纹理分别在水平和竖直方向上做不同级别的像素融合，可以让不同形状的footprint映射到准确的纹理形状上。使用各向异性的效果如下，相较于简单的mipmap好了非常多！\n![](/images/graphics8/filter_better.png)","slug":"ComputerGraphics8","published":1,"updated":"2021-03-23T10:13:29.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wak000ynwqccwoa2tjr","content":"<h2 id=\"纹理映射\"><a href=\"#纹理映射\" class=\"headerlink\" title=\"纹理映射\"></a>纹理映射</h2><h3 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h3><pre><code>纹理映射（Texture Mapping），又称纹理贴图，是将纹理空间中的纹理像素映射到屏幕空间中的像素的过程。\n简单来说，就是把一幅图像贴到三维物体的表面上来增强真实感，可以和光照计算、图像混合等技术结合起来形成许多非常漂亮的效果。\nvia 100°C百科\n</code></pre><p>首先我们观察下皮克斯的顽皮跳跳灯这个场景：<br><img src=\"/images/graphics8/texture_mapping_lamp.png\" alt=\"\"><br>灯下玩具球的图案和桌子上木板纹路图案都是完全不同的。除此之外，球表面由于灯的照射效果呈现出了高光的样式，在部分区域反射了灯的光线。而在桌子上的木板却呈现着均匀的光线效果，没有很强的高光样式。在之前讲解 Blinn-Phong 反射模型的时候曾提到，一个点的颜色是由其漫反射系数决定的，反射什么颜色的光，人眼就能看见什么颜色。<strong>纹理映射</strong>的作用就是定义一组具有相同反射特性且颜色已经定义好的颜色图案，将其应用在已经构建好的模型之上。</p>\n<h3 id=\"如何实现纹理映射\"><a href=\"#如何实现纹理映射\" class=\"headerlink\" title=\"如何实现纹理映射\"></a>如何实现纹理映射</h3><p>那么纹理映射要怎么做呢？我们先看看，如何将三维的物体映射到二维的平面上。<br><img src=\"/images/graphics8/earth_mapping.png\" alt=\"\"><br>上图的例子是一个地球仪，地球仪的模型是一个球，表面纹理即为世界地图的平面展开的图像。倘若拥有从3维 world space 到2维 Texture space 的一个映射关系，那么只需要将每个点的颜色信息即漫反射系数存储在2维的 Texture 之上，每次利用光照模型进行计算的时候根据映射关系就能查到这个点的漫反射系数是多少，所有点计算完之后，结果就像最左边的 screen space 之中，整个 Texture 被贴在了模型之上。</p>\n<p>纹理映射让造型技术变得简单很多，对于模型表面很多细节都可以通过纹理映射的方式让其映射到 Texture 上来。比如下面这个例子：<br><img src=\"/images/graphics8/monster.png\" alt=\"\"><br>对于模型上的每个三角形可以映射到纹理中的每个三角形上，形成一一对应的关系，然后纹理上作出修改即可影响模型最终的渲染的颜色值。这个过程只需要在空间坐标中存储纹理坐标的值即可实现对应关系。即空间坐标$（x, y, z）$会存储纹理坐标$（u, v）$的值，从而实现纹理映射。如下图:<br><img src=\"/images/graphics8/monster_uv.png\" alt=\"\"></p>\n<p>这一过程可以用伪代码进行表示：<br><img src=\"/images/graphics8/texture_code.png\" alt=\"\"><br>即纹理映射过程有以下三个步骤：</p>\n<ol>\n<li>对每个光栅化的像素坐标（往往是像素中心点）进行采样</li>\n<li>利用重心坐标的方式对这个点进行插值计算计算出其uv坐标</li>\n<li>然后使用uv坐标上定义的值作为漫反射系数 $K_d$ 使用 Blinn-Phong 反射模型进行颜色取值。</li>\n</ol>\n<h3 id=\"纹理过小的情况\"><a href=\"#纹理过小的情况\" class=\"headerlink\" title=\"纹理过小的情况\"></a>纹理过小的情况</h3><p>纹理过小的问题相对容易理解，想想我们把一张100x100的纹理贴图应用在一500x500的屏幕之上必然会导致走样失真，因为屏幕空间的几个像素点对应在纹理贴图的坐标上都是集中在一个像素大小之内。那么如果仅仅是使用对应(u,v)坐标在texture贴图下最近的那个像素点，往往会造成严重的走样。<br><img src=\"/images/graphics8/tiny_texture.png\" alt=\"\"><br>如上图所示，红色点为uv坐标对应的空间坐标点，黑色的为实际的空间坐标点。一个uv坐标点无法与模型的空间坐标点进行对应，如果简单的进行坐标取整将其映射到最近的一个坐标上会导致出现严重的走样效果。这里可以用双线性插值的方法来解决这个问题。</p>\n<h3 id=\"双线性插值\"><a href=\"#双线性插值\" class=\"headerlink\" title=\"双线性插值\"></a>双线性插值</h3><p>进行双线性插值的前提条件是已知uv坐标对应的空间点的位置坐标 $（x, y）$，利用临近四个点的坐标值可以求出其对应相邻像素的偏移量$s、t$，如下图所示：<br><img src=\"/images/graphics8/bilinear1.png\" alt=\"\"></p>\n<p>利用偏移量和临近点的坐标，通过线性插值的思路可以快速求出其在竖直方向的值$u_0、u_1$，如下图所示<br><img src=\"/images/graphics8/bilinear2.png\" alt=\"\"></p>\n<p>同理再次利用竖直方向的线性插值法可以求出对应点的颜色值。</p>\n<p>双线性插值的方法对于纹理过小的情况处理速度和处理效果都非常好，下图是处理后的对比效果：<br><img src=\"/images/graphics8/bilinear3.png\" alt=\"\"></p>\n<p>注：图中 Bicubic 方法是一种双三次插值的方法，函数 f 在点 (x, y) 的值可以通过矩形网格中最近的十六个采样点的加权平均得到，在这里需要使用两个多项式插值三次函数，每个方向使用一个。这种方法的效果要好于双线性插值，但是计算过程比较复杂。</p>\n<h3 id=\"纹理过大的情况（较难处理）\"><a href=\"#纹理过大的情况（较难处理）\" class=\"headerlink\" title=\"纹理过大的情况（较难处理）\"></a>纹理过大的情况（较难处理）</h3><p>按照常理考虑，纹理应该是越大越好，因为纹理越大对应的到每个像素的细节就会越多，图像应该是更清晰的。但是实际结果却<strong>并非如此</strong>，将过大的纹理映射到一个较小的模型上的效果如下图所示：<br><img src=\"/images/graphics8/huge_texture.png\" alt=\"\"></p>\n<p>实际效果却是近处锯齿，远处摩尔纹，很反直觉地出现了严重的走样效果。经过前面反走样部分的内容可以知道，出现这样现象的愿意在于欠采样。结合这个例子我们可以这样理解：</p>\n<ol>\n<li>假定一种纹理过大的情况，在极限情况纹理非常大，然后屏幕像素非常少（只有几个）。</li>\n<li>我们需要用仅有的几个像素表示这么多的纹理信息。</li>\n<li>则屏幕坐标映射到纹理坐标上的时候，一个屏幕坐标对应了若干个纹理坐标。</li>\n<li>在这种情况下无法正确地进行采样确定屏幕坐标的颜色，所以造成了走样的现象。<br><img src=\"/images/graphics8/footprint.png\" alt=\"\"></li>\n</ol>\n<p>这种现象被形象的成为屏幕像素在texture空间的footprint。如上图所示一个屏幕空间的蓝色像素点离相机越远，对应在texture空间的范围也就越大。其实也就是越来越欠采样，那么一种直观的解决方法就是Supersampling，如果一个像素点不足以代表一个区域的颜色信息，那么便把一个像素细分为更多个小的采样点不就可以解决这个问题了吗？对，确实是这样，可以看看如下图512x超采样的结果:<br><img src=\"/images/graphics8/ssaa.png\" alt=\"\"></p>\n<p>但是如此效果的代价也是非常大的，计算量太大了，一个像素点被分为了512x512个采样点，计算量为原来的25万倍之多。而且这也不能从根本上解决问题，因为理论上计算量会随着纹理超过实际屏幕像素的大小而发生变化。</p>\n<h2 id=\"Mipmap\"><a href=\"#Mipmap\" class=\"headerlink\" title=\"Mipmap\"></a>Mipmap</h2><h3 id=\"基础定义\"><a href=\"#基础定义\" class=\"headerlink\" title=\"基础定义\"></a>基础定义</h3><p>既然纹理尺寸过大，那么我们缩小纹理尺寸理论上就可以解决这个问题。正如上文所提，一个采样点的颜色信息不足以代表  footprint 里一个区域的颜色信息，如果可以求出这样一个区域里面所有颜色的均值。<br>但是纹理尺寸缩小多少也是一个很难解决的问题，因为在实际使用中模型和屏幕尺寸的大小都不确定。此外在一般的三维场景中由于透视关系的存在，纹理的footprint可能会随着物体距离相机的距离而发生变化。</p>\n<p><img src=\"/images/graphics8/projection.png\" alt=\"\"><br>如上图所示，近处的采样的footprint显然会比远处的小很多。因此纹理应该支持多个级别的查询。Mipmap就是这种优化纹理使用的技术，它可以一定程度上解决纹理尺寸过大的问题。</p>\n<p><img src=\"/images/graphics8/mipmap.png\" alt=\"\"></p>\n<p>如上图所示level 0代表的是原始texture，也是精度最高的原始纹理，随着level的提升，每提升一级将4个相邻像素点求均值合为一个像素点，因此越高的level也就代表了更大的footprint的区域查询。接下来要做的就是根据屏幕像素的footprint大小选定不同level的texture，再进行点查询即可，而这其实就相当于在原始texture上进行了区域查询。</p>\n<h3 id=\"level的取值问题\"><a href=\"#level的取值问题\" class=\"headerlink\" title=\"level的取值问题\"></a>level的取值问题</h3><p>得到了 mipmap 之后如何选取代表精度 level 的 D 值呢？ 这里可以利用屏幕像素点来估算footprint的大小再确定D值，如下图：<br><img src=\"/images/graphics8/levelD.png\" alt=\"\"><br>在屏幕空间中取当前像素点的右方和上方的两个相邻像素点(4个全取也可以)，分别查询得到这3个点对应在Texture space的坐标，计算出当前像素点与右方像素点和上方像素点在 Texture space 的距离，二者取最大值，计算公式如图中所示，那么level D 就是这个距离的 log2 值 (D = log2L) ! 这不难理解，读者可以具体取几个例子比如 L = 1，L = 2，L = 4，看看是否符合这样的计算即可。</p>\n<p>但是这里D值算出来是一个连续值，并不是一个整数，有两种对应的方法：</p>\n<p>1 四舍五入取得最近的那个 level D</p>\n<p>2 利用 D 值在向下和向上取整的两个不同level进行三线性插值</p>\n<p><img src=\"/images/graphics8/integerD.png\" alt=\"\"></p>\n<p>上图是四舍五入求得的D的分布值，可以看到过度效果不好，很多区域过度效果很硬，实际展示效果也不佳。</p>\n<p>三线性插值是一个很好的解决上述问题的方法：<br><img src=\"/images/graphics8/trilinear.png\" alt=\"\"></p>\n<p>如上图所示，主要思路就是基于计算出的 D 的下取整值，在level D平面和 level D+1 平面上分别进行一次双线性插值计算出采样点的值，然后再基于两个平面的比例进行一次线性插值，从而完成一次三线性插值。<br><img src=\"/images/graphics8/trilinearD.png\" alt=\"\"></p>\n<p>上图是三线性插值后的D的分布情况，相较于四舍五入要好非常多，过度效果很平滑。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>mipmap虽然能有效地解决颜色查询的问题，但是应用在我们这个例子上却出现了以下结果：<br><img src=\"/images/graphics8/mipmap_limitations.png\" alt=\"\"><br>在近处展示尚可，但是在远处几乎糊成一片了，这里可以使用各向异性过滤来解决这个问题</p>\n<h3 id=\"各向异性过滤mipmap\"><a href=\"#各向异性过滤mipmap\" class=\"headerlink\" title=\"各向异性过滤mipmap\"></a>各向异性过滤mipmap</h3><p>为什么在上面的例子中，使用mipmap来处理纹理会出现这样的问题呢？其根本原因就是在mipmap中所采用的不同level的Mipmap默认的都是正方形区域的Range Query，然而真实情况并不是如此，见下图:<br><img src=\"/images/graphics8/screen_to_texture.png\" alt=\"\"><br>可以清楚地看到 screen space 的像素点所对应的footprint是不同的，有长方形，甚至是不规则图形。这是因为实际场景中的透视投影的效果造成的，在实际场景渲染中会经常出现这种问题。那么针对这种情况，有的所需要的是仅仅是水平方向的高level，有的需要的仅仅是竖直方向上的高level，因此这也就启发了各向异性的过滤:<br><img src=\"/images/graphics8/anisotropic.png\" alt=\"\"><br>各向异性过滤是让纹理分别在水平和竖直方向上做不同级别的像素融合，可以让不同形状的footprint映射到准确的纹理形状上。使用各向异性的效果如下，相较于简单的mipmap好了非常多！<br><img src=\"/images/graphics8/filter_better.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"纹理映射\"><a href=\"#纹理映射\" class=\"headerlink\" title=\"纹理映射\"></a>纹理映射</h2><h3 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h3><pre><code>纹理映射（Texture Mapping），又称纹理贴图，是将纹理空间中的纹理像素映射到屏幕空间中的像素的过程。\n简单来说，就是把一幅图像贴到三维物体的表面上来增强真实感，可以和光照计算、图像混合等技术结合起来形成许多非常漂亮的效果。\nvia 100°C百科\n</code></pre><p>首先我们观察下皮克斯的顽皮跳跳灯这个场景：<br><img src=\"/images/graphics8/texture_mapping_lamp.png\" alt=\"\"><br>灯下玩具球的图案和桌子上木板纹路图案都是完全不同的。除此之外，球表面由于灯的照射效果呈现出了高光的样式，在部分区域反射了灯的光线。而在桌子上的木板却呈现着均匀的光线效果，没有很强的高光样式。在之前讲解 Blinn-Phong 反射模型的时候曾提到，一个点的颜色是由其漫反射系数决定的，反射什么颜色的光，人眼就能看见什么颜色。<strong>纹理映射</strong>的作用就是定义一组具有相同反射特性且颜色已经定义好的颜色图案，将其应用在已经构建好的模型之上。</p>\n<h3 id=\"如何实现纹理映射\"><a href=\"#如何实现纹理映射\" class=\"headerlink\" title=\"如何实现纹理映射\"></a>如何实现纹理映射</h3><p>那么纹理映射要怎么做呢？我们先看看，如何将三维的物体映射到二维的平面上。<br><img src=\"/images/graphics8/earth_mapping.png\" alt=\"\"><br>上图的例子是一个地球仪，地球仪的模型是一个球，表面纹理即为世界地图的平面展开的图像。倘若拥有从3维 world space 到2维 Texture space 的一个映射关系，那么只需要将每个点的颜色信息即漫反射系数存储在2维的 Texture 之上，每次利用光照模型进行计算的时候根据映射关系就能查到这个点的漫反射系数是多少，所有点计算完之后，结果就像最左边的 screen space 之中，整个 Texture 被贴在了模型之上。</p>\n<p>纹理映射让造型技术变得简单很多，对于模型表面很多细节都可以通过纹理映射的方式让其映射到 Texture 上来。比如下面这个例子：<br><img src=\"/images/graphics8/monster.png\" alt=\"\"><br>对于模型上的每个三角形可以映射到纹理中的每个三角形上，形成一一对应的关系，然后纹理上作出修改即可影响模型最终的渲染的颜色值。这个过程只需要在空间坐标中存储纹理坐标的值即可实现对应关系。即空间坐标$（x, y, z）$会存储纹理坐标$（u, v）$的值，从而实现纹理映射。如下图:<br><img src=\"/images/graphics8/monster_uv.png\" alt=\"\"></p>\n<p>这一过程可以用伪代码进行表示：<br><img src=\"/images/graphics8/texture_code.png\" alt=\"\"><br>即纹理映射过程有以下三个步骤：</p>\n<ol>\n<li>对每个光栅化的像素坐标（往往是像素中心点）进行采样</li>\n<li>利用重心坐标的方式对这个点进行插值计算计算出其uv坐标</li>\n<li>然后使用uv坐标上定义的值作为漫反射系数 $K_d$ 使用 Blinn-Phong 反射模型进行颜色取值。</li>\n</ol>\n<h3 id=\"纹理过小的情况\"><a href=\"#纹理过小的情况\" class=\"headerlink\" title=\"纹理过小的情况\"></a>纹理过小的情况</h3><p>纹理过小的问题相对容易理解，想想我们把一张100x100的纹理贴图应用在一500x500的屏幕之上必然会导致走样失真，因为屏幕空间的几个像素点对应在纹理贴图的坐标上都是集中在一个像素大小之内。那么如果仅仅是使用对应(u,v)坐标在texture贴图下最近的那个像素点，往往会造成严重的走样。<br><img src=\"/images/graphics8/tiny_texture.png\" alt=\"\"><br>如上图所示，红色点为uv坐标对应的空间坐标点，黑色的为实际的空间坐标点。一个uv坐标点无法与模型的空间坐标点进行对应，如果简单的进行坐标取整将其映射到最近的一个坐标上会导致出现严重的走样效果。这里可以用双线性插值的方法来解决这个问题。</p>\n<h3 id=\"双线性插值\"><a href=\"#双线性插值\" class=\"headerlink\" title=\"双线性插值\"></a>双线性插值</h3><p>进行双线性插值的前提条件是已知uv坐标对应的空间点的位置坐标 $（x, y）$，利用临近四个点的坐标值可以求出其对应相邻像素的偏移量$s、t$，如下图所示：<br><img src=\"/images/graphics8/bilinear1.png\" alt=\"\"></p>\n<p>利用偏移量和临近点的坐标，通过线性插值的思路可以快速求出其在竖直方向的值$u_0、u_1$，如下图所示<br><img src=\"/images/graphics8/bilinear2.png\" alt=\"\"></p>\n<p>同理再次利用竖直方向的线性插值法可以求出对应点的颜色值。</p>\n<p>双线性插值的方法对于纹理过小的情况处理速度和处理效果都非常好，下图是处理后的对比效果：<br><img src=\"/images/graphics8/bilinear3.png\" alt=\"\"></p>\n<p>注：图中 Bicubic 方法是一种双三次插值的方法，函数 f 在点 (x, y) 的值可以通过矩形网格中最近的十六个采样点的加权平均得到，在这里需要使用两个多项式插值三次函数，每个方向使用一个。这种方法的效果要好于双线性插值，但是计算过程比较复杂。</p>\n<h3 id=\"纹理过大的情况（较难处理）\"><a href=\"#纹理过大的情况（较难处理）\" class=\"headerlink\" title=\"纹理过大的情况（较难处理）\"></a>纹理过大的情况（较难处理）</h3><p>按照常理考虑，纹理应该是越大越好，因为纹理越大对应的到每个像素的细节就会越多，图像应该是更清晰的。但是实际结果却<strong>并非如此</strong>，将过大的纹理映射到一个较小的模型上的效果如下图所示：<br><img src=\"/images/graphics8/huge_texture.png\" alt=\"\"></p>\n<p>实际效果却是近处锯齿，远处摩尔纹，很反直觉地出现了严重的走样效果。经过前面反走样部分的内容可以知道，出现这样现象的愿意在于欠采样。结合这个例子我们可以这样理解：</p>\n<ol>\n<li>假定一种纹理过大的情况，在极限情况纹理非常大，然后屏幕像素非常少（只有几个）。</li>\n<li>我们需要用仅有的几个像素表示这么多的纹理信息。</li>\n<li>则屏幕坐标映射到纹理坐标上的时候，一个屏幕坐标对应了若干个纹理坐标。</li>\n<li>在这种情况下无法正确地进行采样确定屏幕坐标的颜色，所以造成了走样的现象。<br><img src=\"/images/graphics8/footprint.png\" alt=\"\"></li>\n</ol>\n<p>这种现象被形象的成为屏幕像素在texture空间的footprint。如上图所示一个屏幕空间的蓝色像素点离相机越远，对应在texture空间的范围也就越大。其实也就是越来越欠采样，那么一种直观的解决方法就是Supersampling，如果一个像素点不足以代表一个区域的颜色信息，那么便把一个像素细分为更多个小的采样点不就可以解决这个问题了吗？对，确实是这样，可以看看如下图512x超采样的结果:<br><img src=\"/images/graphics8/ssaa.png\" alt=\"\"></p>\n<p>但是如此效果的代价也是非常大的，计算量太大了，一个像素点被分为了512x512个采样点，计算量为原来的25万倍之多。而且这也不能从根本上解决问题，因为理论上计算量会随着纹理超过实际屏幕像素的大小而发生变化。</p>\n<h2 id=\"Mipmap\"><a href=\"#Mipmap\" class=\"headerlink\" title=\"Mipmap\"></a>Mipmap</h2><h3 id=\"基础定义\"><a href=\"#基础定义\" class=\"headerlink\" title=\"基础定义\"></a>基础定义</h3><p>既然纹理尺寸过大，那么我们缩小纹理尺寸理论上就可以解决这个问题。正如上文所提，一个采样点的颜色信息不足以代表  footprint 里一个区域的颜色信息，如果可以求出这样一个区域里面所有颜色的均值。<br>但是纹理尺寸缩小多少也是一个很难解决的问题，因为在实际使用中模型和屏幕尺寸的大小都不确定。此外在一般的三维场景中由于透视关系的存在，纹理的footprint可能会随着物体距离相机的距离而发生变化。</p>\n<p><img src=\"/images/graphics8/projection.png\" alt=\"\"><br>如上图所示，近处的采样的footprint显然会比远处的小很多。因此纹理应该支持多个级别的查询。Mipmap就是这种优化纹理使用的技术，它可以一定程度上解决纹理尺寸过大的问题。</p>\n<p><img src=\"/images/graphics8/mipmap.png\" alt=\"\"></p>\n<p>如上图所示level 0代表的是原始texture，也是精度最高的原始纹理，随着level的提升，每提升一级将4个相邻像素点求均值合为一个像素点，因此越高的level也就代表了更大的footprint的区域查询。接下来要做的就是根据屏幕像素的footprint大小选定不同level的texture，再进行点查询即可，而这其实就相当于在原始texture上进行了区域查询。</p>\n<h3 id=\"level的取值问题\"><a href=\"#level的取值问题\" class=\"headerlink\" title=\"level的取值问题\"></a>level的取值问题</h3><p>得到了 mipmap 之后如何选取代表精度 level 的 D 值呢？ 这里可以利用屏幕像素点来估算footprint的大小再确定D值，如下图：<br><img src=\"/images/graphics8/levelD.png\" alt=\"\"><br>在屏幕空间中取当前像素点的右方和上方的两个相邻像素点(4个全取也可以)，分别查询得到这3个点对应在Texture space的坐标，计算出当前像素点与右方像素点和上方像素点在 Texture space 的距离，二者取最大值，计算公式如图中所示，那么level D 就是这个距离的 log2 值 (D = log2L) ! 这不难理解，读者可以具体取几个例子比如 L = 1，L = 2，L = 4，看看是否符合这样的计算即可。</p>\n<p>但是这里D值算出来是一个连续值，并不是一个整数，有两种对应的方法：</p>\n<p>1 四舍五入取得最近的那个 level D</p>\n<p>2 利用 D 值在向下和向上取整的两个不同level进行三线性插值</p>\n<p><img src=\"/images/graphics8/integerD.png\" alt=\"\"></p>\n<p>上图是四舍五入求得的D的分布值，可以看到过度效果不好，很多区域过度效果很硬，实际展示效果也不佳。</p>\n<p>三线性插值是一个很好的解决上述问题的方法：<br><img src=\"/images/graphics8/trilinear.png\" alt=\"\"></p>\n<p>如上图所示，主要思路就是基于计算出的 D 的下取整值，在level D平面和 level D+1 平面上分别进行一次双线性插值计算出采样点的值，然后再基于两个平面的比例进行一次线性插值，从而完成一次三线性插值。<br><img src=\"/images/graphics8/trilinearD.png\" alt=\"\"></p>\n<p>上图是三线性插值后的D的分布情况，相较于四舍五入要好非常多，过度效果很平滑。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>mipmap虽然能有效地解决颜色查询的问题，但是应用在我们这个例子上却出现了以下结果：<br><img src=\"/images/graphics8/mipmap_limitations.png\" alt=\"\"><br>在近处展示尚可，但是在远处几乎糊成一片了，这里可以使用各向异性过滤来解决这个问题</p>\n<h3 id=\"各向异性过滤mipmap\"><a href=\"#各向异性过滤mipmap\" class=\"headerlink\" title=\"各向异性过滤mipmap\"></a>各向异性过滤mipmap</h3><p>为什么在上面的例子中，使用mipmap来处理纹理会出现这样的问题呢？其根本原因就是在mipmap中所采用的不同level的Mipmap默认的都是正方形区域的Range Query，然而真实情况并不是如此，见下图:<br><img src=\"/images/graphics8/screen_to_texture.png\" alt=\"\"><br>可以清楚地看到 screen space 的像素点所对应的footprint是不同的，有长方形，甚至是不规则图形。这是因为实际场景中的透视投影的效果造成的，在实际场景渲染中会经常出现这种问题。那么针对这种情况，有的所需要的是仅仅是水平方向的高level，有的需要的仅仅是竖直方向上的高level，因此这也就启发了各向异性的过滤:<br><img src=\"/images/graphics8/anisotropic.png\" alt=\"\"><br>各向异性过滤是让纹理分别在水平和竖直方向上做不同级别的像素融合，可以让不同形状的footprint映射到准确的纹理形状上。使用各向异性的效果如下，相较于简单的mipmap好了非常多！<br><img src=\"/images/graphics8/filter_better.png\" alt=\"\"></p>\n"},{"title":"使用latex来书写数学公式1 —— latex基础知识","index_img":"/images/latex/latex_head.png","date":"2020-08-10T13:09:11.000Z","math":true,"_content":"## TEX && LATEX\n\nTEX 是Donald E. Knuth 编写的一个以排版文章及数学公式为目标的计算机程序。1977 年，在意识到恶劣的排版质量正在影响自己的著作及文章后，Knuth 开始编写TEX 排版系统引擎，探索当时开始进入出版工业的数字印刷设备的潜 力，尤为希望能扭转排版质量下滑的这一趋势。我们现在使用的TEX 系统发布于 1982 年，在 1989 年又稍做改进，增加了对 8 字节字符及多语言的支持。TEX 以其卓越的稳定性、可在不同类型的电脑上运行以及几乎没有缺陷而著称。TEX 的版本号不断趋近于 π，现在为 3.141592。\n\nLATEX 是一个宏集，它使用一个预先定义好的专业版面，可以使作者们高质量的 排版和打印他们的作品。LATEX 最初由 Leslie Lamport 编写，它使用 TEX 程序作为排版引擎。\n\n## LATEX源文件\n\nLATEX 源文件为普通的ASCII 文件，你可以使用任何文本编辑器来创建。LATEX 源文件不仅包含了要排版的文本，而且也包含了告诉LATEX 如何排版这些文本内 容的命令。\n\n### 空白\n\n空格和制表符等空白字符在LATEX 中被看作相同的空白距离(space)。多个连续 的空白字符等同于一个空白字符。在句首的空白距离一般会被忽略，单个空行也 被认为是一个“空白距离”。\n\n两行文本间的空白行标志着上段的结束和下段的开始。多个空白行的作用 等同于一个空白行。下面便是一个例子，上边是源文件中的文本，下边是排版后的结果。\n\n``` latex\n\nIt does not matter whether you enter one or several    spaces after a word.\n\nAn empty line starts a new paragraph.\n\n```\n![](/images/latex/latex1_graph1.png)\n\n### 特殊字符\n\n下面的这些字符是 LATEX 中的保留字符(reserved characters)，它们或在LATEX 中 有特殊的意义，或不一定存在于所有字库中。如果你直接在文本中输入这些字符，通常它们不会被输出，而且还会导致 LATEX 做一些你不希望发生的事情。需要在这些字符前加上反斜线，它们才可以正常的输出到文档中。\n``` latex\n# $ % ^ & _ { } \\ \n\n#添加反斜线可以输出到文档中\n\\# \\$ \\% \\^{} \\& \\_ \\{ \\} \\{}\n```\n### 命令\n\nATEX 命令(commands) 是大小写敏感的，有以下两种格式:\n\n* 以一个反斜线(backslash)\\开始，命令名只由字母组成。命令名后的空格 符、数字或任何非字母的字符都标志着该命令的结束。\n* 由一个反斜线和非字母的字符组成。\n\nLATEX 忽略命令之后的空白字符。如果你希望在命令后得到一个空格，可以 在命令后加上{} 和一个空格，或加上一个特殊的空格命令。{} 将阻止LATEX 吃掉命令后的所有空格。\n``` latex\nI read that Knuth divides the  \npeople working with \\TeX{} into \n\\TeX{}nicians and \\TeX perts.\\\\ \nToday is \\today. \n```\n![](/images/latex/latex1_graph2.png)\n\n有些命令需要一个参数(parameter)，该参数用花括号(curly braces) { } 括 住并写在命令的后面。一些命令支持可选参数(optional parameters)，可选参数可用方括号(square brackets) [ ] 括住，然后写在命令的后面。\n\n``` latex\nYou can \\textsl{lean} on me!\n```\n![](/images/latex/latex1_graph3.png)\n### 注释\n当LATEX 处理一个源文件时，如果遇到一个百分号%，LATEX 将忽略%后的该行内容，换行符以及下一行前的空白字符。\n\n我们可以据此在源文件中写一些注释，而且这些注释并不会出现在最后的排版结果中。\n\n``` latex\nThis is an % stupid\n% Better: instructive <---- example: Supercal%\n              ifragilist%\n    icexpialidocious\n```\n![](/images/latex/latex1_graph4.png)\n\n如果注释的内容较长，你可以使用verbatim 宏包提供的comment环境。\n``` latex\nThis is another \\begin{comment}\nrather stupid,\nbut helpful\n\\end{comment}\nexample for embedding comments in your document.\n```\n![](/images/latex/latex1_graph5.png)\n\n","source":"_posts/latexlearning1.md","raw":"---\ntitle: 使用latex来书写数学公式1 —— latex基础知识\ntags: [latex, 排版, 论文写作]\ncategories: [latex]\nindex_img: /images/latex/latex_head.png\ndate: 2020-08-10 21:09:11\nmath: true\n---\n## TEX && LATEX\n\nTEX 是Donald E. Knuth 编写的一个以排版文章及数学公式为目标的计算机程序。1977 年，在意识到恶劣的排版质量正在影响自己的著作及文章后，Knuth 开始编写TEX 排版系统引擎，探索当时开始进入出版工业的数字印刷设备的潜 力，尤为希望能扭转排版质量下滑的这一趋势。我们现在使用的TEX 系统发布于 1982 年，在 1989 年又稍做改进，增加了对 8 字节字符及多语言的支持。TEX 以其卓越的稳定性、可在不同类型的电脑上运行以及几乎没有缺陷而著称。TEX 的版本号不断趋近于 π，现在为 3.141592。\n\nLATEX 是一个宏集，它使用一个预先定义好的专业版面，可以使作者们高质量的 排版和打印他们的作品。LATEX 最初由 Leslie Lamport 编写，它使用 TEX 程序作为排版引擎。\n\n## LATEX源文件\n\nLATEX 源文件为普通的ASCII 文件，你可以使用任何文本编辑器来创建。LATEX 源文件不仅包含了要排版的文本，而且也包含了告诉LATEX 如何排版这些文本内 容的命令。\n\n### 空白\n\n空格和制表符等空白字符在LATEX 中被看作相同的空白距离(space)。多个连续 的空白字符等同于一个空白字符。在句首的空白距离一般会被忽略，单个空行也 被认为是一个“空白距离”。\n\n两行文本间的空白行标志着上段的结束和下段的开始。多个空白行的作用 等同于一个空白行。下面便是一个例子，上边是源文件中的文本，下边是排版后的结果。\n\n``` latex\n\nIt does not matter whether you enter one or several    spaces after a word.\n\nAn empty line starts a new paragraph.\n\n```\n![](/images/latex/latex1_graph1.png)\n\n### 特殊字符\n\n下面的这些字符是 LATEX 中的保留字符(reserved characters)，它们或在LATEX 中 有特殊的意义，或不一定存在于所有字库中。如果你直接在文本中输入这些字符，通常它们不会被输出，而且还会导致 LATEX 做一些你不希望发生的事情。需要在这些字符前加上反斜线，它们才可以正常的输出到文档中。\n``` latex\n# $ % ^ & _ { } \\ \n\n#添加反斜线可以输出到文档中\n\\# \\$ \\% \\^{} \\& \\_ \\{ \\} \\{}\n```\n### 命令\n\nATEX 命令(commands) 是大小写敏感的，有以下两种格式:\n\n* 以一个反斜线(backslash)\\开始，命令名只由字母组成。命令名后的空格 符、数字或任何非字母的字符都标志着该命令的结束。\n* 由一个反斜线和非字母的字符组成。\n\nLATEX 忽略命令之后的空白字符。如果你希望在命令后得到一个空格，可以 在命令后加上{} 和一个空格，或加上一个特殊的空格命令。{} 将阻止LATEX 吃掉命令后的所有空格。\n``` latex\nI read that Knuth divides the  \npeople working with \\TeX{} into \n\\TeX{}nicians and \\TeX perts.\\\\ \nToday is \\today. \n```\n![](/images/latex/latex1_graph2.png)\n\n有些命令需要一个参数(parameter)，该参数用花括号(curly braces) { } 括 住并写在命令的后面。一些命令支持可选参数(optional parameters)，可选参数可用方括号(square brackets) [ ] 括住，然后写在命令的后面。\n\n``` latex\nYou can \\textsl{lean} on me!\n```\n![](/images/latex/latex1_graph3.png)\n### 注释\n当LATEX 处理一个源文件时，如果遇到一个百分号%，LATEX 将忽略%后的该行内容，换行符以及下一行前的空白字符。\n\n我们可以据此在源文件中写一些注释，而且这些注释并不会出现在最后的排版结果中。\n\n``` latex\nThis is an % stupid\n% Better: instructive <---- example: Supercal%\n              ifragilist%\n    icexpialidocious\n```\n![](/images/latex/latex1_graph4.png)\n\n如果注释的内容较长，你可以使用verbatim 宏包提供的comment环境。\n``` latex\nThis is another \\begin{comment}\nrather stupid,\nbut helpful\n\\end{comment}\nexample for embedding comments in your document.\n```\n![](/images/latex/latex1_graph5.png)\n\n","slug":"latexlearning1","published":1,"updated":"2020-08-11T03:28:23.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wal0011nwqcggec4nmn","content":"<h2 id=\"TEX-amp-amp-LATEX\"><a href=\"#TEX-amp-amp-LATEX\" class=\"headerlink\" title=\"TEX &amp;&amp; LATEX\"></a>TEX &amp;&amp; LATEX</h2><p>TEX 是Donald E. Knuth 编写的一个以排版文章及数学公式为目标的计算机程序。1977 年，在意识到恶劣的排版质量正在影响自己的著作及文章后，Knuth 开始编写TEX 排版系统引擎，探索当时开始进入出版工业的数字印刷设备的潜 力，尤为希望能扭转排版质量下滑的这一趋势。我们现在使用的TEX 系统发布于 1982 年，在 1989 年又稍做改进，增加了对 8 字节字符及多语言的支持。TEX 以其卓越的稳定性、可在不同类型的电脑上运行以及几乎没有缺陷而著称。TEX 的版本号不断趋近于 π，现在为 3.141592。</p>\n<p>LATEX 是一个宏集，它使用一个预先定义好的专业版面，可以使作者们高质量的 排版和打印他们的作品。LATEX 最初由 Leslie Lamport 编写，它使用 TEX 程序作为排版引擎。</p>\n<h2 id=\"LATEX源文件\"><a href=\"#LATEX源文件\" class=\"headerlink\" title=\"LATEX源文件\"></a>LATEX源文件</h2><p>LATEX 源文件为普通的ASCII 文件，你可以使用任何文本编辑器来创建。LATEX 源文件不仅包含了要排版的文本，而且也包含了告诉LATEX 如何排版这些文本内 容的命令。</p>\n<h3 id=\"空白\"><a href=\"#空白\" class=\"headerlink\" title=\"空白\"></a>空白</h3><p>空格和制表符等空白字符在LATEX 中被看作相同的空白距离(space)。多个连续 的空白字符等同于一个空白字符。在句首的空白距离一般会被忽略，单个空行也 被认为是一个“空白距离”。</p>\n<p>两行文本间的空白行标志着上段的结束和下段的开始。多个空白行的作用 等同于一个空白行。下面便是一个例子，上边是源文件中的文本，下边是排版后的结果。</p>\n<pre><code class=\"hljs latex\">\nIt does not matter whether you enter one or several    spaces after a word.\n\nAn empty line starts a new paragraph.\n</code></pre>\n<p><img src=\"/images/latex/latex1_graph1.png\" alt=\"\"></p>\n<h3 id=\"特殊字符\"><a href=\"#特殊字符\" class=\"headerlink\" title=\"特殊字符\"></a>特殊字符</h3><p>下面的这些字符是 LATEX 中的保留字符(reserved characters)，它们或在LATEX 中 有特殊的意义，或不一定存在于所有字库中。如果你直接在文本中输入这些字符，通常它们不会被输出，而且还会导致 LATEX 做一些你不希望发生的事情。需要在这些字符前加上反斜线，它们才可以正常的输出到文档中。<br><pre><code class=\"hljs latex\"># <span class=\"hljs-formula\">$ % ^ &amp; _ &#123; &#125; <span class=\"hljs-tag\">\\<span class=\"hljs-name\"> </span></span></span>\n<span class=\"hljs-formula\"></span>\n<span class=\"hljs-formula\">#添加反斜线可以输出到文档中</span>\n<span class=\"hljs-formula\"><span class=\"hljs-tag\">\\<span class=\"hljs-name\">#</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">$</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">%</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">^</span><span class=\"hljs-string\">&#123;&#125;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&amp;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">_</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&#123;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&#125;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&#123;</span></span>&#125;</span></code></pre></p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>ATEX 命令(commands) 是大小写敏感的，有以下两种格式:</p>\n<ul>\n<li>以一个反斜线(backslash)\\开始，命令名只由字母组成。命令名后的空格 符、数字或任何非字母的字符都标志着该命令的结束。</li>\n<li>由一个反斜线和非字母的字符组成。</li>\n</ul>\n<p>LATEX 忽略命令之后的空白字符。如果你希望在命令后得到一个空格，可以 在命令后加上{} 和一个空格，或加上一个特殊的空格命令。{} 将阻止LATEX 吃掉命令后的所有空格。<br><pre><code class=\"hljs latex\">I read that Knuth divides the  \npeople working with <span class=\"hljs-tag\">\\<span class=\"hljs-name\">TeX</span><span class=\"hljs-string\">&#123;&#125;</span></span> into \n<span class=\"hljs-tag\">\\<span class=\"hljs-name\">TeX</span><span class=\"hljs-string\">&#123;&#125;</span></span>nicians and <span class=\"hljs-tag\">\\<span class=\"hljs-name\">TeX</span></span> perts.<span class=\"hljs-tag\">\\<span class=\"hljs-name\">\\</span></span> \nToday is <span class=\"hljs-tag\">\\<span class=\"hljs-name\">today</span></span>. </code></pre><br><img src=\"/images/latex/latex1_graph2.png\" alt=\"\"></p>\n<p>有些命令需要一个参数(parameter)，该参数用花括号(curly braces) { } 括 住并写在命令的后面。一些命令支持可选参数(optional parameters)，可选参数可用方括号(square brackets) [ ] 括住，然后写在命令的后面。</p>\n<pre><code class=\"hljs latex\">You can <span class=\"hljs-tag\">\\<span class=\"hljs-name\">textsl</span><span class=\"hljs-string\">&#123;lean&#125;</span></span> on me!</code></pre>\n<p><img src=\"/images/latex/latex1_graph3.png\" alt=\"\"></p>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>当LATEX 处理一个源文件时，如果遇到一个百分号%，LATEX 将忽略%后的该行内容，换行符以及下一行前的空白字符。</p>\n<p>我们可以据此在源文件中写一些注释，而且这些注释并不会出现在最后的排版结果中。</p>\n<pre><code class=\"hljs latex\">This is an <span class=\"hljs-comment\">% stupid</span>\n<span class=\"hljs-comment\">% Better: instructive &lt;---- example: Supercal%</span>\n              ifragilist<span class=\"hljs-comment\">%</span>\n    icexpialidocious</code></pre>\n<p><img src=\"/images/latex/latex1_graph4.png\" alt=\"\"></p>\n<p>如果注释的内容较长，你可以使用verbatim 宏包提供的comment环境。<br><pre><code class=\"hljs latex\">This is another <span class=\"hljs-tag\">\\<span class=\"hljs-name\">begin</span><span class=\"hljs-string\">&#123;comment&#125;</span></span>\nrather stupid,\nbut helpful\n<span class=\"hljs-tag\">\\<span class=\"hljs-name\">end</span><span class=\"hljs-string\">&#123;comment&#125;</span></span>\nexample for embedding comments in your document.</code></pre><br><img src=\"/images/latex/latex1_graph5.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"TEX-amp-amp-LATEX\"><a href=\"#TEX-amp-amp-LATEX\" class=\"headerlink\" title=\"TEX &amp;&amp; LATEX\"></a>TEX &amp;&amp; LATEX</h2><p>TEX 是Donald E. Knuth 编写的一个以排版文章及数学公式为目标的计算机程序。1977 年，在意识到恶劣的排版质量正在影响自己的著作及文章后，Knuth 开始编写TEX 排版系统引擎，探索当时开始进入出版工业的数字印刷设备的潜 力，尤为希望能扭转排版质量下滑的这一趋势。我们现在使用的TEX 系统发布于 1982 年，在 1989 年又稍做改进，增加了对 8 字节字符及多语言的支持。TEX 以其卓越的稳定性、可在不同类型的电脑上运行以及几乎没有缺陷而著称。TEX 的版本号不断趋近于 π，现在为 3.141592。</p>\n<p>LATEX 是一个宏集，它使用一个预先定义好的专业版面，可以使作者们高质量的 排版和打印他们的作品。LATEX 最初由 Leslie Lamport 编写，它使用 TEX 程序作为排版引擎。</p>\n<h2 id=\"LATEX源文件\"><a href=\"#LATEX源文件\" class=\"headerlink\" title=\"LATEX源文件\"></a>LATEX源文件</h2><p>LATEX 源文件为普通的ASCII 文件，你可以使用任何文本编辑器来创建。LATEX 源文件不仅包含了要排版的文本，而且也包含了告诉LATEX 如何排版这些文本内 容的命令。</p>\n<h3 id=\"空白\"><a href=\"#空白\" class=\"headerlink\" title=\"空白\"></a>空白</h3><p>空格和制表符等空白字符在LATEX 中被看作相同的空白距离(space)。多个连续 的空白字符等同于一个空白字符。在句首的空白距离一般会被忽略，单个空行也 被认为是一个“空白距离”。</p>\n<p>两行文本间的空白行标志着上段的结束和下段的开始。多个空白行的作用 等同于一个空白行。下面便是一个例子，上边是源文件中的文本，下边是排版后的结果。</p>\n<pre><code class=\"hljs latex\">\nIt does not matter whether you enter one or several    spaces after a word.\n\nAn empty line starts a new paragraph.\n</code></pre>\n<p><img src=\"/images/latex/latex1_graph1.png\" alt=\"\"></p>\n<h3 id=\"特殊字符\"><a href=\"#特殊字符\" class=\"headerlink\" title=\"特殊字符\"></a>特殊字符</h3><p>下面的这些字符是 LATEX 中的保留字符(reserved characters)，它们或在LATEX 中 有特殊的意义，或不一定存在于所有字库中。如果你直接在文本中输入这些字符，通常它们不会被输出，而且还会导致 LATEX 做一些你不希望发生的事情。需要在这些字符前加上反斜线，它们才可以正常的输出到文档中。<br><pre><code class=\"hljs latex\"># <span class=\"hljs-formula\">$ % ^ &amp; _ &#123; &#125; <span class=\"hljs-tag\">\\<span class=\"hljs-name\"> </span></span></span>\n<span class=\"hljs-formula\"></span>\n<span class=\"hljs-formula\">#添加反斜线可以输出到文档中</span>\n<span class=\"hljs-formula\"><span class=\"hljs-tag\">\\<span class=\"hljs-name\">#</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">$</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">%</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">^</span><span class=\"hljs-string\">&#123;&#125;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&amp;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">_</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&#123;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&#125;</span></span> <span class=\"hljs-tag\">\\<span class=\"hljs-name\">&#123;</span></span>&#125;</span></code></pre></p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>ATEX 命令(commands) 是大小写敏感的，有以下两种格式:</p>\n<ul>\n<li>以一个反斜线(backslash)\\开始，命令名只由字母组成。命令名后的空格 符、数字或任何非字母的字符都标志着该命令的结束。</li>\n<li>由一个反斜线和非字母的字符组成。</li>\n</ul>\n<p>LATEX 忽略命令之后的空白字符。如果你希望在命令后得到一个空格，可以 在命令后加上{} 和一个空格，或加上一个特殊的空格命令。{} 将阻止LATEX 吃掉命令后的所有空格。<br><pre><code class=\"hljs latex\">I read that Knuth divides the  \npeople working with <span class=\"hljs-tag\">\\<span class=\"hljs-name\">TeX</span><span class=\"hljs-string\">&#123;&#125;</span></span> into \n<span class=\"hljs-tag\">\\<span class=\"hljs-name\">TeX</span><span class=\"hljs-string\">&#123;&#125;</span></span>nicians and <span class=\"hljs-tag\">\\<span class=\"hljs-name\">TeX</span></span> perts.<span class=\"hljs-tag\">\\<span class=\"hljs-name\">\\</span></span> \nToday is <span class=\"hljs-tag\">\\<span class=\"hljs-name\">today</span></span>. </code></pre><br><img src=\"/images/latex/latex1_graph2.png\" alt=\"\"></p>\n<p>有些命令需要一个参数(parameter)，该参数用花括号(curly braces) { } 括 住并写在命令的后面。一些命令支持可选参数(optional parameters)，可选参数可用方括号(square brackets) [ ] 括住，然后写在命令的后面。</p>\n<pre><code class=\"hljs latex\">You can <span class=\"hljs-tag\">\\<span class=\"hljs-name\">textsl</span><span class=\"hljs-string\">&#123;lean&#125;</span></span> on me!</code></pre>\n<p><img src=\"/images/latex/latex1_graph3.png\" alt=\"\"></p>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>当LATEX 处理一个源文件时，如果遇到一个百分号%，LATEX 将忽略%后的该行内容，换行符以及下一行前的空白字符。</p>\n<p>我们可以据此在源文件中写一些注释，而且这些注释并不会出现在最后的排版结果中。</p>\n<pre><code class=\"hljs latex\">This is an <span class=\"hljs-comment\">% stupid</span>\n<span class=\"hljs-comment\">% Better: instructive &lt;---- example: Supercal%</span>\n              ifragilist<span class=\"hljs-comment\">%</span>\n    icexpialidocious</code></pre>\n<p><img src=\"/images/latex/latex1_graph4.png\" alt=\"\"></p>\n<p>如果注释的内容较长，你可以使用verbatim 宏包提供的comment环境。<br><pre><code class=\"hljs latex\">This is another <span class=\"hljs-tag\">\\<span class=\"hljs-name\">begin</span><span class=\"hljs-string\">&#123;comment&#125;</span></span>\nrather stupid,\nbut helpful\n<span class=\"hljs-tag\">\\<span class=\"hljs-name\">end</span><span class=\"hljs-string\">&#123;comment&#125;</span></span>\nexample for embedding comments in your document.</code></pre><br><img src=\"/images/latex/latex1_graph5.png\" alt=\"\"></p>\n"},{"title":"使用latex来书写数学公式2 —— latex数学公式","index_img":"/images/latex/latex_head.png","date":"2020-08-11T04:09:11.000Z","math":true,"_content":"## 综述\nLATEX 使用一种特有的模式来排版数学(mathematics) 公式。数学公式允许以 行间形式排版在一个段落之中，也可以以独立形式排版，此时段落可能会被拆 开。处于段内的数学文本要放在 `\\(` 与`\\)` 之间，$ 与$ 之间，或者`\\begin{math}` 与 `\\end{math}` 之间。\n\n例如`c^{2}=a^{2}+b^{2}`经过latex转换为公式：\n\n`$c^{2}=a^{2}+b^{2}$`\n\n`100 m^{3}  \\heartsuit`转换为：\n`$100 m^{3} \\heartsuit$`\n\n\n$$\\lim_{n \\to \\infty} \\sum_{k=1}^n \\frac{1}{k^2} = \\frac{\\pi^2}{6}$$","source":"_posts/latexlearning2.md","raw":"---\ntitle: 使用latex来书写数学公式2 —— latex数学公式\ntags: [latex, 排版, 论文写作]\ncategories: [latex]\nindex_img: /images/latex/latex_head.png\ndate: 2020-08-11 12:09:11\nmath: true\n---\n## 综述\nLATEX 使用一种特有的模式来排版数学(mathematics) 公式。数学公式允许以 行间形式排版在一个段落之中，也可以以独立形式排版，此时段落可能会被拆 开。处于段内的数学文本要放在 `\\(` 与`\\)` 之间，$ 与$ 之间，或者`\\begin{math}` 与 `\\end{math}` 之间。\n\n例如`c^{2}=a^{2}+b^{2}`经过latex转换为公式：\n\n`$c^{2}=a^{2}+b^{2}$`\n\n`100 m^{3}  \\heartsuit`转换为：\n`$100 m^{3} \\heartsuit$`\n\n\n$$\\lim_{n \\to \\infty} \\sum_{k=1}^n \\frac{1}{k^2} = \\frac{\\pi^2}{6}$$","slug":"latexlearning2","published":1,"updated":"2020-08-11T05:59:22.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmlv1wam0015nwqcfagd3jx2","content":"<h2 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h2><p>LATEX 使用一种特有的模式来排版数学(mathematics) 公式。数学公式允许以 行间形式排版在一个段落之中，也可以以独立形式排版，此时段落可能会被拆 开。处于段内的数学文本要放在 <code>\\(</code> 与<code>\\)</code> 之间，$ 与$ 之间，或者<code>\\begin&#123;math&#125;</code> 与 <code>\\end&#123;math&#125;</code> 之间。</p>\n<p>例如<code>c^&#123;2&#125;=a^&#123;2&#125;+b^&#123;2&#125;</code>经过latex转换为公式：</p>\n<script type=\"math/tex; mode=display\">c^{2}=a^{2}+b^{2}</script><p><code>100 m^&#123;3&#125;  \\heartsuit</code>转换为：</p>\n<script type=\"math/tex; mode=display\">100 m^{3} \\heartsuit</script><script type=\"math/tex; mode=display\">\\lim_{n \\to \\infty} \\sum_{k=1}^n \\frac{1}{k^2} = \\frac{\\pi^2}{6}</script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h2><p>LATEX 使用一种特有的模式来排版数学(mathematics) 公式。数学公式允许以 行间形式排版在一个段落之中，也可以以独立形式排版，此时段落可能会被拆 开。处于段内的数学文本要放在 <code>\\(</code> 与<code>\\)</code> 之间，$ 与$ 之间，或者<code>\\begin&#123;math&#125;</code> 与 <code>\\end&#123;math&#125;</code> 之间。</p>\n<p>例如<code>c^&#123;2&#125;=a^&#123;2&#125;+b^&#123;2&#125;</code>经过latex转换为公式：</p>\n<script type=\"math/tex; mode=display\">c^{2}=a^{2}+b^{2}</script><p><code>100 m^&#123;3&#125;  \\heartsuit</code>转换为：</p>\n<script type=\"math/tex; mode=display\">100 m^{3} \\heartsuit</script><script type=\"math/tex; mode=display\">\\lim_{n \\to \\infty} \\sum_{k=1}^n \\frac{1}{k^2} = \\frac{\\pi^2}{6}</script>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckmlv1wa50006nwqc18zp7i40","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1wab000cnwqcc3599mha"},{"post_id":"ckmlv1w9z0001nwqc2fn70ljb","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1wad000hnwqc06rph0y1"},{"post_id":"ckmlv1wa9000anwqccmecfhan","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1wae000knwqcehqxce9j"},{"post_id":"ckmlv1wa10002nwqcbc1kfjyt","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1wah000onwqc2i6egzxn"},{"post_id":"ckmlv1waa000bnwqcbk1538ha","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1wai000rnwqchatbacma"},{"post_id":"ckmlv1wac000gnwqc30eg3ffi","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1waj000unwqc6d54fre2"},{"post_id":"ckmlv1wa40005nwqc17hu88z5","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1wak000wnwqch5bm976y"},{"post_id":"ckmlv1wad000jnwqc7ve3fuxb","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1wak000znwqca48f4ee5"},{"post_id":"ckmlv1wag000nnwqc4gce5bda","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1wam0012nwqcbqi82rzm"},{"post_id":"ckmlv1wah000qnwqc7uaq1ntv","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1wan0016nwqc907j2c98"},{"post_id":"ckmlv1wai000tnwqc8w9bbepd","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1wao0019nwqcds3sh9bc"},{"post_id":"ckmlv1waj000vnwqc5a65f014","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1wao001bnwqc19ed72j0"},{"post_id":"ckmlv1wak000ynwqccwoa2tjr","category_id":"ckmlv1wa20003nwqcfoose1ck","_id":"ckmlv1wao001dnwqccxw24vsu"},{"post_id":"ckmlv1wal0011nwqcggec4nmn","category_id":"ckmlv1wan0018nwqch8h08hwj","_id":"ckmlv1wap001gnwqccik7bmhk"},{"post_id":"ckmlv1wam0015nwqcfagd3jx2","category_id":"ckmlv1wan0018nwqch8h08hwj","_id":"ckmlv1wap001knwqchbzv99pp"}],"PostTag":[{"post_id":"ckmlv1wa9000anwqccmecfhan","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1wac000fnwqcdcpp1w4u"},{"post_id":"ckmlv1wa9000anwqccmecfhan","tag_id":"ckmlv1wa70009nwqc5w9pcafi","_id":"ckmlv1wad000inwqcg9rh407y"},{"post_id":"ckmlv1w9z0001nwqc2fn70ljb","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1wae000mnwqc53k1d5u5"},{"post_id":"ckmlv1w9z0001nwqc2fn70ljb","tag_id":"ckmlv1wa70009nwqc5w9pcafi","_id":"ckmlv1wah000pnwqc3ksi54sb"},{"post_id":"ckmlv1wa10002nwqcbc1kfjyt","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1wal0010nwqcdje8fr8c"},{"post_id":"ckmlv1wa10002nwqcbc1kfjyt","tag_id":"ckmlv1wae000lnwqc41mw86nq","_id":"ckmlv1wam0013nwqcb3c257o2"},{"post_id":"ckmlv1wa10002nwqcbc1kfjyt","tag_id":"ckmlv1wai000snwqc1sb5a47v","_id":"ckmlv1wan0017nwqccvi27am5"},{"post_id":"ckmlv1wa40005nwqc17hu88z5","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1wap001fnwqccdbkbzv2"},{"post_id":"ckmlv1wa40005nwqc17hu88z5","tag_id":"ckmlv1wae000lnwqc41mw86nq","_id":"ckmlv1wap001hnwqc6f2j75wl"},{"post_id":"ckmlv1wa40005nwqc17hu88z5","tag_id":"ckmlv1wao001anwqc7n98fyqo","_id":"ckmlv1wap001jnwqc8lnb6wow"},{"post_id":"ckmlv1wa50006nwqc18zp7i40","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1waq001mnwqc6livg8br"},{"post_id":"ckmlv1wa50006nwqc18zp7i40","tag_id":"ckmlv1wap001enwqc4oi94ix7","_id":"ckmlv1waq001nnwqc863089zy"},{"post_id":"ckmlv1wa50006nwqc18zp7i40","tag_id":"ckmlv1wap001inwqch0st99by","_id":"ckmlv1waq001pnwqcb31m8man"},{"post_id":"ckmlv1waa000bnwqcbk1538ha","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1waq001qnwqcg6iihyr6"},{"post_id":"ckmlv1waa000bnwqcbk1538ha","tag_id":"ckmlv1waq001lnwqc0x8p16ts","_id":"ckmlv1war001snwqc2z6a58ti"},{"post_id":"ckmlv1wac000gnwqc30eg3ffi","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1war001unwqcgqz8ai2m"},{"post_id":"ckmlv1wac000gnwqc30eg3ffi","tag_id":"ckmlv1waq001onwqc8n4u69p4","_id":"ckmlv1war001vnwqcc54n3jxm"},{"post_id":"ckmlv1wac000gnwqc30eg3ffi","tag_id":"ckmlv1waq001rnwqc8jpf2d22","_id":"ckmlv1war001xnwqc9yzdd2yr"},{"post_id":"ckmlv1wad000jnwqc7ve3fuxb","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1was001znwqc7z67ftr1"},{"post_id":"ckmlv1wad000jnwqc7ve3fuxb","tag_id":"ckmlv1waq001onwqc8n4u69p4","_id":"ckmlv1was0020nwqc59x1h9zy"},{"post_id":"ckmlv1wad000jnwqc7ve3fuxb","tag_id":"ckmlv1war001wnwqc0x7uhnio","_id":"ckmlv1was0022nwqc238u9r36"},{"post_id":"ckmlv1wag000nnwqc4gce5bda","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1wat0025nwqc9ci7et28"},{"post_id":"ckmlv1wag000nnwqc4gce5bda","tag_id":"ckmlv1was001ynwqcfhq581qe","_id":"ckmlv1wat0026nwqchfydg7zt"},{"post_id":"ckmlv1wag000nnwqc4gce5bda","tag_id":"ckmlv1was0021nwqc7izy8bue","_id":"ckmlv1wat0028nwqc7kx6993g"},{"post_id":"ckmlv1wag000nnwqc4gce5bda","tag_id":"ckmlv1was0023nwqcbus3fwjt","_id":"ckmlv1wat0029nwqc4fmk2izr"},{"post_id":"ckmlv1wah000qnwqc7uaq1ntv","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1wav002bnwqc2hdg1ujc"},{"post_id":"ckmlv1wah000qnwqc7uaq1ntv","tag_id":"ckmlv1wat0024nwqc0q89d6u5","_id":"ckmlv1waw002cnwqc4wtq2zr4"},{"post_id":"ckmlv1wah000qnwqc7uaq1ntv","tag_id":"ckmlv1wat0027nwqcd5mwc1m7","_id":"ckmlv1waw002enwqcaoij0j6f"},{"post_id":"ckmlv1wai000tnwqc8w9bbepd","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1waw002fnwqcf472dmph"},{"post_id":"ckmlv1wai000tnwqc8w9bbepd","tag_id":"ckmlv1wat002anwqc8dhp3l7c","_id":"ckmlv1wax002hnwqc1lvub5dc"},{"post_id":"ckmlv1waj000vnwqc5a65f014","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1waz002jnwqc1y0v0mgt"},{"post_id":"ckmlv1waj000vnwqc5a65f014","tag_id":"ckmlv1wae000lnwqc41mw86nq","_id":"ckmlv1waz002knwqc7xea5ch3"},{"post_id":"ckmlv1waj000vnwqc5a65f014","tag_id":"ckmlv1waw002dnwqc0hpe5t7v","_id":"ckmlv1waz002mnwqc50ap5jst"},{"post_id":"ckmlv1waj000vnwqc5a65f014","tag_id":"ckmlv1wax002gnwqc2ng6d60z","_id":"ckmlv1waz002nnwqcboj0hbdw"},{"post_id":"ckmlv1wak000ynwqccwoa2tjr","tag_id":"ckmlv1wa30004nwqc812x2u5d","_id":"ckmlv1waz002pnwqc3ua146wq"},{"post_id":"ckmlv1wak000ynwqccwoa2tjr","tag_id":"ckmlv1wax002inwqchiu37w79","_id":"ckmlv1wb0002qnwqc9cm103uw"},{"post_id":"ckmlv1wak000ynwqccwoa2tjr","tag_id":"ckmlv1waz002lnwqc48mcbfrb","_id":"ckmlv1wb0002snwqcfkw3go35"},{"post_id":"ckmlv1wal0011nwqcggec4nmn","tag_id":"ckmlv1waz002onwqchgzzgi1i","_id":"ckmlv1wb1002vnwqc3ck995b8"},{"post_id":"ckmlv1wal0011nwqcggec4nmn","tag_id":"ckmlv1wb0002rnwqc32ct8hby","_id":"ckmlv1wb1002wnwqc20n871nc"},{"post_id":"ckmlv1wal0011nwqcggec4nmn","tag_id":"ckmlv1wb0002tnwqca1pybhc4","_id":"ckmlv1wb1002ynwqc4ztmd7x9"},{"post_id":"ckmlv1wam0015nwqcfagd3jx2","tag_id":"ckmlv1waz002onwqchgzzgi1i","_id":"ckmlv1wb20030nwqc9ypge5s3"},{"post_id":"ckmlv1wam0015nwqcfagd3jx2","tag_id":"ckmlv1wb0002rnwqc32ct8hby","_id":"ckmlv1wb20031nwqc5w799xkp"},{"post_id":"ckmlv1wam0015nwqcfagd3jx2","tag_id":"ckmlv1wb0002tnwqca1pybhc4","_id":"ckmlv1wb20032nwqc7c2b09nv"}],"Tag":[{"name":"计算机图形学","_id":"ckmlv1wa30004nwqc812x2u5d"},{"name":"线性代数","_id":"ckmlv1wa70009nwqc5w9pcafi"},{"name":"几何","_id":"ckmlv1wae000lnwqc41mw86nq"},{"name":"曲面细分","_id":"ckmlv1wai000snwqc1sb5a47v"},{"name":"贝塞尔曲线","_id":"ckmlv1wao001anwqc7n98fyqo"},{"name":"光线追踪","_id":"ckmlv1wap001enwqc4oi94ix7"},{"name":"阴影","_id":"ckmlv1wap001inwqch0st99by"},{"name":"投影，视图变换","_id":"ckmlv1waq001lnwqc0x8p16ts"},{"name":"光栅化","_id":"ckmlv1waq001onwqc8n4u69p4"},{"name":"bresenham","_id":"ckmlv1waq001rnwqc8jpf2d22"},{"name":"反走样","_id":"ckmlv1war001wnwqc0x7uhnio"},{"name":"光照","_id":"ckmlv1was001ynwqcfhq581qe"},{"name":"着色","_id":"ckmlv1was0021nwqc7izy8bue"},{"name":"渲染模型","_id":"ckmlv1was0023nwqcbus3fwjt"},{"name":"重心坐标","_id":"ckmlv1wat0024nwqc0q89d6u5"},{"name":"线性插值","_id":"ckmlv1wat0027nwqcd5mwc1m7"},{"name":"渲染管线","_id":"ckmlv1wat002anwqc8dhp3l7c"},{"name":"隐式曲面","_id":"ckmlv1waw002dnwqc0hpe5t7v"},{"name":"显式曲面","_id":"ckmlv1wax002gnwqc2ng6d60z"},{"name":"纹理映射","_id":"ckmlv1wax002inwqchiu37w79"},{"name":"Mipmap","_id":"ckmlv1waz002lnwqc48mcbfrb"},{"name":"latex","_id":"ckmlv1waz002onwqchgzzgi1i"},{"name":"排版","_id":"ckmlv1wb0002rnwqc32ct8hby"},{"name":"论文写作","_id":"ckmlv1wb0002tnwqca1pybhc4"}]}}
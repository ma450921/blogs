<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/25/ComputerGraphics12/"/>
    <url>/2020/10/25/ComputerGraphics12/</url>
    
    <content type="html"><![CDATA[<hr><p>title: 计算机图形学12 —— 阴影和光线追踪介绍<br>tags: [计算机图形学, 光线追踪, 阴影]<br>categories: [GAMES101]<br>index_img: /images/graphics7/graphics7_banner.png<br>date: 2020-10-03 17:09:11</p><h2 id="阴影光栅化方式表示"><a href="#阴影光栅化方式表示" class="headerlink" title="阴影光栅化方式表示"></a>阴影光栅化方式表示</h2><h2 id="光线追踪简介"><a href="#光线追踪简介" class="headerlink" title="光线追踪简介"></a>光线追踪简介</h2><h2 id="whitted-ray-tracing"><a href="#whitted-ray-tracing" class="headerlink" title="whitted ray tracing"></a>whitted ray tracing</h2><h2 id="calculate-intersection"><a href="#calculate-intersection" class="headerlink" title="calculate intersection"></a>calculate intersection</h2><h2 id="Axis-Aligned-Bounding-box"><a href="#Axis-Aligned-Bounding-box" class="headerlink" title="Axis-Aligned Bounding box"></a>Axis-Aligned Bounding box</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学11 —— 曲面细分</title>
    <link href="/2020/10/03/ComputerGraphics11/"/>
    <url>/2020/10/03/ComputerGraphics11/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>几何</tag>
      
      <tag>曲面细分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学10 ——  贝塞尔曲线</title>
    <link href="/2020/10/03/ComputerGraphics10/"/>
    <url>/2020/10/03/ComputerGraphics10/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>几何</tag>
      
      <tag>贝塞尔曲线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学13 -</title>
    <link href="/2020/10/03/ComputerGraphics13/"/>
    <url>/2020/10/03/ComputerGraphics13/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>光线追踪</tag>
      
      <tag>阴影</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学7.5 —— 重心坐标和线性插值</title>
    <link href="/2020/10/03/ComputerGraphics7.5/"/>
    <url>/2020/10/03/ComputerGraphics7.5/</url>
    
    <content type="html"><![CDATA[<h2 id="重心坐标的定义"><a href="#重心坐标的定义" class="headerlink" title="重心坐标的定义"></a>重心坐标的定义</h2><p>重心坐标是由三角形顶点点定义出的一个特征点坐标，它满足以下特征：</p><ol><li>令$\alpha$、$\beta$、$\gamma$为数字常量，且 $\alpha + \beta + \gamma = 1$。</li><li>重心坐标则为三个顶点分别乘以三个系数的坐标值，即 $(x, y) = \alpha A + \beta B + \gamma C$</li></ol><p><img src="/images/graphics7.5/barycentric_coordinates.png" alt=""></p><p>此外在三角形中，重心坐标又被称为面积坐标。因为P点关于三角形ABC的重心坐标和三角形PBC, PCA及PAB的（有向）面积成比例。证明如下：（如下图所示）</p><p>我们用黑体小写字母表示对应点的向量，比如三角形ABC顶点为 $a$、$b$、$c$，P点为$p$。设三角形PBC、PCA以及PAB的比例为 $\lambda_1 : \lambda_2 : \lambda_3$，且$\lambda_1 + \lambda_2 + \lambda_3 = 1$，设射线AP与BC交于D。</p><p><img src="/images/graphics7.5/Areal_coordinates.png" alt=""></p><script type="math/tex; mode=display">由相似三角形的特性可以得出：BD : DC = \lambda_3 : \lambda_2</script><script type="math/tex; mode=display">则d的坐标为： d = \frac{\lambda_2 b  + \lambda_3 c}{\lambda_2 + \lambda_3}</script><script type="math/tex; mode=display">同理：AP : PC = (\lambda_3 + \lambda_2) : \lambda_1</script><script type="math/tex; mode=display">则 p 的坐标为：p = \frac{(\lambda_3 + \lambda_2) d  + \lambda1 a}{\lambda_1 + \lambda_2 + \lambda_3}</script><script type="math/tex; mode=display">综上化简后，p为：p = \lambda_1 a + \lambda_2 b + \lambda_3 c</script><h2 id="重心坐标的应用"><a href="#重心坐标的应用" class="headerlink" title="重心坐标的应用"></a>重心坐标的应用</h2><h3 id="判断点的位置"><a href="#判断点的位置" class="headerlink" title="判断点的位置"></a>判断点的位置</h3><h3 id="线性插值"><a href="#线性插值" class="headerlink" title="线性插值"></a>线性插值</h3>]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>重心坐标</tag>
      
      <tag>线性插值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学7 —— 渲染管线</title>
    <link href="/2020/10/03/ComputerGraphics7/"/>
    <url>/2020/10/03/ComputerGraphics7/</url>
    
    <content type="html"><![CDATA[<h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>渲染管线是实时渲染的重要工具，实时渲染离不开渲染管线。图形渲染管线主要包括两个功能：一是将物体3D坐标转变为屏幕空间2D坐标，二是为屏幕每个像素点进行着色。渲染管线的一般流程如下图所示。分别是：顶点数据的输入、顶点着色器、曲面细分过程、几何着色器、图元组装、裁剪剔除、光栅化、片段着色器以及混合测试。渲染管线流程实际上就是对前文中介绍的各项技术的一个总结。其大致流程如下图：<br><img src="/images/graphics7/graphics7_banner.png" alt=""></p><ul><li>顶点处理，即将在3D场景的顶点数据转换为2D屏幕的坐标数据（MVP过程）。</li><li>三角形处理，即将顶点分割为屏幕中的渲染三角形。</li><li>光栅化，也就是采样过程，确定三角形覆盖的像素。</li><li>着色，主要通过着色器对像素进行颜色的绘制。</li><li>帧缓冲，输出着色后的图形。</li></ul><h3 id="顶点处理-amp-amp-三角形处理"><a href="#顶点处理-amp-amp-三角形处理" class="headerlink" title="顶点处理 &amp;&amp; 三角形处理"></a>顶点处理 &amp;&amp; 三角形处理</h3><p><img src="/images/graphics7/graphics7_vertex.jpg" alt=""><br>顶点处理过程实际上就是对所有顶点进行Modal、view、projection的转换，将3D的顶点信息投影到2D的屏幕上来。这一部分在本系列笔记的第2、3 部分有着较为详细的讨论。另外，顶点处理还有一个比较重要的作用就是确定像素深度，为后续着色过程中ZBuffer提供深度z值。</p><p>三角形处理相对就简单很多，只需要将处理好的顶点数据分割为三角形。对于三角形而言，是几何中最简单的多边形，因此分割为三角形而非其他多边形能有效地提高分割以及渲染的性能。（当然存在一些渲染引擎以四边形作为基础的渲染多边形，以简化建模过程。）</p><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>当分割为合适的三角形之后，就需要用到我们在本系列笔记的第4部分中提到的光栅化过程。逐个对每个三角形中的每个像素进行采样，判断像素是否在三角形内。而且在光栅化这一步同时涉及到我们在系列笔记第5部分提到的走样的原理以及反走样原理和抗锯齿的过程。<br><img src="/images/graphics7/graphics7_rasterization.jpg" alt=""></p><h3 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h3><p>渲染管线流程中的着色，是通过着色器（shader）实现的。shader其实就是专门用来渲染图形的一种技术，通过shader，我们可以自定义GPU渲染画面的算法，使画面达到我们想要的效果。一般来说shader分为两类：</p><ol><li>顶点着色器（vertext shader），它的作用主要是处理顶点数据，生成裁剪空间坐标值。</li><li>片段着色曲(fragment shader)，它的作用是主要用来处理三角形内每个像素的颜色值。</li></ol><p><img src="/images/graphics7/graphics7_shading.jpg" alt=""><br>当着色器接收到完成光栅化后的片段时，需要对其进行着色处理。在系列笔记的第6部分我们提到了着色的过程，这一过程涉及到渲染管线中的顶点处理和片段处理。顶点着色器运行在顶点处理中。在顶点处理时就可以直接对顶点的值进行计算，比如说Gouraud Shading和phong shading，它们都会涉及到顶点颜色的处理。而片段着色器主要是用来处理图元或者说片段信息，也就是被拆分后的一个个三角形面中的像素。比如说plat shading会直接对一个片段使用同一种颜色进行着色。或者是Gouraud中通过差值的方式，对片段进行着色。</p><p><img src="/images/graphics7/graphics7_zbuffer.jpg" alt=""><br>当然，着色的过程始终是在2D平面中进行的，像素也就存在着遮挡问题。这个时候通过ZBuffer缓存，对像素深度信息进行缓存，从而确定，哪些像素点应该显示在屏幕上，哪些点被遮挡了不应该显示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章主要是对于可编程渲染管线的每个步骤的总结，其内容在前面笔记中都有详细的描述。可编程渲染管线是过去20年中图形学工业腾飞的基石，程序员可以有效的控制渲染过程，编程来代替原来固定的顶点处理和片元处理从而达到各种各样令人惊叹的效果。</p>]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>渲染管线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学9 - 几何介绍</title>
    <link href="/2020/10/03/ComputerGraphics9/"/>
    <url>/2020/10/03/ComputerGraphics9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>几何</tag>
      
      <tag>隐式曲面</tag>
      
      <tag>显式曲面</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学8 ——  纹理映射和Mipmap</title>
    <link href="/2020/10/03/ComputerGraphics8/"/>
    <url>/2020/10/03/ComputerGraphics8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>纹理映射</tag>
      
      <tag>Mipmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学6 —— 着色</title>
    <link href="/2020/10/01/ComputerGraphics6/"/>
    <url>/2020/10/01/ComputerGraphics6/</url>
    
    <content type="html"><![CDATA[<h2 id="可见性和Z-buffer"><a href="#可见性和Z-buffer" class="headerlink" title="可见性和Z-buffer"></a>可见性和Z-buffer</h2><p>对于在一个场景中进行绘制时，将3D模型投影到2D屏幕上的时候，总会出现遮盖的情景。那么那些部分可见，那些部分不可见是需要考虑的。最直接的方式就是一层一层，从远及近将这张图给画出来，这样前景的物体就会遮挡住背景的物体。这种绘制方式叫做画家算法（painter’s algorithm）<br>但是这种简单的做法在很多场景是很难解决的，因为远近先后顺序这个很难做判断。比如说下面这个场景三角形$P、R、Q$相互的前后关系很难确定，实际要表现的效果是互有遮挡。因此单纯使用画家算法来一层层进行绘制，是很难达到显示效果的。<br><img src="/images/graphics6/graphics6_painter.png" alt=""></p><p>Z-buffer算法解决了这个问题，因为对于三角形来说确定遮挡关系很难，但是对于像素来说，是可以有明确的遮挡关系的。对于2D场景中任意一个点$(x, y)$，存储其深度（depth）信息$z$，每次绘制像素点$(x, y)$时，比较其与zbuffer(x, y)的值进行比较，如果小的话则将深度其存储在zbuffer中，并将其颜色信息存储在framebuffer中。当场景计算完毕之后，再通过framebuffer进行绘制。伪代码如下：<br><pre><code class="hljs gml"><span class="hljs-keyword">for</span> (each triangle T)    <span class="hljs-keyword">for</span> (each sample (<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>,z) in T)        <span class="hljs-keyword">if</span> (z &lt; zbuffer[<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>])             framebuffer[<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>] = rgb; <span class="hljs-comment">// 存储颜色信息</span>            zbuffer[<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>] = z; <span class="hljs-comment">// 存储z信息</span>        <span class="hljs-keyword">else</span>            ... <span class="hljs-comment">// do nothing</span></code></pre></p><h2 id="光照和着色"><a href="#光照和着色" class="headerlink" title="光照和着色"></a>光照和着色</h2><p>着色（shading）过程是渲染过程非常关键的一步，简单来说就是光栅化过程中计算每个采样点的颜色色值。在词典中着色的解释如下：</p><pre><code class="hljs mipsasm"><span class="hljs-keyword">shad·ing, </span>[ˈʃeɪdɪŋ], nounThe darkening <span class="hljs-keyword">or </span>coloring of an illustration <span class="hljs-keyword">or </span><span class="hljs-keyword">diagram </span>with parallel lines <span class="hljs-keyword">or </span>a <span class="hljs-keyword">block </span>of color.</code></pre><p>正如解释所说，shading过程实际上就是引入明暗不同以及颜色的变化，在图形学课程中，往往shading指对不同的物体，应用不同的材质。</p><p>对于一个物体而言，我们之所以能看见他，是因为光线在其表面发生了反射和吸收，之后传达到了人眼中。物体将特定频率的光线进行反射，也形成了其颜色。在相同材质的物体上，却有不同的颜色和明暗变化。这是因为光源以及光的反射方式的不同。如下图所示是一个光线的反射场景：<br><img src="/images/graphics6/graphics6_shading.png" alt=""><br>对于光线反射而言，一共有三种反射类型：</p><ol><li>镜面反射</li><li>漫反射</li><li>环境光</li></ol><h3 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h3><p>镜面反射模型比较简单，以光线与反射面接触点（shading point）的法线方向为中界限，入射角等于出射角。影响镜面反射模型的着色因素主要有入射角度、相机角度、法线方向以及表面材质（影响折射率）。<br><img src="/images/graphics6/graphics6_Specula.png" alt=""></p><h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><p>漫反射模型也相对比较简单。理论上在漫反射模型中，无论光源的位置在任何地方，在反射面都会形成所有方向的反射光。而且在漫反射模型中，反射光的强度在任何方向上都是一致的，无论入射光的角度在任意的方向。</p><p>但是漫反射能反射多少能量强度的光源与入射角有很直接的关系。假设光源的强度一定时，我们抽象出单位宽度的平行光源，假定在任意角度下，表面材质对漫反射的折射率一定。当入射角度为90度时，理论上反射面能接收被反射所有的光线。但是当反射面与入射光线有一定的夹脚时，反射面就只能接收部分反射光线。此时的光照强度，应该乘于夹角系数$cos\theta = l \cdot n$，其中$l$为入射角的方向，$n$为法线方向。<br><img src="/images/graphics6/graphics6_lambertian.png" alt=""></p><p>另外，对于光线传播来说，传递的光线总是会随着传播的距离能量会随之衰减。以点光源向四面扩散为例，光源发射出来的能量其实是一定的，那么在任意两个圈上接受到的能量之和一定相等。而离圆心越远，圆的面积越大，单位面积所接受能量也就越弱。其到达某个点的光照强度应为：$I/r^2$，其中$I$为光源光照强度，$r$为距离。<br><img src="/images/graphics6/graphics6_energy.png" alt=""></p><p>结合光照强度参数和漫反射的入射角度强度计算，可以得到一个计算漫反射光照强度的公式：<br><img src="/images/graphics6/graphics6_diffuse_function.png" alt=""><br>其中：</p><ul><li>$k_d$ 为漫反射系数，可能会受到材质等影响</li><li>$I$ 为入射光照强度，$r$ 为shading point距离光源的距离</li><li>$n, l$ 分别如图中所示为法线向量和入射方向</li></ul><h3 id="高光"><a href="#高光" class="headerlink" title="高光"></a>高光</h3><p>高光项与漫反射的计算项类似，但是不同的是，漫反射的效果只和入射角度有关，与观察角度的是没有关系的。但是高光与相机的观察角度也是有关系的，在接近出射角的位置，高光最明显，在于远离出射角的位置高光几乎不可见：<br><img src="/images/graphics6/graphics6_Specular.png" alt=""><br>因此对于高光项来说，镜头视角与出射光的夹角对于着色效果影响很大。直接计算这个夹角值相对来说比较困难，因为需要确定出射角的方向。这里Blinn-Phong很巧妙地简化了这一计算，直接计算入射方向 $l$ 和相机视角方向 $v$ 的半程向量 $h$。使用法线 $n$ 与半程向量 $h$的夹角来作为计算参数。</p><p>高光的大小和强度理论上也需要在反射模型中通过公式来体现，对$n \cdot h$增加求幂计算，对整体通过乘于参数$K_s$，就可以控制其大小和强度，其因素变化如下图：<br><img src="/images/graphics6/graphics6_spe_param.png" alt=""></p><p>将上述所有的因素组合起来，得到高光项的计算公式：</p><script type="math/tex; mode=display">L_s = K_s (I/r^2)max(0, \cos{\alpha})^p = K_s(I/r^2)max(0, {h \cdot n})^p</script><h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><p>环境光的着色过程，不依赖于任何的系数的。它只负责绘制绘制物体的轮廓形态，通常只会填充一些固定的颜色，不会考虑物体的光照效果，只是一个估计值。<br><img src="/images/graphics6/graphics6_Ambient.png" alt=""></p><h3 id="Blinn-Phong反射模型"><a href="#Blinn-Phong反射模型" class="headerlink" title="Blinn-Phong反射模型"></a>Blinn-Phong反射模型</h3><p>Blinn-Phong反射模型就是结合了环境光、漫反射、高光三项的计算模型。<br><img src="/images/graphics6/graphics6_combine.png" alt=""></p><p>结合公式来看：</p><script type="math/tex; mode=display">L = L_a + L_d + L_s = K_aI_a + K_d(I/r^2)max(0, n \cdot l) + K_s(I/r^2)max(0, n \cdot h)^p</script><h2 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h2><p>当我们计算出着色信息之后，需要将颜色信息绘制到图形上。在着色过程中，图形上每个像素点的位置和颜色信息都不尽相同。。如果我们单纯地对每个像素点进行计算着色，那么对于那些形状/颜色变化过大地物体就会有非常大地计算量，因此业界有三种着色方式来优化着色过程。</p><h3 id="Flat-Shading-平面着色"><a href="#Flat-Shading-平面着色" class="headerlink" title="Flat Shading(平面着色)"></a>Flat Shading(平面着色)</h3><p>像素着色对于着色的性能消耗较高，因为我们需要对每个像素点进行单独的计算。在实际情况中，往往不需要这么高的精度，因为对于某些图形来说，局部的颜色几乎是相同的。这时候可以通过将图形划分为多个三角形面，单独地对每个三角形进行一次着色，这种方式叫平面着色（Flat Shaing)。但是平面着色有个显著的问题，当三角形划分较大的时候，着色效果很差，因为整块三角形都使用同样的色值，无法做颜色边界区分。</p><h3 id="Gourand-Shading（顶点着色）"><a href="#Gourand-Shading（顶点着色）" class="headerlink" title="Gourand Shading（顶点着色）"></a>Gourand Shading（顶点着色）</h3><p>定点着色的思路和平面着色思路类似，但是它使用了差值的方式来优化平面着色的效果。大体思路是先通过对三角形的顶点的法线方向的颜色计算值进行着色，当其颜色值确定后，三角形内的颜色可以通过插值的方式来计算得出。其明暗处理只在多边形顶点处采用Phong局部反射模型计算光强，而在多边形内的其他点采用双向线性插值，这样做的优点是高效，但是无法很好的处理镜面高光问题，依赖于其所在多面形的相对位置；</p><h3 id="Phong-Shading（像素着色）"><a href="#Phong-Shading（像素着色）" class="headerlink" title="Phong Shading（像素着色）"></a>Phong Shading（像素着色）</h3><p>它对三角形的每个片元进行着色计算。这个方法有时也称为逐片元着色（per-pixel shading）。由于颜色是按片元着色的，因此得到的结果比Gouraud着色好，尤其是用于光亮表面。</p>]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>光照</tag>
      
      <tag>着色</tag>
      
      <tag>渲染模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学5 —— 反走样</title>
    <link href="/2020/09/13/ComputerGraphics5/"/>
    <url>/2020/09/13/ComputerGraphics5/</url>
    
    <content type="html"><![CDATA[<h2 id="走样"><a href="#走样" class="headerlink" title="走样"></a>走样</h2><p>上一节介绍图形的光栅化的过程，经过图形光栅化过程后，可以得到一个像素集合，它将表示我们想要光栅化的图形，这些点被称为采样信号（Sampled Signal）<br><img src="/images/graphics5/graphics5_sample.png" alt=""><br>上图表示了三角形光栅化的过程，可以看到最后形成的采样信号与原信号差距还是比较大的，这种现象就是我们所说的走样(Aliasing)。它对于实际的图形成像的影响非常大，出现走样现象的图形，会在边界处出现各种情况的锯齿，这些锯齿很影响实际的成像体验。</p><p>走样现象实际上是无法完全避免的，即使分辨率更高的分辨率，更精细的模型，更高的渲染渲染性能也于事无补。因为产生走样现象的本质是由于像素本身是离散型的，我们需要有限的像素点来表示无限精细的线，走样是数字化的必然产物。比如在下图中，相当精细的画面实际上在放大之后观察像素也存在着走样的现象。我们能够做的，仅仅是利用各种技术去减轻这种现象。<br><img src="/images/graphics5/graphics5_aliasing.png" alt=""></p><h2 id="走样在信号上的解释"><a href="#走样在信号上的解释" class="headerlink" title="走样在信号上的解释"></a>走样在信号上的解释</h2><p>图形的光栅化过程，实际上是可以通过信号采样和重建过程来表示的。场景中的几何物体投射到屏幕上的过程，实际就是对虚拟场景的采样和重建的过程，所以也可以把图像当作信号来分析。由于存储空间和显示设备分辨率的限制，图像的采样过程也是有损的。<br><img src="/images/graphics5/graphics5_reconstructed.png" alt=""></p><p>从频域的角度来看，实际上成样过程实际上也是通过离散的采样点来模拟原信号的变换过程。对于低频信号而言，不需要太多的采样点就可以很容易模拟出原信号的形态，因为原信号变化波动很慢。但是对于高频信号而言，很容易出现采样点无法还原原信号的情况，一旦采样点越过了多次频率变化，就很难还原原有的信号。频率越高，通过采样点能还原原信号的概率就越低。比如下图，蓝色部分是原信号，由于采样点不足，通过采样点还原信号时还原的信号频率远低于原信号。</p><p><img src="/images/graphics5/graphics5_frequency.png" alt=""></p><p>因此走样的根因和采样过程有关系，最常见的问题就在于采样不足。信号变换太快（高频信号），但是采样的速度跟不上。从时域的角度去看，当采样不足时，就会出现模拟出的信号与信号源有一定的差距，就造成了走样现象。</p><h3 id="Jaggies（锯齿）"><a href="#Jaggies（锯齿）" class="headerlink" title="Jaggies（锯齿）"></a>Jaggies（锯齿）</h3><p>锯齿是在空间中采样的走样现象，造成这种现象的根本原因是因为在空间采样中过程，信号频率变化太快导致的。在图形的边缘型号有带有颜色信息的信号变为无颜色信息的型号，这个过程变化过于剧烈。在采样的过程中如果采样不足，就会造成边缘部分出现无法还原图形的真实形状，就出现了锯齿。比如下图在边缘部分出现严重的锯齿现象。<br><img src="/images/graphics5/graphics5_jaggies.png" alt=""></p><h3 id="Moire-Patterns"><a href="#Moire-Patterns" class="headerlink" title="Moiré Patterns"></a>Moiré Patterns</h3><p>Moiré Patterns 也是因为采样不足导致的，在采样过程中由于采样频率过低，从而导致信号在某些区域内出现缺失。比如说在采样的过程中，跳过了奇数行像素或者偶数行像素的信号。就会出现严重的 Moiré Patterns 现象。<br><img src="/images/graphics5/graphics5_Moiré.jpg" alt=""></p><h2 id="反走样及其原理"><a href="#反走样及其原理" class="headerlink" title="反走样及其原理"></a>反走样及其原理</h2><h3 id="SSAA"><a href="#SSAA" class="headerlink" title="SSAA"></a>SSAA</h3><p>反走样的最直接也最有效的的原理就是增大采样频率，使用尽量多的采样点来还原原始的信号形态。这就是SSAA（Super Sampling Anti-aliasing）的原理。它的原理正如字面意思，将一个像素点分解为多个模拟的像素点，通过这种细分来进行着色（shading）计算，最后在对模拟像素点取平均值，最终的到实际物理像素点的颜色。</p><p>以每个像素点分解为4个模拟像素点为例，对原始的像素点作出分解。正如上面的介绍所说，如果模拟像素点位于三角形内，否则不进行着色，所有模拟像素点着色完成之后，则将其计算颜色的平均值。<br><img src="/images/graphics5/graphics5_SSAA.jpg" alt=""></p><p>最后通过SSAA得到的像素点如右图所示，看起来依旧是存在锯齿的，但是在实际成像过程中，边缘的部分颜色会浅一些，这样锯齿的效果也不会特别明显，能够更还原几何形体的真实形态。</p><h3 id="MSAA"><a href="#MSAA" class="headerlink" title="MSAA"></a>MSAA</h3><p>MSAA（Multi-Sampling Anti-aliasing）是对SSAA的一个改进。SSAA虽然非常直接有效，但是其消耗的性能也是极大的。拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。</p><p>MSAA（Multi-Sampling AA）则很聪明的只是在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次。例如下图是4xMSAA，三角形只覆盖了4个coverage sample中的2个。所以这个三角形需要生成一个fragment在pixel shader里着色，只不过生成的fragment还是在像素中央（位置，法线等信息插值到像素中央）然后只运行一次pixel shader，最后得到的结果在resolve阶段会乘以0.5，因为这个三角形只cover了一半的sample。现代所有GPU都在硬件上实现了这个算法，而且在shading的运算量远大于光栅化的今天，这个方法远比SSAA快很多。</p>]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>光栅化</tag>
      
      <tag>反走样</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学4 ——  光栅化</title>
    <link href="/2020/09/01/ComputerGraphics4/"/>
    <url>/2020/09/01/ComputerGraphics4/</url>
    
    <content type="html"><![CDATA[<blockquote><p>总体来说，栅格化这个术语可以用于任何将向量图形转换成位图的过程,在通常的应用中，这个术语用来表示在计算机上显示三维形状的流行渲染算法。</p><p>栅格化目前是生成实时三维计算机图形最流行的算法。实时应用需要立即响应用户输入，并且通常需要至少每秒 24 帧的速率。辐射着色、光线跟踪等其它渲染技术不同，栅格化的速度非常快，但是由于它不是根据光传输的物理规律进行处理的，所以无法正确模拟许多复杂真实光照环境，只能达到足够欺骗人类眼睛的程度。</p></blockquote><p>以上是Wikipedia对于光栅化的解释，大致上来说，光栅化是顶点数据变换为屏幕像素数据的过程。在光栅化中，我们需要考虑如何将位置信息数据转化为像素信息数据，例如如何在屏幕上进行展示一条线、一个圆，一个三角形。如下图所示，在屏幕中实际显示的最小单位是一个像素点。如何在屏幕中绘制像素信息，或使用哪些像素值来表示图形，是光栅化需要考虑的问题。</p><p>光栅化的基本过程可以用以下伪代码来表示：<br><pre><code class="hljs properties"><span class="hljs-attr">for</span> <span class="hljs-string">(T in trangels):</span>    <span class="hljs-attr">for</span> <span class="hljs-string">(P in pixels):</span>        <span class="hljs-attr">determine</span> <span class="hljs-string">if P is inside T</span></code></pre></p><h2 id="像素（pixels）的表示"><a href="#像素（pixels）的表示" class="headerlink" title="像素（pixels）的表示"></a>像素（pixels）的表示</h2><p>我们使用一个整数坐标点代表一个像素，像素作为光栅化的最小单位，其尺寸是单位大小为1的正方形。其用其中心点$x, y$来表示其位置坐标。如下图所示：<br><img src="/images/graphics4/graphics4_pixels.png" alt=""></p><h2 id="直线光栅化表示"><a href="#直线光栅化表示" class="headerlink" title="直线光栅化表示"></a>直线光栅化表示</h2><p>和绘制一个点相比，绘制一条直线就需要我们关注如何通过直线中每个像素点的位置来表示这个像素点。在photoshop中绘制一条直线时，应用自动产生的像素点的位置。通过下图可以看出，在绘制一条水平或者垂直的直线的时候，只需要连续在对应方向进行绘制即可。但是当直线的斜率为$(0, \infty)$时，表示一条直线就困难很多。此时无法利用像素点直接还原这条直线，只能通过类似表示的方式来表示这条直线。如何绘制直线，演进出很多算法，下面介绍两种直线绘制算法DDA和Bresenham。<br><img src="/images/graphics4/graphics4_lines.png" alt=""></p><h3 id="DDA-Digital-differience-analyzer"><a href="#DDA-Digital-differience-analyzer" class="headerlink" title="DDA(Digital differience analyzer)"></a>DDA(Digital differience analyzer)</h3><p>DDA的绘制过程比较简单，绘制像素的位置都由直线的斜率来决定。指定直线的斜率$k$，每个像素点$X, Y$</p><ol><li>如果斜率$\left | k \right |  &lt; 1$，则$X = X + 1$, $Y = Y + k$</li><li>如果斜率$\left | k \right |  &gt; 1$，则$X = X + 1/k$, $Y = Y + 1$<br>以上所有结果都进行四舍五入进行取整表示，DDA的绘制过程可以通过以下代码来进行表示：</li></ol><pre><code class="hljs cpp"><span class="hljs-comment">// calculate dx , dy</span>dx = X1 - X0;dy = Y1 - Y0;<span class="hljs-comment">// Depending upon absolute value of dx &amp; dy</span><span class="hljs-comment">// choose number of steps to put pixel as</span>steps = <span class="hljs-built_in">abs</span>(dx) &gt; <span class="hljs-built_in">abs</span>(dy) ? <span class="hljs-built_in">abs</span>(dx) : <span class="hljs-built_in">abs</span>(dy);<span class="hljs-comment">// calculate increment in x &amp; y for each steps</span>Xinc = dx / (<span class="hljs-keyword">float</span>) steps;Yinc = dy / (<span class="hljs-keyword">float</span>) steps;<span class="hljs-comment">// Put pixel for each step</span>X = X0;Y = Y0;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= steps; i++)&#123;    putpixel (X, Y, RED);    X += Xinc;    Y += Yinc;&#125;</code></pre><h3 id="Bresenham"><a href="#Bresenham" class="headerlink" title="Bresenham"></a>Bresenham</h3><p>DDA算法按照直线的函数表达式来绘制，但是并不代表它的准确性和效率就高。实际上，在绘制过程中对值取四舍五入的方式不仅浪费性能，而且可能会造成绘制不准。Bresenham算法有效地解决了这些问题，它在绘制过程中，通过对两个备选绘制点的中值进行比较来决定绘制点的位置。</p><p>如下图所示，在斜率 $\left | k \right |  &lt; 1$ 的情况下，当我们绘制下一个点 $(x_k+1, unknown)$ 时，有两个备选点 $(x_k+1, y_k + 1)$ 以及 $(x_k+1, y_k)$ 。这时候我们只需要找出与直线与 $x = x_k + 1$ 相交的交点距离哪个备选点更近即可。<br><img src="/images/graphics4/graphics4_bresenham.png" alt=""><br>观察实际$y$的增长值$y_d$，如果$y_d &gt; 0.5$，则取上面的点，否则取下面的点。实际Bresenham过程也比较简单，但是这里比较涉及到了浮点数$0.5$的计算，性能会退化地和DDA一致。为了避免使用浮点数计算，使用了一种比较巧妙的计算方法。在以下两个条件下做讨论：</p><ol><li>所有的直线的斜率$k\in(0,1)$</li><li>$x_1 &lt; x_2$ 且 $y_1 &lt; y_2$</li></ol><p>此时，每次绘制像素时：</p><ol><li>$X$方向都会向右移动一格</li><li>为了得到$Y$方向的增长值，先计算 $\Delta{y} = (y_2 - y_1)$ $\Delta{x} =(x_2 - x_1)$，根据斜率的性质，可以得出 $\Delta{y} = k\Delta{x}$ </li><li>当 $y$ 增长1个单位时，$x$ 需要增长$1/k$个单位</li><li>我们规定 $2\Delta{y} - \Delta{x}$ 为初始判定值$d$，每次绘制时$d += 2\Delta{y}$</li><li>当 $d &gt;= 0$的时候，说明$Y$轴方向的增长量超过了1，令$y + 1$，然后将$d - 2\Delta{x}$。</li></ol><p>以下是代码表示:</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bresenham</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span> </span>&#123;     <span class="hljs-keyword">int</span> m_new = <span class="hljs-number">2</span> * (y2 - y1);     <span class="hljs-keyword">int</span> slope_error_new = m_new - (x2 - x1);     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = x1, y = y1; x &lt;= x2; x++)     &#123;         <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;         <span class="hljs-comment">// Add slope to increment angle formed </span>        slope_error_new += m_new;         <span class="hljs-comment">// Slope error reached limit, time to </span>        <span class="hljs-comment">// increment y and update slope error. </span>        <span class="hljs-keyword">if</span> (slope_error_new &gt;= <span class="hljs-number">0</span>)         &#123;             y++;             slope_error_new  -= <span class="hljs-number">2</span> * (x2 - x1);         &#125;     &#125; &#125;</code></pre><h2 id="图形光栅化表示"><a href="#图形光栅化表示" class="headerlink" title="图形光栅化表示"></a>图形光栅化表示</h2><p>下面以三角形为例，介绍图形的光栅化过程。在图形光栅化的过程中，我们需要逐行扫描每个像素，判断像素是否处于图形之中，如果处于图形之中就将其采样。</p><p><img src="/images/graphics4/graphics4_sample.png" alt=""></p><p>如何判断点$Q$是否在三角形内呢？对于三角形而言，确定三角形的形状和位置需要确定三角形的三个定点$P_1$、$P_2$、$P_3$。利用向量叉乘的特性，分别计算$\overrightarrow{P_1P_2} \times \overrightarrow{P_1Q}$和$\overrightarrow{P_2P_3} \times \overrightarrow{P_2Q}$以及$\overrightarrow{P_3P_1} \times \overrightarrow{P_3Q}$的值是否是相同正负号的。如果是就说明点$Q$在三角形$P_1P_2P_3$内。<br><img src="/images/graphics4/graphics4_inside.png" alt=""></p><p>逐行扫描对于光栅化过程来说有点过于耗费性能，因为很多情况下区域内只有很小的宇哥图形。如果逐行去扫描不需要着色的像素，会造成严重的性能浪费。因此可以使用一个盒子边界来包裹需要扫描的像素区域，只在这个区域内进行光栅化的过程，大幅提升光栅化的性能。这个特性实际上适用于很多图形学的场景，比如碰撞检测、抗锯齿。<br><img src="/images/graphics4/graphics4_bound_box.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>光栅化</tag>
      
      <tag>bresenham</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学3 —— 视图变换</title>
    <link href="/2020/08/24/ComputerGraphics3/"/>
    <url>/2020/08/24/ComputerGraphics3/</url>
    
    <content type="html"><![CDATA[<p>视图变换（viewing transform）的主要职责是将3D物体的坐标（我们取标准坐标$(x, y, z)$映射到屏幕的一个个像素点上来。它的过程可以说是比较复杂的，因为在视图变换的过程中很多因素可以决定最后成像的效果。视图变换可以分为四个过程，模型变换（modal transform）、 视角变换（view transform）、投影变换（projection transform）以及视口变换（viewport transformation）。这个过程可以拿拍照片来类比：</p><ol><li>站好位置，摆好姿势（modal transform）</li><li>找好角度，调整相机位置（view transform）</li><li>拍摄照片，将3D场景拍摄到2D的照片（projection transform &amp;&amp; viewport transformation）</li></ol><p>在拍照片的过程中我们模拟了视图变换的过程。首先是模型变换，我们需要将模型从模型坐标变换到世界坐标中来，也就是在拍照过程中让人站好姿势、摆好位置。调整相机位置，也就是调整在世界坐标中从哪个方向去观测。这个过程我们需要确定两个方向，一个方向是观测的朝向，另一个方向就是与观测朝向“向上”的方向，比如说我们朝着$-Z$方向去看，那么“向上”方向就是$Y$方向。当以上过程都完成后，我们需要将3D场景转换到2D屏幕上，就需要通过投影的方式做像素映射。</p><p><img src="/images/graphics3/graphics3_transformation.png" alt=""></p><h2 id="相机变换-view-camera-transform"><a href="#相机变换-view-camera-transform" class="headerlink" title="相机变换 view/camera transform"></a>相机变换 view/camera transform</h2><p>结合在上一篇我们讨论的绕任意轴旋转的变换推导中，我们其实可以很容易使用类似的思路来进行推导相机变换。还记得为什么在相机变换的过程中，为什么除了看向方向（look-at direction）之外表示为$g$，还需要一个“向上”的方向（up direction）表示为$t$，有了着两个方向以及相机的位置$e$。<br>我们在根据坐标系法则就可以建立起一个三位坐标$u,v,w$。定义如下：</p><script type="math/tex; mode=display">w =  -\frac{g}{\left |\left | g \right |   \right | }</script><script type="math/tex; mode=display">u = \frac{t \times w }{ \left |\left | {t \times w} \right |   \right |  }</script><script type="math/tex; mode=display">v = w \times u</script><p><img src="/images/graphics3/graphics3_camera.png" alt=""><br>摄像机变换就可以看作将$x,y,z$坐标系转换到$u,v,w$坐标系的过程。我们将变换矩阵写作$M_{view}$，令</p><script type="math/tex; mode=display">M_{view} = R_{view}T_{view}</script><p>其中$R$是改变相机朝向的的变换矩阵，它的作用是使得$-Z$旋转到看向方向$u$，$Y$旋转到“向上“的方向$v$。$T_{view}$是移动相机位置的矩阵，是一个平移矩阵，可以被表示为：</p><script type="math/tex; mode=display">T_{view} =\begin{bmatrix}1 & 0 & 0 & -x_e\\0 & 1 & 0 & -y_e\\0 & 0 & 1 & -z_e\\0 & 0 & 0 & 1\end{bmatrix}</script><p>旋转的过程在前面的章节有提过，如果需要使用$R$变换矩阵，因此$M$可以被表示为：</p><script type="math/tex; mode=display">M_{view} = \begin{bmatrix}x_u & y_u & z_u & 0\\x_v & y_v & z_v & 0\\x_w & y_w & z_w & 0\\0 & 0 & 0 & 1\end{bmatrix}\begin{bmatrix}1 & 0 & 0 & -x_e\\0 & 1 & 0 & -y_e\\0 & 0 & 1 & -z_e\\0 & 0 & 0 & 1\end{bmatrix}</script><h2 id="投影变换-pojection-transform"><a href="#投影变换-pojection-transform" class="headerlink" title="投影变换 pojection transform"></a>投影变换 pojection transform</h2><p>投影变换的过程主要是将3D的点投影到2D的屏幕上来，根据变换条件的不同，可以将投影区分为正交投影和透视投影。如下图所示展现了两种投影的变换方式和成像结果。<br><img src="/images/graphics3/graphics3_banner.png" alt=""></p><h3 id="正交投影-Orthographic-Projection-Transformation"><a href="#正交投影-Orthographic-Projection-Transformation" class="headerlink" title="正交投影 Orthographic Projection Transformation"></a>正交投影 Orthographic Projection Transformation</h3><p>正交投影很好理解，在正交投影之后图形中所有点的的相对位置都不会发生改变，可以将其看作直接将图形“压扁”，然后放置在某一平面上。<br><img src="/images/graphics3/graphic3_orthographic.png" alt=""><br>在实际渲染过程中，我们总是希望在某个空间区域来渲染图形，而非根据整个视图区域来做渲染。假设渲染发生在一个沿着$Z$轴负方向，底面（bottom）与$XY$平面平行的一个立方体。这时候可以定义左右面（left, right）以及近远面（near, far），以及上下面（top, bottom）用以下代数表示：</p><script type="math/tex; mode=display">x = l = left{\space}plane</script><script type="math/tex; mode=display">x = r = right{\space}plane</script><script type="math/tex; mode=display">y = v = bottom{\space}plane</script><script type="math/tex; mode=display">y = t = left{\space}plane</script><script type="math/tex; mode=display">z = n = near{\space}plane</script><script type="math/tex; mode=display">z = f = far{\space}plane</script><p>简单来说，正交投影的主要原理是将上述区域变换到一个”正则、规范、标准“的立方体$[-1, 1]^3$中来。这个变换过程可以分解为两个变换：</p><ol><li>将渲染盒子平移到以原点为中心的位置，即每个定点到投影平面的距离为 边长/2</li><li>将渲染盒子缩放为立方体$[-1, 1]^3$<br><img src="/images/graphics3/graphics3_orthographic_transform.png" alt=""><br>这个过程可以用变换矩阵表示为：<script type="math/tex; mode=display">M_{ortho} = \begin{bmatrix}\frac{2}{r - l} & 0 & 0 & 0\\0 & \frac{2}{t - b} & 0 & 0\\0 & 0 & \frac{2}{n - f} & 0\\0 & 0 & 0 & 1\end{bmatrix} \begin{bmatrix}1 & 0 & 0 & -\frac{r+l}{2}\\0 & 1 & 0 & -\frac{t+b}{2}\\0 & 0 & 1 & -\frac{n+f}{2}\\0 & 0 & 0 & 1\end{bmatrix}</script><h3 id="透视投影-Perspective-Projection-Transformation"><a href="#透视投影-Perspective-Projection-Transformation" class="headerlink" title="透视投影 Perspective Projection Transformation"></a>透视投影 Perspective Projection Transformation</h3>透视投影和正交投影最大的区别在于，透视投影的过程不是“平行的”，投影的线最终会相交。因为透视投影需要实现真实的透视关系，也就是相等大小的物体，处于场景近端他会显示得更大，处于场景远端它会显示得更小。对于任意一点的投影过程可以用下图来表示：</li></ol><p><img src="/images/graphics3/graphic3_orthographic_point.png" alt=""></p><p>对于任意点$[x, y, z]$, 经过透视投影变换后到投影平面上，形成$[x^{\prime}, y^{\prime}, z^{\prime}]$。图中的$z = -n$为投影平面，也就是我们的$near$面，假定$[x, y, z]$所在的与$XY$平面平行的面为$far$面。根据相似三角形法则，对于$y^{\prime}$可以得到：</p><script type="math/tex; mode=display">y^{\prime} = \frac{n}{z}y {\space}{\space}{\space}{\space}{\space}x^{\prime} = \frac{n}{z}x</script><p>为了推导投影矩阵，我们列出其原点和投影点的关系，当被投影点坐标全部乘以$z$的时候，被投影点坐标变化如下：</p><script type="math/tex; mode=display"> \begin{pmatrix} x\\ y\\ z\\ 1\end{pmatrix}\Rightarrow  \begin{pmatrix} nx/z\\ ny/z\\ unknown\\ 1\end{pmatrix}== \begin{pmatrix} nx\\ ny\\ still{\space}unknown\\ z\end{pmatrix}</script><p>因此我们想要求的投影矩阵是执行了如下变化：</p><script type="math/tex; mode=display">M_{persp{\to}ortho}^{4\times4}:{\space}\begin{pmatrix} x\\ y\\ z\\ 1\end{pmatrix}== \begin{pmatrix} nx\\ ny\\ still{\space}unknown\\ z\end{pmatrix}</script><p>根据上面的变换过程我们可以将变换矩阵的确定项先写出来：</p><script type="math/tex; mode=display">M_{persp{\to}ortho}^{4\times4}= \begin{bmatrix} n & 0 & 0 & 0\\ 0 & n & 0 & 0\\ ? & ? & ? & ?\\ 0 & 0 & 0 &1 \end{bmatrix}</script><p>接下来就是如何确定不确定的这行的值了，在透视投影的可视空间中，发生透视变换后有两个特性：</p><ol><li>所有在$near$面上的点，经过透视投影变换后其坐标值是不变的。</li><li>所有在$far$面上的点，经过透视投影变换后其$z$值是不变的。</li></ol><p>对于特性1，我们可以假定在near平面上的点$(x,y,n,1)^T$，经过变换之后，其坐标仍然保持不变。将所有坐标乘以$n$，得到：</p><script type="math/tex; mode=display">M_{persp{\to}ortho}^{4\times4} \begin{pmatrix} x\\ y\\ n\\ 1\end{pmatrix}\Rightarrow \begin{pmatrix} x\\ y\\ n\\ 1\end{pmatrix}==\begin{pmatrix} nx\\ ny\\ n^2\\ n\end{pmatrix}</script><p>通过上面的变换，我们可以得出一个结论——未知行额前两项必定为0，因为经过变换后的$z$值与$x,y$无关。因此假定最后一行为$(0,0,A,B)$，再计算第三行的乘法：</p><script type="math/tex; mode=display">\begin{pmatrix} 0 {\space} 0 {\space} A {\space} B \end{pmatrix}\begin{pmatrix} x \\ y \\ n \\ 1 \end{pmatrix}=n^2\Rightarrow An + B = n^2</script><p>同理，利用特性二所有在$far$平面上的点的$z$值不会发生变化：</p><script type="math/tex; mode=display">M_{persp{\to}ortho}^{4\times4} \begin{pmatrix} 0\\ 0\\ f\\ 1\end{pmatrix}\Rightarrow \begin{pmatrix} 0\\ 0\\ f\\ 1\end{pmatrix}==\begin{pmatrix} 0\\ 0\\ f^2\\ f\end{pmatrix}\Rightarrow Af + B = f^2</script><p>联立两个等式，得到：</p><script type="math/tex; mode=display">A = f + n</script><script type="math/tex; mode=display">B = -nf</script><p>因此变换矩阵$M_{persp{\to}ortho}^{4\times4}$的值为：</p><script type="math/tex; mode=display">M_{persp{\to}ortho}^{4\times4} =   \begin{bmatrix} n & 0 & 0 & 0\\ 0 & n & 0 & 0\\ 0 & 0 & f+n & -nf \\ 0 & 0 & 0 &1 \end{bmatrix}</script><p>实际上，完成透视变换之后，再进行一次正交投影变换就彻底完成了以上透视投影变换：</p><script type="math/tex; mode=display">M_{persp} = M_{ortho}M_{persp{\to}ortho}</script>]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>投影，视图变换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学2 —— 图形变换扩展</title>
    <link href="/2020/08/17/ComputerGraphics2/"/>
    <url>/2020/08/17/ComputerGraphics2/</url>
    
    <content type="html"><![CDATA[<h2 id="线性变换的组合和分解"><a href="#线性变换的组合和分解" class="headerlink" title="线性变换的组合和分解"></a>线性变换的组合和分解</h2><h3 id="线性变换的组合"><a href="#线性变换的组合" class="headerlink" title="线性变换的组合"></a>线性变换的组合</h3><p>在前文我们提到，所有的线性变换都可以扩展成为变换矩阵左乘于源坐标点的数学表示。当对一个向量应用多次变换时的数学表示则是按照顺序分别左乘变换矩阵：</p><script type="math/tex; mode=display">first, v_2 = Sv_1, then, v_3 = Rv_2</script><p>可以被表示为：</p><script type="math/tex; mode=display">v_3 = R(Sv_1)</script><p>根据矩阵计算的结合律可以推导为：</p><script type="math/tex; mode=display">v_3 = (RS)v_1</script><p>根据上面的推导可以发现一个规律，矩阵经过的两次变换$S$、$R$，可以表示为一次变换矩阵$M$，其中$M = RS$。其中矩阵乘法的顺序很重要。<br><img src="/images/graphics2/graphics2_compose.png" alt=""></p><h3 id="线性变换的分解"><a href="#线性变换的分解" class="headerlink" title="线性变换的分解"></a>线性变换的分解</h3><p>既然多个变换矩阵可以合并为同一个变换矩阵，那么一个变换矩阵也可以被分解为多个变换矩阵的乘积。利用矩阵分解知识我们知道，对于给定 $A_{n*n}$ 的方阵，如果其具有n个线性无关的特征向量，那么可以被分解为，正交矩阵与对角矩阵相乘的形式，这个过程：</p><script type="math/tex; mode=display">A = RSR^T</script><p>其中 $R$ 为特征向量组成的正交矩阵，$S$ 为其特征值组成的对角矩阵。在$n=2$的情况下，$R$ 由其特征向量 $v_1, v_2$ 组成，$R = [v_1, v_2]$。$S$的对角值分别为其特征值 $\lambda_1$、$\lambda_2$。</p><p>根据其分解出的矩阵的特点，我们可以通过几何意义来对 $A$ 进行线性变换分解，$R$ 可以看作是一个旋转变换，$S$可以看作是缩放变换，因此原变换矩阵 $A$ 被分解为以下三个步骤：</p><ol><li>将其特征向量 $v_1$ 和 $v_2$ 旋转到 $x, y$轴上即变换矩阵 $R^T$。</li><li>将变换后的矩阵进行缩放，$x, y$ 方向分别被缩放 $(\lambda_1, \lambda_2)$ 即变换矩阵$S$。</li><li>将变换后的特征向量 $v_1$ 和 $v_2$ 旋转回原来的位置即变换矩阵 $R$<br><img src="/images/graphics2/graphics2_decompose.png" alt=""></li></ol><h3 id="绕任意轴旋转"><a href="#绕任意轴旋转" class="headerlink" title="绕任意轴旋转"></a>绕任意轴旋转</h3><p>前文中提到了绕 $x, y, z$轴旋转的变换矩阵，根据矩阵分解和组合的特性我们可以推倒出绕任意轴旋转的变换矩阵。绕任意轴旋转可以被分解为以下三步：</p><ol><li>通过变换矩阵$R_{uvw}^T$将需要做旋转的向量的向量空间变换到笛卡尔坐标系中，使得原向量空间下的 $u, v ,w$ 和 $x, y, z$做对齐。</li><li>做绕 $x$ 轴的旋转，变换矩阵为标准旋转矩阵$R_x$</li><li>通过变换矩阵$R_{uvw}$将旋转后的矩阵, 在重新变换为原向量空间下的 $u, v, w$中。</li></ol><p>以上过程可以用以下公式表示：</p><script type="math/tex; mode=display">R_a = R_{uvw} R_x R_{uvw}^T</script><p>下面讨论下$R_{uvw}$这个矩阵，这里面会涉及到一部分向量空间的知识。为了方便理解，这里先不过多的讨论理论知识，按照方便理解的方式来进行讨论。假设$x, y, z$轴三个方向上的单位向量组成的矩阵：</p><script type="math/tex; mode=display">R_E = \begin{bmatrix}1 & 0 & 0\\0 & 1 & 0\\0 & 0 & 1\end{bmatrix}</script><p>这三个向量互为正交，因此当我们为其做一些线性变换后(比如说绕z轴旋转45度后再绕y轴旋转45度，然后在缩放2倍)，三个向量依旧是正交的，通过线性变换 $R<em>{uvw}^T$ 变换之后，我们可以得到正交矩阵 $R</em>{uvw}$ </p><script type="math/tex; mode=display">R_{uvw} = \begin{bmatrix}x_u & x_v & x_w\\y_u & y_v & y_w\\z_u & z_v & z_w\end{bmatrix}</script><p>下面证明上面的表达式为何能成立，假定$u = x_ux + y_uy + z_uz$，$v, w$同理，根据正交矩阵的特性，可以得到以下推倒：</p><script type="math/tex; mode=display">u  \cdot u = v \cdot v = w \cdot w = 1</script><script type="math/tex; mode=display">u \cdot v = v \cdot w = w \cdot u = 0</script><p>利用这个特性，我们可以使用变换矩阵$R_{uvw}$将u变换到x轴上：</p><script type="math/tex; mode=display">R_{uvw}u = \begin{bmatrix}x_u & x_v & x_w\\y_u & y_v & y_w\\z_u & z_v & z_w\end{bmatrix}\begin{bmatrix}x_u \\y_u \\z_u\end{bmatrix}= \begin{bmatrix}x_ux_u + y_vy_v + z_wz_w\\x_vx_u + y_vy_u + z_vy_u\\x_wx_u + y_wy_u + z_wx_u\end{bmatrix}</script><p>上式可以被化简为：</p><script type="math/tex; mode=display">R_{uvw}u = \begin{bmatrix}u \cdot u\\v \cdot u\\w \cdot u= \end{bmatrix}=\begin{bmatrix}1 \\0 \\0\end{bmatrix}= x</script><p>同理可以推导出$R<em>{uvw}v = y$以及$R</em>{uvw}w = z$<br>对于还原变换矩阵$R_{uvw}^T$同理也可以通过上述方式推导如何将坐标轴${x, y, z}$变换到$u, v, w$上去。<br>总结来看，对于任意轴的旋转可以用下列公式进行表示：</p><script type="math/tex; mode=display">R_a = R_{uvw} R_x R_{uvw}^T = \begin{bmatrix}x_u & y_u & z_u\\x_v & y_v & z_v\\x_w & y_w & z_w\end{bmatrix}\begin{bmatrix}cos\varphi & -sin\varphi & 0\\sin\varphi & cos\varphi & 0\\0 & 0 & 1\end{bmatrix}\begin{bmatrix}x_u & x_v & x_w\\y_u & y_v & y_w\\z_u & z_v & z_w\end{bmatrix}</script><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><p>平移操作也是矩阵中经常会出现的情况，它变换后的坐标$x^\prime,y^\prime$可以很方便的通过公式表示:</p><script type="math/tex; mode=display">x^\prime = x + x_t</script><script type="math/tex; mode=display">y^\prime = y = y_t</script><p>但是平移变换很难通过与待变换矩阵同纬度的变换矩阵来进行表示，因为它不属于线性变换。这里需要引入其次坐标的概念，通过原本是n维的向量用一个n+1维向量来表示。比如我们原有的平面中的点$(x, y)$升纬到3D表示为：$[x, y, 1]^T$，这样就可以将平移操作表示3D中的线性变换矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix}m_{11} & m_{12} & x_t\\m_{21} & m_{22} & y_t\\0 & 0 & 1\end{bmatrix}</script><p>此时再对$x^\prime,y^\prime$做计算，可以得到：</p><script type="math/tex; mode=display">\begin{bmatrix}x^\prime \\y^\prime \\1\end{bmatrix}=\begin{bmatrix}m_{11} & m_{12} & x_t\\m_{21} & m_{22} & y_t\\0 & 0 & 1\end{bmatrix}\begin{bmatrix}x \\y \\1\end{bmatrix}= \begin{bmatrix}m_{11}x + m_{12}y + x_t\\m_{21}x + m_{22}y + y_t\\1\end{bmatrix}</script><p><strong>注：在其次坐标中最后一维取值为0时，代表一个方向，取值为1时代表一个点</strong></p>]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用latex来书写数学公式2 —— latex数学公式</title>
    <link href="/2020/08/11/latexlearning2/"/>
    <url>/2020/08/11/latexlearning2/</url>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>LATEX 使用一种特有的模式来排版数学(mathematics) 公式。数学公式允许以 行间形式排版在一个段落之中，也可以以独立形式排版，此时段落可能会被拆 开。处于段内的数学文本要放在 <code>\(</code> 与<code>\)</code> 之间，$ 与$ 之间，或者<code>\begin&#123;math&#125;</code> 与 <code>\end&#123;math&#125;</code> 之间。</p><p>例如<code>c^&#123;2&#125;=a^&#123;2&#125;+b^&#123;2&#125;</code>经过latex转换为公式：</p><script type="math/tex; mode=display">c^{2}=a^{2}+b^{2}</script><p><code>100 m^&#123;3&#125;  \heartsuit</code>转换为：</p><script type="math/tex; mode=display">100 m^{3} \heartsuit</script><script type="math/tex; mode=display">\lim_{n \to \infty} \sum_{k=1}^n \frac{1}{k^2} = \frac{\pi^2}{6}</script>]]></content>
    
    
    <categories>
      
      <category>latex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>latex</tag>
      
      <tag>排版</tag>
      
      <tag>论文写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用latex来书写数学公式1 —— latex基础知识</title>
    <link href="/2020/08/10/latexlearning1/"/>
    <url>/2020/08/10/latexlearning1/</url>
    
    <content type="html"><![CDATA[<h2 id="TEX-amp-amp-LATEX"><a href="#TEX-amp-amp-LATEX" class="headerlink" title="TEX &amp;&amp; LATEX"></a>TEX &amp;&amp; LATEX</h2><p>TEX 是Donald E. Knuth 编写的一个以排版文章及数学公式为目标的计算机程序。1977 年，在意识到恶劣的排版质量正在影响自己的著作及文章后，Knuth 开始编写TEX 排版系统引擎，探索当时开始进入出版工业的数字印刷设备的潜 力，尤为希望能扭转排版质量下滑的这一趋势。我们现在使用的TEX 系统发布于 1982 年，在 1989 年又稍做改进，增加了对 8 字节字符及多语言的支持。TEX 以其卓越的稳定性、可在不同类型的电脑上运行以及几乎没有缺陷而著称。TEX 的版本号不断趋近于 π，现在为 3.141592。</p><p>LATEX 是一个宏集，它使用一个预先定义好的专业版面，可以使作者们高质量的 排版和打印他们的作品。LATEX 最初由 Leslie Lamport 编写，它使用 TEX 程序作为排版引擎。</p><h2 id="LATEX源文件"><a href="#LATEX源文件" class="headerlink" title="LATEX源文件"></a>LATEX源文件</h2><p>LATEX 源文件为普通的ASCII 文件，你可以使用任何文本编辑器来创建。LATEX 源文件不仅包含了要排版的文本，而且也包含了告诉LATEX 如何排版这些文本内 容的命令。</p><h3 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h3><p>空格和制表符等空白字符在LATEX 中被看作相同的空白距离(space)。多个连续 的空白字符等同于一个空白字符。在句首的空白距离一般会被忽略，单个空行也 被认为是一个“空白距离”。</p><p>两行文本间的空白行标志着上段的结束和下段的开始。多个空白行的作用 等同于一个空白行。下面便是一个例子，上边是源文件中的文本，下边是排版后的结果。</p><pre><code class="hljs latex">It does not matter whether you enter one or several    spaces after a word.An empty line starts a new paragraph.</code></pre><p><img src="/images/latex/latex1_graph1.png" alt=""></p><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>下面的这些字符是 LATEX 中的保留字符(reserved characters)，它们或在LATEX 中 有特殊的意义，或不一定存在于所有字库中。如果你直接在文本中输入这些字符，通常它们不会被输出，而且还会导致 LATEX 做一些你不希望发生的事情。需要在这些字符前加上反斜线，它们才可以正常的输出到文档中。<br><pre><code class="hljs latex"># <span class="hljs-formula">$ % ^ &amp; _ &#123; &#125; <span class="hljs-tag">\<span class="hljs-name"> </span></span></span><span class="hljs-formula"></span><span class="hljs-formula">#添加反斜线可以输出到文档中</span><span class="hljs-formula"><span class="hljs-tag">\<span class="hljs-name">#</span></span> <span class="hljs-tag">\<span class="hljs-name">$</span></span> <span class="hljs-tag">\<span class="hljs-name">%</span></span> <span class="hljs-tag">\<span class="hljs-name">^</span><span class="hljs-string">&#123;&#125;</span></span> <span class="hljs-tag">\<span class="hljs-name">&amp;</span></span> <span class="hljs-tag">\<span class="hljs-name">_</span></span> <span class="hljs-tag">\<span class="hljs-name">&#123;</span></span> <span class="hljs-tag">\<span class="hljs-name">&#125;</span></span> <span class="hljs-tag">\<span class="hljs-name">&#123;</span></span>&#125;</span></code></pre></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>ATEX 命令(commands) 是大小写敏感的，有以下两种格式:</p><ul><li>以一个反斜线(backslash)\开始，命令名只由字母组成。命令名后的空格 符、数字或任何非字母的字符都标志着该命令的结束。</li><li>由一个反斜线和非字母的字符组成。</li></ul><p>LATEX 忽略命令之后的空白字符。如果你希望在命令后得到一个空格，可以 在命令后加上{} 和一个空格，或加上一个特殊的空格命令。{} 将阻止LATEX 吃掉命令后的所有空格。<br><pre><code class="hljs latex">I read that Knuth divides the  people working with <span class="hljs-tag">\<span class="hljs-name">TeX</span><span class="hljs-string">&#123;&#125;</span></span> into <span class="hljs-tag">\<span class="hljs-name">TeX</span><span class="hljs-string">&#123;&#125;</span></span>nicians and <span class="hljs-tag">\<span class="hljs-name">TeX</span></span> perts.<span class="hljs-tag">\<span class="hljs-name">\</span></span> Today is <span class="hljs-tag">\<span class="hljs-name">today</span></span>. </code></pre><br><img src="/images/latex/latex1_graph2.png" alt=""></p><p>有些命令需要一个参数(parameter)，该参数用花括号(curly braces) { } 括 住并写在命令的后面。一些命令支持可选参数(optional parameters)，可选参数可用方括号(square brackets) [ ] 括住，然后写在命令的后面。</p><pre><code class="hljs latex">You can <span class="hljs-tag">\<span class="hljs-name">textsl</span><span class="hljs-string">&#123;lean&#125;</span></span> on me!</code></pre><p><img src="/images/latex/latex1_graph3.png" alt=""></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>当LATEX 处理一个源文件时，如果遇到一个百分号%，LATEX 将忽略%后的该行内容，换行符以及下一行前的空白字符。</p><p>我们可以据此在源文件中写一些注释，而且这些注释并不会出现在最后的排版结果中。</p><pre><code class="hljs latex">This is an <span class="hljs-comment">% stupid</span><span class="hljs-comment">% Better: instructive &lt;---- example: Supercal%</span>              ifragilist<span class="hljs-comment">%</span>    icexpialidocious</code></pre><p><img src="/images/latex/latex1_graph4.png" alt=""></p><p>如果注释的内容较长，你可以使用verbatim 宏包提供的comment环境。<br><pre><code class="hljs latex">This is another <span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;comment&#125;</span></span>rather stupid,but helpful<span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;comment&#125;</span></span>example for embedding comments in your document.</code></pre><br><img src="/images/latex/latex1_graph5.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>latex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>latex</tag>
      
      <tag>排版</tag>
      
      <tag>论文写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学1 —— 线性变换</title>
    <link href="/2020/08/10/ComputerGraphics1/"/>
    <url>/2020/08/10/ComputerGraphics1/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在图形学中，图形位置形态的数学定义是坐标中的一个个坐标点的集合，因此图形的变换操作通过数学计算来进行。为了简化计算思路，通常我们会将这些变化通过线性代数的方式抽象为变换矩阵 (Transformation Marices)。一切物体的缩放，旋转，位移，都可以通过变换矩阵作用得到。当我们确定好了某种变化的变换矩阵后，可以将其应用在任何其他图形上。本文将介绍基本图形变化中如何利用变换矩阵来进行图形变换。</p><h2 id="2D线性变换"><a href="#2D线性变换" class="headerlink" title="2D线性变换"></a>2D线性变换</h2><p>在2D图形中，我们规定 $[x, y]^T$ 为图形上的任意一个点（也可以看作是一个二维向量），2D基于原点的线性变化可以被定义为向量 $[x, y]^T$ 左乘变换矩阵的数学表示：</p><script type="math/tex; mode=display">\begin{bmatrix} a_{11} & a_{12}\\ a_{21} & a_{22}\end{bmatrix}\begin{bmatrix} x \\ y\end{bmatrix}=\begin{bmatrix} a_{11}x & a_{12}y\\ a_{21}x & a_{22}y\end{bmatrix}</script><h3 id="缩放（scale）"><a href="#缩放（scale）" class="headerlink" title="缩放（scale）"></a>缩放（scale）</h3><p>缩放操作是将图形中所有点的坐标整体放大或者缩小某个数值，如下图所示的变换分别将$x, y$分别缩小了0.5:</p><p><img src="/images/graphics1/graphics1_scale.png" alt=""><br>$[x, y]^T$经过变换后表示为$[x\prime, y\prime]^T$，经过变化后的值可以表示为：</p><script type="math/tex; mode=display">x\prime = 0.5 \times x + 0 \times y</script><script type="math/tex; mode=display">y\prime = 0 \times x + 0.5 \times y</script><p>上述操作可以使用变换矩阵表示为：</p><script type="math/tex; mode=display">scale(s_x, s_y)= \begin{bmatrix} s_x & 0\\ 0 & s_y\end{bmatrix}</script><h3 id="剪切（Shear）"><a href="#剪切（Shear）" class="headerlink" title="剪切（Shear）"></a>剪切（Shear）</h3><p>剪切变换可以简单理解为将图形的一段固定，将其对端沿着固定方向拉动。以固定x轴为例：<br><img src="/images/graphics1/graphics1_shear.png" alt=""><br>所有点的$y$值保持不变，x坐标加上了对应的y值，经过变化后的值表示为：</p><script type="math/tex; mode=display">x\prime =  x + 1 \times y</script><script type="math/tex; mode=display">y\prime = 0 \times x + y</script><p>上述操作可以使用变换矩阵表示为：</p><script type="math/tex; mode=display">shearX(s)= \begin{bmatrix} 1 & s\\ 0 & 1\end{bmatrix}</script><script type="math/tex; mode=display">shearY(s)= \begin{bmatrix} 1 & 0\\ s & 1\end{bmatrix}</script><h3 id="翻转（reflection）"><a href="#翻转（reflection）" class="headerlink" title="翻转（reflection）"></a>翻转（reflection）</h3><p>翻转一般是通过将某个坐标轴的所有值取反得到的，其变换矩阵可以表示为：<br>上述操作可以使用变换矩阵表示为：</p><script type="math/tex; mode=display">reflectionY= \begin{bmatrix} -1 & 0\\ 0 & 1\end{bmatrix}</script><script type="math/tex; mode=display">reflectionX= \begin{bmatrix} 1 & 0\\ 0 & -1\end{bmatrix}</script><p>以X轴翻转为例，经过变化矩阵计算后，图形变换如下：<br><img src="/images/graphics1/graphics1_reflection.png" alt=""></p><h3 id="旋转（rotate）"><a href="#旋转（rotate）" class="headerlink" title="旋转（rotate）"></a>旋转（rotate）</h3><p>旋转的几何意义很容易理解，图形绕着原点逆时针旋转，但是数学上的变换关系并没有上述几种变换直观。为了便于理解，我们先假定图形中的一个任意向量 $\vec{a}$ ，它与x轴的夹角为$\alpha$，坐标为 $[x_a, y_a]$ 。向量的长度表示为  $r^2 = x_a^2 + y_a^2$ ，因此其坐标可以表示为：</p><script type="math/tex; mode=display">x_a = rcos\alpha</script><script type="math/tex; mode=display">y_a = rsin\alpha</script><p>当 $\vec{a}$ 旋转了任意角度 $\varphi$ 之后得到 $\vec{b}$，此时 $\vec{b}$ 与x轴的夹角为 $(\alpha + \varphi)$，坐标为$[x_b, y_b]$ 被表示为：</p><script type="math/tex; mode=display">x_b = rcos(\alpha + \varphi) = rcos\alpha cos\varphi - rsin\alpha sin\varphi</script><script type="math/tex; mode=display">y_b = rsin(\alpha + \varphi) = rsin\alpha cos\varphi + r sin\alpha sin\varphi</script><p>根据$x_a = rcos\alpha$以及$y_a = rsin\alpha$我们可以化简得到：</p><script type="math/tex; mode=display">x_b = x_a cos\varphi - y_a sin\varphi</script><script type="math/tex; mode=display">y_b = y_a cos\varphi + x_a sin\varphi</script><p>变换矩阵可以表示为：</p><script type="math/tex; mode=display">rotate(\varphi) = \begin{bmatrix} cos\varphi & -sin\varphi\\ sin\varphi & cos\varphi\end{bmatrix}</script><p>举一个简单的旋转的例子，让图形逆时针旋转$\pi/4$，变换矩阵的值为：</p><script type="math/tex; mode=display">\begin{bmatrix}cos\varphi & -sin\varphi\\sin\varphi & cos\varphi\end{bmatrix}= \begin{bmatrix}0.707 & -0.707\\0.707 & 0.707\end{bmatrix}</script><p>图形坐标经过计算后的样式如下：<br><img src="/images/graphics1/graphics1_rotate.png" alt=""></p><h2 id="3D线性变换"><a href="#3D线性变换" class="headerlink" title="3D线性变换"></a>3D线性变换</h2><p>了解了2D线性变换之后，3D线性变换的推倒思路是一致的，仅仅是多增加了一个纬度的判断罢了。</p><h3 id="缩放、剪切、翻转"><a href="#缩放、剪切、翻转" class="headerlink" title="缩放、剪切、翻转"></a>缩放、剪切、翻转</h3><p>3D缩放比较简单，直接通过2D缩放进行扩展：</p><script type="math/tex; mode=display">scale(s_x, s_y, s_z) = \begin{bmatrix}s_x & 0 & 0\\0 & s_y & 0\\0 & 0 & s_z\end{bmatrix}</script><p>3D剪切也可以通过2D剪切做类似的扩展：</p><script type="math/tex; mode=display">shearX(d_y, d_z) = \begin{bmatrix}1 & d_y & d_z\\0 & 1 & 0\\0 & 0 & 1\end{bmatrix}</script><p>3D的旋转稍稍复杂一点点，因为在3D场景下旋转可以是以原点为中心绕着任意轴进行旋转。在2D中是由x轴向y轴旋转，换算到3D空间中就是绕着z轴进行旋转(绕z轴，z的值不会发生变化，因此变换矩阵第三行没有变化)：</p><script type="math/tex; mode=display">rotateZ(\varphi) = \begin{bmatrix}cos\varphi & -sin\varphi & 0\\sin\varphi & cos\varphi & 0\\0 & 0 & 1\end{bmatrix}</script><p>绕着x轴的旋转可以理解为在2D场景下的yz平面，由y轴转向z轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：</p><script type="math/tex; mode=display">rotateX(\varphi) = \begin{bmatrix}1 & 0 & 0\\0 & cos\varphi & -sin\varphi\\0 & sin\varphi & cos\varphi\end{bmatrix}</script><p>绕着y轴的旋转可以理解为在2D场景下的xz平面，由z轴转向x轴(x轴的数值没有变化所以，变换矩阵第一行没有变化)：</p><script type="math/tex; mode=display">rotateY(\varphi) = \begin{bmatrix}cos\varphi & 0 & sin\varphi\\0 & 1 & 0\\-sin\varphi & 0  & cos\varphi\end{bmatrix}</script>]]></content>
    
    
    <categories>
      
      <category>GAMES101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
